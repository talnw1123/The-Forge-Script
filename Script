repeat wait(2) until game:IsLoaded()
task.wait(180)
-- bundled_quests_v4_original_linear.lua
-- Auto Quest Runner (Original logic from 1.lua‚Äì18.lua)
-- NOTE:
--   - ‡πÅ‡∏ï‡πà‡∏•‡∏∞ Quest ‡πÉ‡∏ä‡πâ logic ‡πÄ‡∏î‡∏¥‡∏°‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö 1.lua‚Äì18.lua
--   - ‡∏ú‡∏°‡πÅ‡∏Ñ‡πà wrap ‡πÄ‡∏õ‡πá‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô RunQuestXX() ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÅ‡∏Å‡πâ logic ‡∏Ç‡πâ‡∏≤‡∏á‡πÉ‡∏ô
--   - ‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡∏°‡∏µ Linear Runner ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏Å RunQuest01..RunQuest18 ‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô

----------------------------------------------------------------
-- ‚úÖ WAIT FOR UI LEVEL TO LOAD (FIXED)
----------------------------------------------------------------
print("‚è≥ Waiting for UI to fully load...")
print("   Checking for Player Level UI...")

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local function waitForLevelUI()
    local maxAttempts = 60  -- ‡∏£‡∏≠‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 60 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á (60 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)
    local attempt = 0
    
    while attempt < maxAttempts do
        attempt = attempt + 1
        
        -- ‚úÖ FIX: ‡πÄ‡∏ä‡πá‡∏Ñ nil ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô
        local main = playerGui:FindFirstChild("Main")
        if not main then
            print(string.format("   ‚è≥ Waiting for Main UI... (Attempt %d/%d)", attempt, maxAttempts))
            task.wait(1)
            continue
        end
        
        local screen = main:FindFirstChild("Screen")
        if not screen then
            print(string.format("   ‚è≥ Waiting for Screen UI... (Attempt %d/%d)", attempt, maxAttempts))
            task.wait(1)
            continue
        end
        
        local hud = screen:FindFirstChild("Hud")
        if not hud then
            print(string.format("   ‚è≥ Waiting for Hud UI... (Attempt %d/%d)", attempt, maxAttempts))
            task.wait(1)
            continue
        end
        
        local levelUI = hud:FindFirstChild("Level")
        if not levelUI then
            print(string.format("   ‚è≥ Waiting for Level UI... (Attempt %d/%d)", attempt, maxAttempts))
            task.wait(1)
            continue
        end
        
        -- ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô TextLabel
        if not levelUI:IsA("TextLabel") then
            print(string.format("   ‚ö†Ô∏è Level UI is not TextLabel! (Attempt %d/%d)", attempt, maxAttempts))
            task.wait(1)
            continue
        end
        
        -- ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ Text
        local levelText = levelUI.Text or ""
        if levelText == "" or levelText == nil then
            print(string.format("   ‚è≥ Level UI found but empty... (Attempt %d/%d)", attempt, maxAttempts))
            task.wait(1)
            continue
        end
        
        -- ‚úÖ ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!
        print(string.format("   ‚úÖ Level UI found! (Attempt %d/%d)", attempt, maxAttempts))
        print(string.format("   üìä Player Level: %s", levelText))
        return true
    end
    
    warn("‚ùå Failed to find Level UI after " .. maxAttempts .. " attempts!")
    warn("   Continuing anyway, but Quest may fail...")
    return false
end

-- ‡∏£‡∏≠‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏à‡∏≠ UI Level
local uiReady = waitForLevelUI()

if uiReady then
    print("‚úÖ UI fully loaded! Starting quests...")
    print(string.rep("=", 60))
else
    warn("‚ö†Ô∏è UI not fully loaded, but starting anyway...")
    print(string.rep("=", 60))
end

task.wait(1)  -- ‡∏£‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡∏µ‡∏Å‡∏ô‡∏¥‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ô‡πà‡πÉ‡∏à

------------------------------------------------------------
-- GLOBAL SOFT LOCK (‡∏Å‡∏±‡∏ô‡∏ï‡∏Å map ‡∏ï‡∏≠‡∏ô‡∏Ç‡∏∏‡∏î/‡∏ï‡∏µ)
------------------------------------------------------------
local SoftLockState = { conn = nil }

local function SoftLockPosition(yOffset)
    yOffset = yOffset or 0

    if SoftLockState.conn then return end

    local Players    = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local player     = Players.LocalPlayer

    local char = player.Character
    local hrp  = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local basePos = hrp.Position

    SoftLockState.conn = RunService.Heartbeat:Connect(function()
        if not char or not char.Parent or not hrp or not hrp.Parent then
            if SoftLockState.conn then
                SoftLockState.conn:Disconnect()
                SoftLockState.conn = nil
            end
            return
        end

        hrp.Velocity    = Vector3.zero
        hrp.RotVelocity = Vector3.zero

        local _, ry, rz = hrp.CFrame:ToEulerAnglesYXZ()
        hrp.CFrame = CFrame.new(
            basePos.X,
            basePos.Y + yOffset,
            basePos.Z
        ) * CFrame.fromEulerAnglesYXZ(0, ry, rz)
    end)
end

local function SoftUnlockPosition()
    if SoftLockState.conn then
        SoftLockState.conn:Disconnect()
        SoftLockState.conn = nil
    end
end



----------------------------------------------------------------
-- QUEST 1 ORIGINAL (from 1.lua)
----------------------------------------------------------------
local function RunQuest01()
    -- Full Quest 1 Automation Script (Smooth Movement + UI Force Restore)
    -- Features: Quest Check -> Smooth BodyMove -> Dialogue -> Force Restore ALL UI
    
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Workspace = game:GetService("Workspace")
    
    local player = Players.LocalPlayer
    
    ----------------------------------------------------------------
    -- CONFIGURATION
    ----------------------------------------------------------------
    local QUEST_NAME = "Getting Started!"
    local NPC_NAME = "Sensei Moro"
    local QUEST_OPTION_ARG = "GiveIntroduction1"
    local MOVE_SPEED = 20
    
    ----------------------------------------------------------------
    -- STATE MANAGEMENT
    ----------------------------------------------------------------
    local State = {
        noclipConn = nil,
        moveConn = nil,
        bodyVelocity = nil,
        bodyGyro = nil,
    }
    
    local function cleanupState()
        if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
    end
    
    ----------------------------------------------------------------
    -- NOCLIP
    ----------------------------------------------------------------
    local function enableNoclip()
        if State.noclipConn then return end
        
        local char = player.Character
        if not char then return end
        
        State.noclipConn = RunService.Stepped:Connect(function()
            if not char or not char.Parent then
                if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
                return
            end
            
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end
    
    local function disableNoclip()
        if State.noclipConn then
            State.noclipConn:Disconnect()
            State.noclipConn = nil
        end
    end
    
    ----------------------------------------------------------------
    -- SMOOTH MOVEMENT
    ----------------------------------------------------------------
    local function smoothMoveTo(targetPos, callback)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        -- Cleanup previous movement
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        -- Enable noclip
        enableNoclip()
        
        -- Create BodyVelocity
        local bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Parent = hrp
        State.bodyVelocity = bv
        
        -- Create BodyGyro
        local bg = Instance.new("BodyGyro")
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.P = 10000
        bg.D = 500
        bg.Parent = hrp
        State.bodyGyro = bg
        
        print(string.format("   üöÄ Moving to (%.1f, %.1f, %.1f)...", targetPos.X, targetPos.Y, targetPos.Z))
        
        State.moveConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                if bv then bv:Destroy() end
                if bg then bg:Destroy() end
                State.bodyVelocity = nil
                State.bodyGyro = nil
                return
            end
            
            local currentPos = hrp.Position
            local direction = (targetPos - currentPos)
            local distance = direction.Magnitude
            
            if distance < 5 then  -- Stop at 5 studs (NPC proximity)
                print("   ‚úÖ Reached NPC!")
                
                bv.Velocity = Vector3.zero
                task.wait(0.1)
                
                bv:Destroy()
                bg:Destroy()
                State.bodyVelocity = nil
                State.bodyGyro = nil
                
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                
                if callback then callback() end
                return
            end
            
            local speed = math.min(MOVE_SPEED, distance * 10)
            local velocity = direction.Unit * speed
            
            bv.Velocity = velocity
            bg.CFrame = CFrame.lookAt(currentPos, targetPos)
        end)
        
        return true
    end
    
    ----------------------------------------------------------------
    -- REMOTE FUNCTIONS
    ----------------------------------------------------------------
    local function invokeDialogueStart(npcModel)
        local remote = ReplicatedStorage:WaitForChild("Shared")
            :WaitForChild("Packages"):WaitForChild("Knit")
            :WaitForChild("Services"):WaitForChild("ProximityService")
            :WaitForChild("RF"):WaitForChild("Dialogue")
        if remote then
            remote:InvokeServer(npcModel)
            print("üì° 1. Started Dialogue")
        end
    end
    
    local function invokeRunCommand(commandName)
        local remote = ReplicatedStorage:WaitForChild("Shared")
            :WaitForChild("Packages"):WaitForChild("Knit")
            :WaitForChild("Services"):WaitForChild("DialogueService")
            :WaitForChild("RF"):WaitForChild("RunCommand")
        if remote then
            print("üì° 2. Selecting Option: " .. commandName)
            pcall(function() remote:InvokeServer(commandName) end)
        end
    end
    
    ----------------------------------------------------------------
    -- HELPER: FORCE RESTORE (Fix Missing UI)
    ----------------------------------------------------------------
    local function ForceEndDialogueAndRestore()
        print("üîß 3. Forcing Cleanup & UI Restore...")
    
        -- A. ‡∏õ‡∏¥‡∏î Dialogue & ‡πÅ‡∏Å‡πâ Camera
        local gui = player:FindFirstChild("PlayerGui")
        if gui then
            local dUI = gui:FindFirstChild("DialogueUI")
            if dUI then
                dUI.Enabled = false
                local bb = dUI:FindFirstChild("ResponseBillboard")
                if bb then bb.Visible = false end
            end
        end
    
        local cam = Workspace.CurrentCamera
        if cam then
            cam.CameraType = Enum.CameraType.Custom
            cam.FieldOfView = 70
        end
    
        -- B. ‡∏•‡∏ö Status ‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡πÉ‡∏´‡πâ UI ‡∏´‡∏≤‡∏¢
        local char = player.Character
        if char then
            local status = char:FindFirstChild("Status")
            if status then
                for _, tag in ipairs(status:GetChildren()) do
                    if tag.Name == "DisableBackpack" or tag.Name == "NoMovement" or tag.Name == "Talking" then
                        tag:Destroy()
                        print("   - Removed Status Tag: " .. tag.Name)
                    end
                end
            end
            
            -- ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ Humanoid
            local humanoid = char:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = 16
                humanoid.JumpPower = 50
            end
        end
    
        -- C. ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÄ‡∏õ‡∏¥‡∏î UI ‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤
        if gui then
            local main = gui:FindFirstChild("Main")
            if main then 
                main.Enabled = true 
                print("   - Main UI (Quest) Restored")
            end
            
            local backpack = gui:FindFirstChild("BackpackGui")
            if backpack then 
                backpack.Enabled = true 
                print("   - Backpack Restored")
            end
            
            local compass = gui:FindFirstChild("Compass")
            if compass then compass.Enabled = true end
            
            local mobile = gui:FindFirstChild("MobileButtons")
            if mobile then mobile.Enabled = true end
        end
    
        -- D. ‡∏ö‡∏≠‡∏Å Server ‡∏ß‡πà‡∏≤‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß
        local remote = ReplicatedStorage:WaitForChild("Shared")
            :WaitForChild("Packages"):WaitForChild("Knit")
            :WaitForChild("Services"):WaitForChild("DialogueService")
            :WaitForChild("RE"):WaitForChild("DialogueEvent")
        if remote then
            remote:FireServer("Closed")
        end
        
        print("‚úÖ Restore Complete")
    end
    
    ----------------------------------------------------------------
    -- HELPER: QUEST & MOVEMENT
    ----------------------------------------------------------------
    local function getActiveQuestName()
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil end
        local list = gui:FindFirstChild("Main") and gui.Main:FindFirstChild("Screen") 
                     and gui.Main.Screen:FindFirstChild("Quests") and gui.Main.Screen.Quests:FindFirstChild("List")
        if not list then return nil end
        for _, child in ipairs(list:GetChildren()) do
            if string.match(child.Name, "^Introduction%d+Title$") then
                local frame = child:FindFirstChild("Frame")
                if frame then
                    local label = frame:FindFirstChild("TextLabel")
                    if label and label.Text ~= "" then return label.Text end
                end
            end
        end
        return nil
    end
    
    local function getNpcModel(name)
        local prox = Workspace:FindFirstChild("Proximity")
        return prox and prox:FindFirstChild(name)
    end
    
    ----------------------------------------------------------------
    -- MAIN EXECUTION
    ----------------------------------------------------------------
    local function Run_Quest1()
        print(string.rep("=", 50))
        print("üöÄ QUEST 1: " .. QUEST_NAME)
        print(string.rep("=", 50))
        
        local activeQuest = getActiveQuestName()
        if activeQuest ~= QUEST_NAME then
            warn("‚ö†Ô∏è Quest mismatch. Active: " .. tostring(activeQuest))
        else
            print("‚úÖ Quest Active: " .. activeQuest)
        end
    
        local npcModel = getNpcModel(NPC_NAME)
        if not npcModel then 
            cleanupState()
            disableNoclip()
            return warn("‚ùå NPC Not Found") 
        end
        
        local targetPart = npcModel.PrimaryPart or npcModel:FindFirstChildWhichIsA("BasePart")
        if not targetPart then
            cleanupState()
            disableNoclip()
            return warn("‚ùå NPC has no valid part")
        end
        
        local targetPos = targetPart.Position
        
        print(string.format("\nüö∂ Moving to NPC '%s' at (%.1f, %.1f, %.1f)...", 
            NPC_NAME, targetPos.X, targetPos.Y, targetPos.Z))
        
        -- Start smooth movement
        local moveComplete = false
        smoothMoveTo(targetPos, function()
            moveComplete = true
        end)
        
        -- Wait for movement to complete
        local timeout = 15
        local startTime = tick()
        while not moveComplete and tick() - startTime < timeout do
            task.wait(0.1)
        end
        
        -- Cleanup movement
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        if not moveComplete then
            cleanupState()
            disableNoclip()
            return warn("‚ùå Failed to reach NPC (timeout)")
        end
        
        print("\nüìû Starting Dialogue...")
        task.wait(0.5)
        invokeDialogueStart(npcModel)
        
        print("‚è≥ Waiting for dialogue to open...")
        task.wait(1.5)
        
        print("‚úÖ Selecting quest option...")
        invokeRunCommand(QUEST_OPTION_ARG)
        
        print("‚è≥ Processing...")
        task.wait(0.5)
        
        ForceEndDialogueAndRestore()
        
        -- Final cleanup
        cleanupState()
        disableNoclip()
        
        print("\n" .. string.rep("=", 50))
        print("üéâ Quest 1 Sequence Finished!")
        print(string.rep("=", 50))
    end
    
    Run_Quest1()
end

----------------------------------------------------------------
-- QUEST 2 ORIGINAL (from 2.lua)
----------------------------------------------------------------
local function RunQuest02()
    -- QUEST 2: "First Pickaxe!" (SMART SYSTEM: Priority-based + Flexible + smoothMoveTo)
    -- Priority Order: 1) Open Equipments ‚Üí 2) Equip Pickaxe ‚Üí 3) Mine Pebbles
    
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local Workspace = game:GetService("Workspace")
    
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    ----------------------------------------------------------------
    -- CONFIG
    ----------------------------------------------------------------
    local Quest2Active = true
    
    local QUEST_CONFIG = {
        QUEST_NAME = "First Pickaxe!",
        PICKAXE_NAME = "Stone Pickaxe",
        MINING_START_POSITION = Vector3.new(43.203, -3.717, -106.628),
        MOVE_SPEED = 50,
        STOP_DISTANCE = 6,
        
        -- üî• NEW: Priority Order
        PRIORITY_ORDER = {
            "Open",    -- 1. ‡πÄ‡∏õ‡∏¥‡∏î Equipments
            "Equip",   -- 2. ‡πÉ‡∏™‡πà Pickaxe
            "Mine",    -- 3. ‡∏Ç‡∏∏‡∏î Pebbles
        }
    }
    
    ----------------------------------------------------------------
    -- SERVICES & REMOTES
    ----------------------------------------------------------------
    local SERVICES = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")
    local CHAR_RF = SERVICES:WaitForChild("CharacterService"):WaitForChild("RF"):WaitForChild("EquipItem")
    local TOOL_RF_BACKUP = SERVICES:WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("ToolActivated")
    
    local MINING_FOLDER_PATH = nil
    do
        local ok, rocks = pcall(function()
            return Workspace:FindFirstChild("Rocks")
        end)
        if ok and rocks then
            MINING_FOLDER_PATH = rocks:FindFirstChild("Island1CaveStart")
        end
        if not MINING_FOLDER_PATH then
            warn("[Quest2] Rocks/Island1CaveStart not found ‚Äì skipping Quest 2 on this map.")
            return  -- ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å Quest02() ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ ‡πÉ‡∏´‡πâ Linear runner ‡πÑ‡∏õ‡∏ï‡πà‡∏≠ Quest 3..18
        end
    end
    
    ----------------------------------------------------------------
    -- HOOK CONTROLLERS
    ----------------------------------------------------------------
    local UIController = nil
    local ToolController = nil
    local ToolActivatedFunc = nil
    
    pcall(function()
        for _, v in pairs(getgc(true)) do
            if type(v) == "table" then
                if rawget(v, "Open") and rawget(v, "Modules") then
                    UIController = v
                end
                if rawget(v, "Name") == "ToolController" and rawget(v, "ToolActivated") then
                    ToolController = v
                    ToolActivatedFunc = v.ToolActivated
                end
            end
        end
    end)
    
    if UIController then print("‚úÖ UIController Hooked!") else warn("‚ö†Ô∏è UIController not found") end
    if ToolController then print("‚úÖ ToolController Hooked!") else warn("‚ö†Ô∏è ToolController not found (using backup)") end
    
    ----------------------------------------------------------------
    -- STATE MANAGEMENT
    ----------------------------------------------------------------
    local State = {
        currentTarget = nil,
        targetDestroyed = false,
        moveConn = nil,
        hpWatchConn = nil,
        noclipConn = nil,
        bodyVelocity = nil,
        bodyGyro = nil,
        currentObjectiveFrame = nil,
    }
    
    local function cleanupState()
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.hpWatchConn then State.hpWatchConn:Disconnect() State.hpWatchConn = nil end
        if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        State.currentTarget = nil
        State.targetDestroyed = false
        if ToolController then ToolController.holdingM1 = false end
    end
    
    ----------------------------------------------------------------
    -- QUEST SYSTEM
    ----------------------------------------------------------------
    local function getQuestObjectives(questName)
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil, nil end
        
        local list = gui:FindFirstChild("Main") and gui.Main:FindFirstChild("Screen") 
                     and gui.Main.Screen:FindFirstChild("Quests") and gui.Main.Screen.Quests:FindFirstChild("List")
        if not list then return nil, nil end
        
        local questID = nil
        for _, child in ipairs(list:GetChildren()) do
            local id = string.match(child.Name, "^Introduction(%d+)Title$")
            if id and child:FindFirstChild("Frame") and child.Frame:FindFirstChild("TextLabel") then
                if child.Frame.TextLabel.Text == questName then
                    questID = id
                    break
                end
            end
        end
        
        if not questID then return nil, nil end
        
        local objList = list:FindFirstChild("Introduction" .. questID .. "List")
        return questID, objList
    end
    
    local function isObjectiveComplete(item)
        if not item then return false end
        local check = item:FindFirstChild("Main") and item.Main:FindFirstChild("Frame") and item.Main.Frame:FindFirstChild("Check")
        return check and check.Visible
    end
    
    local function getObjectiveText(item)
        local lbl = item:FindFirstChild("Main") and item.Main:FindFirstChild("TextLabel")
        return lbl and lbl.Text or ""
    end
    
    local function isQuest2StillActive()
        if not Quest2Active then return false end
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        if not questID or not objList then
            print("üõë Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' disappeared!")
            Quest2Active = false
            return false
        end
        
        return true
    end
    
    local function isCurrentObjectiveComplete()
        if State.currentObjectiveFrame then
            return isObjectiveComplete(State.currentObjectiveFrame)
        end
        return false
    end
    
    -- üî• NEW: Classify objective type
    local function getObjectiveType(text)
        if string.find(text, "Open Equipments") or string.find(text, "Open") then
            return "Open"
        elseif string.find(text, "Equip") and string.find(text, "Pickaxe") then
            return "Equip"
        elseif string.find(text, "Get Ore") or string.find(text, "Mine") or string.find(text, "Pebble") then
            return "Mine"
        else
            return "Unknown"
        end
    end
    
    -- üî• NEW: Check if objective can be done now
    local function canDoObjective(objType)
        -- Quest 2 ‡πÑ‡∏°‡πà‡∏°‡∏µ dependency (‡∏ó‡∏∏‡∏Å objective ‡∏ó‡∏≥‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢)
        return true
    end
    
    ----------------------------------------------------------------
    -- NOCLIP & MOVEMENT
    ----------------------------------------------------------------
    local function enableNoclip()
        if State.noclipConn then return end
        
        local char = player.Character
        if not char then return end
        
        State.noclipConn = RunService.Stepped:Connect(function()
            if not char or not char.Parent then
                if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
                return
            end
            
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end
    
    local function disableNoclip()
        if State.noclipConn then
            State.noclipConn:Disconnect()
            State.noclipConn = nil
        end
    end
    
    local function smoothMoveTo(targetPos, stopDistance, callback)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        enableNoclip()
        
        local bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Parent = hrp
        State.bodyVelocity = bv
        
        local bg = Instance.new("BodyGyro")
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.P = 10000
        bg.D = 500
        bg.Parent = hrp
        State.bodyGyro = bg
        
        State.moveConn = RunService.Heartbeat:Connect(function()
            if State.targetDestroyed or not Quest2Active then
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                if bv then bv.Velocity = Vector3.zero bv:Destroy() end
                if bg then bg:Destroy() end
                State.bodyVelocity = nil
                State.bodyGyro = nil
                return
            end
            
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                if bv then bv:Destroy() end
                if bg then bg:Destroy() end
                State.bodyVelocity = nil
                State.bodyGyro = nil
                return
            end
            
            local currentPos = hrp.Position
            local direction = (targetPos - currentPos)
            local distance = direction.Magnitude
            
            if distance < stopDistance then
                bv.Velocity = Vector3.zero
                if callback then callback() end
                return
            end
            
            local speed = math.min(QUEST_CONFIG.MOVE_SPEED, distance * 10)
            local velocity = direction.Unit * speed
            
            bv.Velocity = velocity
            bg.CFrame = CFrame.lookAt(currentPos, targetPos)
        end)
        
        return true
    end
    
    ----------------------------------------------------------------
    -- HELPER FUNCTIONS
    ----------------------------------------------------------------
    local HOTKEY_MAP = {
        ["1"] = Enum.KeyCode.One, ["2"] = Enum.KeyCode.Two, ["3"] = Enum.KeyCode.Three,
        ["4"] = Enum.KeyCode.Four, ["5"] = Enum.KeyCode.Five, ["6"] = Enum.KeyCode.Six,
        ["7"] = Enum.KeyCode.Seven, ["8"] = Enum.KeyCode.Eight, ["9"] = Enum.KeyCode.Nine, ["0"] = Enum.KeyCode.Zero
    }
    
    local function pressKey(keyCode)
        if not keyCode then return end
        VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
        task.wait(0.05)
        VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
    end
    
    local function findPickaxeSlotKey()
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil end
        local hotbar = gui:FindFirstChild("BackpackGui") and gui.BackpackGui:FindFirstChild("Backpack") and gui.BackpackGui.Backpack:FindFirstChild("Hotbar")
        if hotbar then
            for _, slotFrame in ipairs(hotbar:GetChildren()) do
                local frame = slotFrame:FindFirstChild("Frame")
                local label = frame and frame:FindFirstChild("ToolName")
                if label and label:IsA("TextLabel") and string.find(label.Text, "Pickaxe") then
                    return HOTKEY_MAP[slotFrame.Name]
                end
            end
        end
        return nil
    end
    
    local function checkMiningError()
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return false end
        local notif = gui:FindFirstChild("Notifications")
        if notif and notif:FindFirstChild("Screen") and notif.Screen:FindFirstChild("NotificationsFrame") then
            for _, child in ipairs(notif.Screen.NotificationsFrame:GetChildren()) do
                local lbl = child:FindFirstChild("TextLabel", true)
                if lbl and string.find(lbl.Text, "Someone else is already mining") then return true end
            end
        end
        return false
    end
    
    local function getPebblePosition(pebbleModel)
        if not pebbleModel or not pebbleModel.Parent then return nil end
        if pebbleModel.PrimaryPart then return pebbleModel.PrimaryPart.Position end
        local part = pebbleModel:FindFirstChildWhichIsA("BasePart")
        return part and part.Position or nil
    end
    
    local function faceTarget(targetPos)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp and targetPos then
            hrp.CFrame = CFrame.lookAt(hrp.Position, Vector3.new(targetPos.X, hrp.Position.Y, targetPos.Z))
        end
    end
    
    ----------------------------------------------------------------
    -- HP CHECKER
    ----------------------------------------------------------------
    local function getPebbleHP(pebble)
        if not pebble or not pebble.Parent then return 0 end
        
        local success, result = pcall(function()
            return pebble:GetAttribute("Health") or 0
        end)
        
        return success and result or 0
    end
    
    local function isTargetValid(pebble)
        if not pebble or not pebble.Parent then return false end
        if not pebble:FindFirstChildWhichIsA("BasePart") then return false end
        
        local hp = getPebbleHP(pebble)
        return hp > 0
    end
    
    ----------------------------------------------------------------
    -- VIRTUAL CLICK
    ----------------------------------------------------------------
    local function VirtualClick(guiObject)
        if not guiObject then 
            warn("‚ùå GUI Object not found!")
            return false 
        end
        
        local clickSuccess = pcall(function()
            local conns = getconnections(guiObject.MouseButton1Click)
            for _, conn in pairs(conns) do
                conn:Fire()
            end
        end)
        
        local activatedSuccess = pcall(function()
            local conns = getconnections(guiObject.Activated)
            for _, conn in pairs(conns) do
                conn:Fire()
            end
        end)
        
        if clickSuccess or activatedSuccess then
            print("   ‚úÖ Click executed")
            return true
        end
        return false
    end
    
    ----------------------------------------------------------------
    -- TARGET FINDER
    ----------------------------------------------------------------
    local function findNearestPebble()
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return nil end
        
        local targetPebble, minDist = nil, math.huge
        
        for _, child in ipairs(MINING_FOLDER_PATH:GetChildren()) do
            if child:IsA("SpawnLocation") or child.Name == "SpawnLocation" then
                local pebble = child:FindFirstChild("Pebble")
                if isTargetValid(pebble) then
                    local pos = getPebblePosition(pebble)
                    if pos then
                        local dist = (pos - hrp.Position).Magnitude
                        if dist < minDist then
                            minDist = dist
                            targetPebble = pebble
                        end
                    end
                end
            end
        end
        
        return targetPebble, minDist
    end
    
    ----------------------------------------------------------------
    -- MOVE TO STARTING POSITION
    ----------------------------------------------------------------
    local function moveToStartPosition()
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        local currentDist = (QUEST_CONFIG.MINING_START_POSITION - hrp.Position).Magnitude
        
        if currentDist > 50 then
            print(string.format("üìç Moving to starting position (%.1f studs away)...", currentDist))
            print(string.format("   üöÄ Target: (%.1f, %.1f, %.1f)", 
                QUEST_CONFIG.MINING_START_POSITION.X, QUEST_CONFIG.MINING_START_POSITION.Y, QUEST_CONFIG.MINING_START_POSITION.Z))
            
            local moveComplete = false
            smoothMoveTo(QUEST_CONFIG.MINING_START_POSITION, 5, function()
                moveComplete = true
            end)
            
            local timeout = 15
            local startTime = tick()
            while not moveComplete and tick() - startTime < timeout do
                if not hrp or not hrp.Parent then break end
                local dist = (QUEST_CONFIG.MINING_START_POSITION - hrp.Position).Magnitude
                if dist < 8 then
                    moveComplete = true
                    break
                end
                task.wait(0.1)
            end
            
            if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
            if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
            if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
            
            -- ‚úÖ ‡πÑ‡∏°‡πà SoftUnlock ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà ‡πÉ‡∏´‡πâ‡∏£‡∏≠‡∏Ç‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô
            print("   ‚úÖ Reached starting position!")
            task.wait(0.3)
        else
            print("   ‚úÖ Already near starting position!")
        end
        
        return true
    end
    
    ----------------------------------------------------------------
    -- WATCH HP
    ----------------------------------------------------------------
    local function watchPebbleHP(pebble)
        if State.hpWatchConn then State.hpWatchConn:Disconnect() end
        if not pebble then return end
        
        State.hpWatchConn = pebble:GetAttributeChangedSignal("Health"):Connect(function()
            local hp = pebble:GetAttribute("Health") or 0
            print(string.format("   ‚ö° [HP Changed!] New HP: %d", hp))
            
            if hp <= 0 then
                print("   üí• HP = 0 detected! Switching target...")
                State.targetDestroyed = true
                if ToolController then ToolController.holdingM1 = false end
            end
        end)
    end
    
    ----------------------------------------------------------------
    -- ACTIONS
    ----------------------------------------------------------------
    local function doOpenEquipments()
        print("üì¶ Objective: Opening Equipments...")
        
        if not UIController then
            warn("   ‚ùå UIController not available")
            return false
        end
        
        if UIController.Modules["Inventory"] then
            pcall(function() UIController:Open("Inventory") end)
        end
        
        if UIController.Modules["Menu"] then
            pcall(function() UIController:Open("Menu") end)
            
            local menuModule = UIController.Modules["Menu"]
            if menuModule.OpenTab then
                pcall(function() menuModule:OpenTab("Inventory") end)
                pcall(function() menuModule:OpenTab("Equipments") end)
            elseif menuModule.SwitchTab then
                pcall(function() menuModule:SwitchTab("Inventory") end)
            end
        end
        
        print("   ‚è≥ Waiting for Menu...")
        task.wait(1)
        
        local toolsButton = nil
        pcall(function()
            toolsButton = playerGui.Menu.Frame.Frame.BottomBar.Buttons.Buttons.Tools
        end)
        
        if toolsButton then
            print("   üñ±Ô∏è Clicking Tools...")
            VirtualClick(toolsButton)
            task.wait(0.5)
            
            print("   üö™ Closing Menu...")
            if UIController and UIController.Close then
                pcall(function() UIController:Close("Menu") end)
            end
            task.wait(0.3)
            return true
        else
            warn("   ‚ùå Tools button not found")
            return false
        end
    end
    
    local function doEquipPickaxe()
        print("‚õèÔ∏è Objective: Equipping Stone Pickaxe...")
        
        local key = findPickaxeSlotKey()
        if key then
            print("   üî¢ Using hotkey...")
            pressKey(key)
            task.wait(0.5)
        else
            print("   üì° Using remote...")
            pcall(function() 
                CHAR_RF:InvokeServer({Runes = {}, Name = QUEST_CONFIG.PICKAXE_NAME}) 
            end)
            task.wait(0.5)
        end
        
        local char = player.Character
        local tool = char and char:FindFirstChildWhichIsA("Tool")
        if tool and string.find(tool.Name, "Pickaxe") then
            print("   ‚úÖ Pickaxe equipped!")
            return true
        else
            warn("   ‚ö†Ô∏è Pickaxe not in hand yet")
            return false
        end
    end
    
    local function doMinePebbles()
        print("ü™® Objective: Mining Pebbles...")
        print("\n" .. string.rep("-", 30))
        print("üö∂ Step 1: Moving to starting position...")
        print(string.rep("-", 30))
        
        moveToStartPosition()
        
        print("\n" .. string.rep("-", 30))
        print("‚õèÔ∏è  Step 2: Starting mining loop...")
        print(string.rep("-", 30))
        
        while isQuest2StillActive() and not isCurrentObjectiveComplete() do
            local char = player.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            
            if not hrp then
                task.wait(1)
                continue
            end
            
            cleanupState()
            
            local targetPebble, dist = findNearestPebble()
            
            if not targetPebble then
                warn("   ‚ùå No Pebbles found, waiting...")
                task.wait(2)
                continue
            end
            
            State.currentTarget = targetPebble
            State.targetDestroyed = false
            
            local targetPos = getPebblePosition(targetPebble)
            local currentHP = getPebbleHP(targetPebble)
            
            print(string.format("   üéØ Target: %s (dist: %d, HP: %d)", 
                targetPebble.Parent.Name, math.floor(dist), currentHP))
            
            watchPebbleHP(targetPebble)
            
            -- ‚úÖ FIX: ‡∏ñ‡πâ‡∏≤ pebble ‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ (< 3 studs) ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏õ
            if dist < 3 then
                print("   ‚ö†Ô∏è Pebble too close to starting position, skipping...")
                State.targetDestroyed = true
                task.wait(1)
                continue
            end
            
            -- ‚úÖ FIX: ‡πÄ‡∏û‡∏¥‡πà‡∏° STOP_DISTANCE ‡πÄ‡∏õ‡πá‡∏ô 8 studs
            local moveComplete = false
            smoothMoveTo(targetPos, 8, function()
                moveComplete = true
            end)
            
            -- ‡∏£‡∏≠‡πÉ‡∏´‡πâ movement ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô
            local timeout = 10
            local startTime = tick()
            while not moveComplete and tick() - startTime < timeout do
                if not hrp or not hrp.Parent then break end
                local currentDist = (targetPos - hrp.Position).Magnitude
                if currentDist <= 8 then
                    moveComplete = true
                    break
                end
                task.wait(0.1)
            end
            
            -- ‚úÖ FIX: ‡∏´‡∏¢‡∏∏‡∏î movement ‡∏Å‡πà‡∏≠‡∏ô ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢ SoftLock
            if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
            if State.bodyVelocity then 
                State.bodyVelocity.Velocity = Vector3.zero
                State.bodyVelocity:Destroy() 
                State.bodyVelocity = nil 
            end
            if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
            
            task.wait(0.3)
            
            -- ‚úÖ FIX: ‡πÄ‡∏ä‡πá‡∏Ñ‡∏£‡∏∞‡∏¢‡∏∞‡∏Å‡πà‡∏≠‡∏ô SoftLock
            local finalDist = (targetPos - hrp.Position).Magnitude
            print(string.format("   üìè Final distance to pebble: %.1f studs", finalDist))
            
            if finalDist > 12 then
                print("   ‚ö†Ô∏è Too far from pebble, retrying...")
                State.targetDestroyed = true
                continue
            end
            
            -- ‚úÖ SoftLock ‡∏ó‡∏µ‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà starting position)
            SoftLockPosition(-2)
            
            -- Mining loop
            while not State.targetDestroyed and isQuest2StillActive() and not isCurrentObjectiveComplete() do
                if not targetPebble or not targetPebble.Parent then
                    print("   üí• Target removed!")
                    State.targetDestroyed = true
                    SoftUnlockPosition()
                    break
                end
                
                if checkMiningError() then
                    print("   ‚ö†Ô∏è Someone else mining!")
                    State.targetDestroyed = true
                    if ToolController then ToolController.holdingM1 = false end
                    SoftUnlockPosition()
                    break
                end
                
                local currentPos = getPebblePosition(targetPebble)
                if currentPos then faceTarget(currentPos) end
                
                local toolInHand = char:FindFirstChildWhichIsA("Tool")
                local isPickaxeHeld = toolInHand and string.find(toolInHand.Name, "Pickaxe")
                
                if not isPickaxeHeld then
                    if ToolController then ToolController.holdingM1 = false end
                    local key = findPickaxeSlotKey()
                    if key then
                        pressKey(key)
                        task.wait(0.3)
                    else
                        pcall(function() CHAR_RF:InvokeServer({Runes = {}, Name = QUEST_CONFIG.PICKAXE_NAME}) end)
                        task.wait(0.5)
                    end
                else
                    local pos = getPebblePosition(targetPebble)
                    if pos and hrp and (pos - hrp.Position).Magnitude <= 12 then
                        if ToolController and ToolActivatedFunc then
                            ToolController.holdingM1 = true
                            pcall(function() ToolActivatedFunc(ToolController, toolInHand) end)
                        else
                            pcall(function() TOOL_RF_BACKUP:InvokeServer(toolInHand.Name, true) end)
                        end
                    else
                        if ToolController then ToolController.holdingM1 = false end
                    end
                end
                
                task.wait(0.15)
            end
            
            SoftUnlockPosition()
            
            if isCurrentObjectiveComplete() then
                print("‚úÖ Objective (Mine Pebbles) Complete!")
                break
            end
            
            print("   üîÑ Finding next target...")
            task.wait(0.1)
        end
        
        print("\nüõë Mining ended")
        SoftUnlockPosition()
        cleanupState()
    end
    
    ----------------------------------------------------------------
    -- üî• SMART QUEST RUNNER (Priority-based + Flexible)
    ----------------------------------------------------------------
    local function RunQuest2_Smart()
        print(string.rep("=", 50))
        print("üöÄ QUEST 2: " .. QUEST_CONFIG.QUEST_NAME)
        print("üéØ SMART SYSTEM: Priority-based + Flexible")
        print("üìã Priority Order: Open ‚Üí Equip ‚Üí Mine")
        print("üõ°Ô∏è  Noclip + smoothMoveTo enabled")
        print(string.rep("=", 50))
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        
        if not questID then
            warn("‚ùå Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' not active")
            Quest2Active = false
            return
        end
        
        print("‚úÖ Quest found (ID: " .. questID .. ")")
        
        -- Collect all objectives
        local objectives = {}
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                local text = getObjectiveText(item)
                local objType = getObjectiveType(text)
                
                table.insert(objectives, {
                    order = tonumber(item.Name),
                    frame = item,
                    text = text,
                    type = objType
                })
            end
        end
        
        -- üî• Sort by priority
        table.sort(objectives, function(a, b)
            local function getPriority(type)
                for i, priorityType in ipairs(QUEST_CONFIG.PRIORITY_ORDER) do
                    if string.find(type, priorityType) then
                        return i
                    end
                end
                return 999
            end
            return getPriority(a.type) < getPriority(b.type)
        end)
        
        print("\n" .. string.rep("=", 50))
        print("‚öôÔ∏è  Quest Objectives (Priority Order):")
        for i, obj in ipairs(objectives) do
            local complete = isObjectiveComplete(obj.frame)
            print(string.format("   %d. [%s] %s [%s]", i, obj.type, obj.text, complete and "‚úÖ" or "‚è≥"))
        end
        print(string.rep("=", 50))
        
        -- üî• Main loop: Process objectives by priority
        local maxAttempts = 5
        local attempt = 0
        
        while isQuest2StillActive() and attempt < maxAttempts do
            attempt = attempt + 1
            print(string.format("\nüîÑ Quest Cycle #%d", attempt))
            
            local allComplete = true
            local didSomething = false
            
            for _, obj in ipairs(objectives) do
                if not isQuest2StillActive() then
                    print("üõë Quest disappeared!")
                    break
                end
                
                local complete = isObjectiveComplete(obj.frame)
                
                if not complete then
                    allComplete = false
                    
                    if not canDoObjective(obj.type) then
                        print(string.format("   ‚è≠Ô∏è  Skipping [%s] - Cannot do right now", obj.type))
                        continue
                    end
                    
                    State.currentObjectiveFrame = obj.frame
                    
                    print(string.format("\nüìã Processing [%s]: %s", obj.type, obj.text))
                    
                    -- Execute objective
                    local success = false
                    
                    if obj.type == "Open" then
                        success = doOpenEquipments()
                        didSomething = true
                        task.wait(1)
                        
                    elseif obj.type == "Equip" then
                        success = doEquipPickaxe()
                        didSomething = true
                        task.wait(1)
                        
                    elseif obj.type == "Mine" then
                        doMinePebbles()
                        didSomething = true
                        -- Mining ‡∏à‡∏∞‡∏ó‡∏≥‡∏à‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à
                        
                    else
                        warn("   ‚ö†Ô∏è Unknown objective type: " .. obj.type)
                    end
                    
                    -- Check if complete
                    task.wait(1)
                    if isObjectiveComplete(obj.frame) then
                        print(string.format("‚úÖ [%s] Complete!", obj.type))
                    else
                        print(string.format("‚è≥ [%s] Still in progress", obj.type))
                    end
                end
            end
            
            if allComplete then
                print("\nüéâ All objectives complete!")
                break
            end
            
            if not didSomething then
                warn("\n‚ö†Ô∏è No objectives could be completed this cycle!")
                print("   Waiting 2s before retry...")
                task.wait(2)
            end
        end
        
        -- Final check
        task.wait(1)
        
        local allComplete = true
        for _, obj in ipairs(objectives) do
            if not isObjectiveComplete(obj.frame) then
                allComplete = false
                warn(string.format("   ‚ö†Ô∏è [%s] incomplete: %s", obj.type, obj.text))
            end
        end
        
        if allComplete then
            print("\n" .. string.rep("=", 50))
            print("‚úÖ Quest 2 Complete!")
            print(string.rep("=", 50))
        else
            warn("\n" .. string.rep("=", 50))
            warn("‚ö†Ô∏è Quest 2 incomplete after " .. attempt .. " cycles")
            warn(string.rep("=", 50))
        end
        
        Quest2Active = false
        disableNoclip()
        cleanupState()
    end
    
    ----------------------------------------------------------------
    -- START
    ----------------------------------------------------------------
    RunQuest2_Smart()
end

----------------------------------------------------------------
-- QUEST 3 ORIGINAL (from 3.lua)
----------------------------------------------------------------
local function RunQuest03()
    -- QUEST 3 ONLY: "Learning to Forge!" (FIXED: smoothMoveTo + Lock Position)
    
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Workspace = game:GetService("Workspace")
    
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    ----------------------------------------------------------------
    -- CONFIG
    ----------------------------------------------------------------
    local Quest3Active = true
    
    local FORGE_CONFIG = {
        REQUIRED_ORE_COUNT = 3,
        ITEM_TYPE = "Weapon",
        FORGE_DELAY = 2,
        FORGE_POSITION = Vector3.new(-192.3, 29.5, 168.1),  -- üÜï Fixed position
        MOVE_SPEED = 50,
    }
    
    ----------------------------------------------------------------
    -- SERVICES & REMOTES
    ----------------------------------------------------------------
    local SERVICES = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")
    local PROXIMITY_RF = SERVICES:WaitForChild("ProximityService"):WaitForChild("RF"):WaitForChild("Forge")
    
    local FORGE_OBJECT = Workspace:WaitForChild("Proximity"):WaitForChild("Forge")
    
    ----------------------------------------------------------------
    -- KNIT SETUP
    ----------------------------------------------------------------
    local KnitPackage = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit")
    local Knit = require(KnitPackage)
    
    if not Knit.OnStart then 
        pcall(function() Knit.Start():await() end)
    end
    
    local ForgeController = nil
    local ForgeService = nil
    local PlayerController = nil
    local UIController = nil
    
    pcall(function()
        ForgeController = Knit.GetController("ForgeController")
        ForgeService = Knit.GetService("ForgeService")
        PlayerController = Knit.GetController("PlayerController")
    end)
    
    -- Hook UIController from getgc
    pcall(function()
        for _, v in pairs(getgc(true)) do
            if type(v) == "table" then
                if rawget(v, "Open") and rawget(v, "Close") and rawget(v, "Modules") then
                    UIController = v
                    break
                end
            end
        end
    end)
    
    if ForgeService then print("‚úÖ ForgeService Ready!") else warn("‚ö†Ô∏è ForgeService not found") end
    if PlayerController then print("‚úÖ PlayerController Ready!") else warn("‚ö†Ô∏è PlayerController not found") end
    if UIController then print("‚úÖ UIController Ready!") else warn("‚ö†Ô∏è UIController not found") end
    
    ----------------------------------------------------------------
    -- STATE
    ----------------------------------------------------------------
    local State = {
        moveConn = nil,
        noclipConn = nil,
        bodyVelocity = nil,
        bodyGyro = nil,
    }
    
    local function cleanupState()
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
    end
    
    ----------------------------------------------------------------
    -- NOCLIP & MOVEMENT
    ----------------------------------------------------------------
    local function enableNoclip()
        if State.noclipConn then return end
        
        local char = player.Character
        if not char then return end
        
        State.noclipConn = RunService.Stepped:Connect(function()
            if not char or not char.Parent then
                if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
                return
            end
            
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end
    
    local function disableNoclip()
        if State.noclipConn then
            State.noclipConn:Disconnect()
            State.noclipConn = nil
        end
    end
    
    -- üÜï smoothMoveTo with BodyVelocity + BodyGyro
    local function smoothMoveTo(targetPos, callback)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        -- Cleanup previous movement
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        -- Enable noclip
        enableNoclip()
        
        -- Create BodyVelocity
        local bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Parent = hrp
        State.bodyVelocity = bv
        
        -- Create BodyGyro
        local bg = Instance.new("BodyGyro")
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.P = 10000
        bg.D = 500
        bg.Parent = hrp
        State.bodyGyro = bg
        
        print(string.format("   üöÄ Moving to (%.1f, %.1f, %.1f)...", targetPos.X, targetPos.Y, targetPos.Z))
        
        State.moveConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                if bv then bv:Destroy() end
                if bg then bg:Destroy() end
                State.bodyVelocity = nil
                State.bodyGyro = nil
                return
            end
            
            local currentPos = hrp.Position
            local direction = (targetPos - currentPos)
            local distance = direction.Magnitude
            
            if distance < 2 then
                print("   ‚úÖ Reached target!")
                
                bv.Velocity = Vector3.zero
                task.wait(0.1)
                
                bv:Destroy()
                bg:Destroy()
                State.bodyVelocity = nil
                State.bodyGyro = nil
                
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                
                if callback then callback() end
                return
            end
            
            local speed = math.min(FORGE_CONFIG.MOVE_SPEED, distance * 10)
            local velocity = direction.Unit * speed
            
            bv.Velocity = velocity
            bg.CFrame = CFrame.lookAt(currentPos, targetPos)
        end)
        
        return true
    end
    
    ----------------------------------------------------------------
    -- UI MANAGEMENT
    ----------------------------------------------------------------
    local function closeForgeUI()
        print("\n   üö™ Closing Forge UI...")
        
        local closed = false
        
        -- Method 1: UIController.Close
        if UIController and UIController.Close then
            pcall(function()
                if UIController.Modules and UIController.Modules["Forge"] then
                    UIController:Close("Forge")
                    print("      ‚úÖ Closed via UIController")
                    closed = true
                end
            end)
        end
        
        -- Method 2: ForgeController
        if not closed and ForgeController then
            pcall(function()
                if ForgeController.Close then
                    ForgeController:Close()
                    print("      ‚úÖ Closed via ForgeController")
                    closed = true
                elseif ForgeController.CloseForge then
                    ForgeController:CloseForge()
                    print("      ‚úÖ Closed via ForgeController.CloseForge")
                    closed = true
                end
            end)
        end
        
        -- Method 3: PlayerGui (direct UI close)
        if not closed then
            pcall(function()
                local forgeGui = playerGui:FindFirstChild("Forge") or playerGui:FindFirstChild("ForgeUI")
                if forgeGui then
                    forgeGui.Enabled = false
                    print("      ‚úÖ Closed via PlayerGui")
                    closed = true
                end
            end)
        end
        
        if not closed then
            warn("      ‚ö†Ô∏è Could not close Forge UI (may already be closed)")
        end
        
        task.wait(0.5)
    end
    
    ----------------------------------------------------------------
    -- QUEST SYSTEM
    ----------------------------------------------------------------
    local function getQuestObjectives(questName)
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil, nil end
        
        local list = gui:FindFirstChild("Main") and gui.Main:FindFirstChild("Screen") 
                     and gui.Main.Screen:FindFirstChild("Quests") and gui.Main.Screen.Quests:FindFirstChild("List")
        if not list then return nil, nil end
        
        local questID = nil
        for _, child in ipairs(list:GetChildren()) do
            local id = string.match(child.Name, "^Introduction(%d+)Title$")
            if id and child:FindFirstChild("Frame") and child.Frame:FindFirstChild("TextLabel") then
                if child.Frame.TextLabel.Text == questName then
                    questID = id
                    break
                end
            end
        end
        
        if not questID then return nil, nil end
        
        local objList = list:FindFirstChild("Introduction" .. questID .. "List")
        return questID, objList
    end
    
    local function isQuestComplete(questName)
        local questID, objList = getQuestObjectives(questName)
        
        if not questID or not objList then
            return true
        end
        
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                local check = item:FindFirstChild("Main") and item.Main:FindFirstChild("Frame") and item.Main.Frame:FindFirstChild("Check")
                if check and not check.Visible then
                    return false
                end
            end
        end
        
        return true
    end
    
    local function isQuest3StillActive()
        if not Quest3Active then return false end
        
        if isQuestComplete("Learning to Forge!") then
            print("üõë Quest 'Learning to Forge!' completed!")
            Quest3Active = false
            return false
        end
        
        local questID, objList = getQuestObjectives("Learning to Forge!")
        if not questID or not objList then
            print("üõë Quest 'Learning to Forge!' not found!")
            Quest3Active = false
            return false
        end
        
        return true
    end
    
    ----------------------------------------------------------------
    -- INVENTORY SYSTEM
    ----------------------------------------------------------------
    local function getPlayerInventory()
        local inventory = {}
        
        if not PlayerController then
            warn("   ‚ö†Ô∏è PlayerController not available!")
            return inventory
        end
        
        if not PlayerController.Replica then
            print("   ‚è≥ Waiting for Replica...")
            task.wait(2)
        end
        
        if not PlayerController.Replica then
            warn("   ‚ùå Replica still not available!")
            return inventory
        end
        
        local replica = PlayerController.Replica
        
        if replica and replica.Data and replica.Data.Inventory then
            print("   ‚úÖ Reading from Replica.Data.Inventory")
            
            for itemName, amount in pairs(replica.Data.Inventory) do
                if type(amount) == "number" and amount > 0 then
                    inventory[itemName] = amount
                end
            end
        else
            warn("   ‚ùå Replica.Data.Inventory not found!")
            
            if replica and replica.Data then
                print("   üîç Available keys in Replica.Data:")
                for k, v in pairs(replica.Data) do
                    print("      ‚Ä¢ " .. tostring(k) .. " = " .. tostring(type(v)))
                end
            end
        end
        
        return inventory
    end
    
    local function getAvailableOres()
        local inventory = getPlayerInventory()
        local ores = {}
        
        local oreTypes = {"Copper","Stone", "Iron","Sand Stone", "Tin", "Cardboardite", "Silver", "Gold", "Bananite", "Mushroomite", "Platinum","Aite"}
        
        for _, oreName in ipairs(oreTypes) do
            if inventory[oreName] and inventory[oreName] > 0 then
                table.insert(ores, {Name = oreName, Amount = inventory[oreName]})
            end
        end
        
        if #ores == 0 then
            print("   üîç Scanning all items for ores...")
            for itemName, amount in pairs(inventory) do
                if string.find(itemName, "Ore") or string.find(itemName, "ore") then
                    table.insert(ores, {Name = itemName, Amount = amount})
                end
            end
        end
        
        return ores
    end
    
    local function selectRandomOres(count)
        local availableOres = getAvailableOres()
        
        if #availableOres == 0 then
            return nil, "No ores found in inventory!"
        end
        
        local totalOres = 0
        for _, ore in ipairs(availableOres) do
            totalOres = totalOres + ore.Amount
        end
        
        if totalOres < count then
            return nil, string.format("Not enough ores! Need %d, have %d", count, totalOres)
        end
        
        local orePool = {}
        for _, ore in ipairs(availableOres) do
            for i = 1, ore.Amount do
                table.insert(orePool, ore.Name)
            end
        end
        
        local selected = {}
        for i = 1, count do
            if #orePool == 0 then break end
            
            local randomIndex = math.random(1, #orePool)
            local oreName = table.remove(orePool, randomIndex)
            
            selected[oreName] = (selected[oreName] or 0) + 1
        end
        
        return selected, nil
    end
    
    local function printInventorySummary()
        print("\n   üì¶ === INVENTORY CHECK ===")
        
        local ores = getAvailableOres()
        
        if #ores == 0 then
            warn("   ‚ùå No ores found in inventory!")
            
            local inv = getPlayerInventory()
            if next(inv) then
                print("   üìã All items in inventory:")
                for item, amount in pairs(inv) do
                    print(string.format("      ‚Ä¢ %s: %d", item, amount))
                end
            else
                warn("   ‚ö†Ô∏è Inventory is completely empty!")
            end
            return
        end
        
        print("   ‚úÖ Available Ores:")
        local total = 0
        for _, ore in ipairs(ores) do
            print(string.format("      ‚Ä¢ %s: %d", ore.Name, ore.Amount))
            total = total + ore.Amount
        end
        print(string.format("      üìä Total: %d ores", total))
        print("   " .. string.rep("=", 28) .. "\n")
    end
    
    ----------------------------------------------------------------
    -- FORGE SYSTEM
    ----------------------------------------------------------------
    getgenv().ForgeHookActive = getgenv().ForgeHookActive or false
    
    local function setupForgeHook()
        if getgenv().ForgeHookActive then
            print("   ‚ö†Ô∏è Forge Hook already active")
            return
        end
        
        if not ForgeService then
            warn("   ‚ùå ForgeService not available!")
            return
        end
        
        print("   ü™ù Installing Forge Hook...")
        local originalChangeSequence = ForgeService.ChangeSequence
        
        ForgeService.ChangeSequence = function(self, sequenceName, args)
            print("      üîÑ Sequence: " .. sequenceName)
            
            local success, result = pcall(originalChangeSequence, self, sequenceName, args)
            
            task.spawn(function()
                if sequenceName == "Melt" then
                    print("      ‚è© Auto: Pouring in 8s...")
                    task.wait(8)
                    self:ChangeSequence("Pour", {ClientTime = 8.5, InContact = true})
                    
                elseif sequenceName == "Pour" then
                    print("      ‚è© Auto: Hammering in 5s...")
                    task.wait(5)
                    self:ChangeSequence("Hammer", {ClientTime = 5.2})
                    
                elseif sequenceName == "Hammer" then
                    print("      ‚è© Auto: Watering in 6s...")
                    task.wait(6)
                    self:ChangeSequence("Water", {ClientTime = 6.5})
                    
                elseif sequenceName == "Water" then
                    print("      ‚è© Auto: Showcasing in 3s...")
                    task.wait(3)
                    self:ChangeSequence("Showcase", {})
                    
                elseif sequenceName == "Showcase" then
                    print("      ‚úÖ Forge completed!")
                end
            end)
            
            return success, result
        end
        
        getgenv().ForgeHookActive = true
        print("   ‚úÖ Forge Hook installed!")
    end
    
    -- üÜï IMPROVED: Use smoothMoveTo with fixed position
    local function moveToForge()
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        local forgePos = FORGE_CONFIG.FORGE_POSITION
        local currentDist = (forgePos - hrp.Position).Magnitude
        
        print(string.format("   üö∂ Moving to Forge at (%.1f, %.1f, %.1f) (%.1f studs away)...", 
            forgePos.X, forgePos.Y, forgePos.Z, currentDist))
        
        -- Use smoothMoveTo with noclip + lock position
        local moveComplete = false
        smoothMoveTo(forgePos, function()
            moveComplete = true
        end)
        
        -- Wait for movement to complete
        local timeout = 15
        local startTime = tick()
        while not moveComplete and tick() - startTime < timeout do
            task.wait(0.1)
        end
        
        -- Cleanup movement
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        print("   ‚úÖ Reached Forge!")
        
        -- Wait 1.5 seconds before opening UI
        print("   ‚è∏Ô∏è  Waiting 1.5s before opening Forge UI...")
        task.wait(1.5)
        
        return true
    end
    
    local function startForge(oreSelection)
        print("   üî• Starting Forge with:")
        for oreName, amount in pairs(oreSelection) do
            print(string.format("      ‚Ä¢ %s x%d", oreName, amount))
        end
        
        local success = pcall(function()
            PROXIMITY_RF:InvokeServer(FORGE_OBJECT)
        end)
        
        if not success then
            warn("   ‚ùå Failed to invoke Forge remote")
            return false
        end
        
        task.wait(1)
        
        if not ForgeService then
            warn("   ‚ùå ForgeService not available!")
            return false
        end
        
        local forgeSuccess = pcall(function()
            ForgeService:ChangeSequence("Melt", {
                Ores = oreSelection,
                ItemType = FORGE_CONFIG.ITEM_TYPE,
                FastForge = false
            })
        end)
        
        if forgeSuccess then
            print("   ‚úÖ Forge Melt started!")
            return true
        else
            warn("   ‚ö†Ô∏è Could not start forge melt")
            return false
        end
    end
    
    local function doForgeLoop()
        print("üî• Action: Auto Forging...")
        
        setupForgeHook()
        
        moveToForge()
        
        local forgeCount = 0
        local consecutiveFailures = 0
        
        while isQuest3StillActive() do
            forgeCount = forgeCount + 1
            print(string.format("\n   üî® Forge Attempt #%d", forgeCount))
            
            printInventorySummary()
            
            local oreSelection, errorMsg = selectRandomOres(FORGE_CONFIG.REQUIRED_ORE_COUNT)
            
            if not oreSelection then
                warn(string.format("\n‚ùå ERROR: %s", errorMsg))
                consecutiveFailures = consecutiveFailures + 1
                
                if consecutiveFailures >= 3 then
                    warn("‚ùå Failed 3 times in a row. Cannot continue forging!")
                    warn("üí° Please mine more ores and try again.")
                    Quest3Active = false
                    break
                end
                
                warn(string.format("‚è≥ Waiting 5s before retry... (%d/3 failures)", consecutiveFailures))
                task.wait(5)
                continue
            end
            
            consecutiveFailures = 0
            
            local success = startForge(oreSelection)
            
            if success then
                print("   ‚è≥ Waiting for forge to complete...")
                task.wait(25)
            else
                warn("   ‚ö†Ô∏è Forge failed, retrying in 3s...")
                task.wait(3)
            end
            
            if not isQuest3StillActive() then
                print("   ‚úÖ Quest complete!")
                break
            end
            
            print(string.format("   ‚è∏Ô∏è Cooling down for %ds...", FORGE_CONFIG.FORGE_DELAY))
            task.wait(FORGE_CONFIG.FORGE_DELAY)
        end
        
        print("\nüõë Quest 3 forging ended")
    end
    
    ----------------------------------------------------------------
    -- MAIN RUNNER
    ----------------------------------------------------------------
    local function Run_Quest3()
        print(string.rep("=", 50))
        print("üöÄ QUEST 3: Learning to Forge!")
        print("üõ°Ô∏è  Noclip + Lock Position enabled")
        print("üìç Forge Position: (-192.3, 29.5, 168.1)")
        print("‚è∏Ô∏è  Wait 1.5s before opening Forge UI")
        print(string.rep("=", 50))
        
        local questID, objList = getQuestObjectives("Learning to Forge!")
        
        if not questID then
            warn("‚ùå Quest 'Learning to Forge!' not found!")
            warn("üí° Make sure the quest is active in your quest log.")
            Quest3Active = false
            return
        end
        
        print("‚úÖ Quest found (ID: " .. questID .. ")")
        
        print("\n" .. string.rep("=", 50))
        print("üî• Starting Forge Sequence...")
        print(string.rep("=", 50))
        
        doForgeLoop()
        
        closeForgeUI()
        
        if Quest3Active == false and not isQuestComplete("Learning to Forge!") then
            warn("\n" .. string.rep("=", 50))
            warn("‚ùå Quest 3 Failed!")
            warn("Reason: Not enough ores to continue")
            warn(string.rep("=", 50))
        else
            print("\n" .. string.rep("=", 50))
            print("‚úÖ Quest 3 Complete!")
            print(string.rep("=", 50))
        end
        
        Quest3Active = false
        disableNoclip()
        cleanupState()
    end
    
    ----------------------------------------------------------------
    -- START
    ----------------------------------------------------------------
    Run_Quest3()
end

----------------------------------------------------------------
-- QUEST 4 ORIGINAL (from 4.lua)
----------------------------------------------------------------
local function RunQuest04()
    -- Created file: 4.lua-- QUEST 4: "Getting Equipped!" (SMART SYSTEM: Priority-based + Flexible + UI Damage Reading)
    -- Priority Order: 1) Equip Best Weapon ‚Üí 2) Sell Weakest Weapon
    
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Workspace = game:GetService("Workspace")
    
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    ----------------------------------------------------------------
    -- CONFIG
    ----------------------------------------------------------------
    local Quest4Active = true
    
    -- Weapon Types (ALL WEAPONS IN GAME - 23 Types)
    local WEAPON_TYPES = {
        "Dagger", "Falchion Knife", "Gladius Dagger", "Hook",
        "Crusaders Sword", "Long Sword", "Falchion Sword", "Gladius Sword",
        "Cutlass", "Rapier", "Great Sword", "Uchigatana", "Tachi",
        "Double Battle Axe", "Hammer", "Skull Crusher", "Scythe",
        "Dragon Slayer", "Comically Large Spoon", "Chaos", "Ironhand",
        "Boxing Gloves", "Relevator"
    }
    
    -- Sell Config
    local SELL_CONFIG = {
        NPC_NAME = "Marbles",
        KEEP_BEST_COUNT = 1
    }
    
    -- üî• NEW: Priority Order
    local PRIORITY_ORDER = {
        "Equip",   -- 1. ‡πÉ‡∏™‡πà‡∏≠‡∏≤‡∏ß‡∏∏‡∏ò‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô
        "Sell",    -- 2. ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡∏Ç‡∏≤‡∏¢‡∏≠‡∏≤‡∏ß‡∏∏‡∏ò‡πÅ‡∏¢‡πà‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
    }
    
    ----------------------------------------------------------------
    -- KNIT SETUP
    ----------------------------------------------------------------
    local KnitPackage = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit")
    local Knit = require(KnitPackage)
    
    if not Knit.OnStart then 
        pcall(function() Knit.Start():await() end)
    end
    
    local CharacterService = nil
    local PlayerController = nil
    local ProximityService = nil
    local DialogueService = nil
    local UIController = nil
    
    pcall(function()
        CharacterService = Knit.GetService("CharacterService")
        PlayerController = Knit.GetController("PlayerController")
        ProximityService = Knit.GetService("ProximityService")
        DialogueService = Knit.GetService("DialogueService")
    end)
    
    pcall(function()
        for _, v in pairs(getgc(true)) do
            if type(v) == "table" then
                if rawget(v, "Open") and rawget(v, "Close") and rawget(v, "Modules") then
                    UIController = v
                    break
                end
            end
        end
    end)
    
    if CharacterService then print("‚úÖ CharacterService Ready!") else warn("‚ö†Ô∏è CharacterService not found") end
    if PlayerController then print("‚úÖ PlayerController Ready!") else warn("‚ö†Ô∏è PlayerController not found") end
    if ProximityService then print("‚úÖ ProximityService Ready!") else warn("‚ö†Ô∏è ProximityService not found") end
    if DialogueService then print("‚úÖ DialogueService Ready!") else warn("‚ö†Ô∏è DialogueService not found") end
    if UIController then print("‚úÖ UIController Ready!") else warn("‚ö†Ô∏è UIController not found") end
    
    ----------------------------------------------------------------
    -- QUEST SYSTEM
    ----------------------------------------------------------------
    local function getQuestObjectives(questName)
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil, nil end
        
        local list = gui:FindFirstChild("Main") and gui.Main:FindFirstChild("Screen") 
                     and gui.Main.Screen:FindFirstChild("Quests") and gui.Main.Screen.Quests:FindFirstChild("List")
        if not list then return nil, nil end
        
        local questID = nil
        for _, child in ipairs(list:GetChildren()) do
            local id = string.match(child.Name, "^Introduction(%d+)Title$")
            if id and child:FindFirstChild("Frame") and child.Frame:FindFirstChild("TextLabel") then
                if child.Frame.TextLabel.Text == questName then
                    questID = id
                    break
                end
            end
        end
        
        if not questID then return nil, nil end
        
        local objList = list:FindFirstChild("Introduction" .. questID .. "List")
        return questID, objList
    end
    
    local function isObjectiveComplete(item)
        if not item then return false end
        local check = item:FindFirstChild("Main") and item.Main:FindFirstChild("Frame") and item.Main.Frame:FindFirstChild("Check")
        return check and check.Visible
    end
    
    local function getObjectiveText(item)
        local lbl = item:FindFirstChild("Main") and item.Main:FindFirstChild("TextLabel")
        return lbl and lbl.Text or ""
    end
    
    local function isQuest4StillActive()
        if not Quest4Active then return false end
        
        local questID, objList = getQuestObjectives("Getting Equipped!")
        if not questID or not objList then
            print("üõë Quest 'Getting Equipped!' not found!")
            Quest4Active = false
            return false
        end
        
        return true
    end
    
    -- üî• NEW: Classify objective type
    local function getObjectiveType(text)
        if string.find(text, "Equip") and string.find(text, "Weapon") then
            return "Equip"
        elseif string.find(text, "Sell") and string.find(text, "Weapon") then
            return "Sell"
        else
            return "Unknown"
        end
    end
    
    -- üî• NEW: Check if objective can be done now
    local function canDoObjective(objType)
        if objType == "Sell" then
            -- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏≠‡∏≤‡∏ß‡∏∏‡∏ò‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 1 ‡∏ä‡∏¥‡πâ‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            local weapons = getPlayerWeapons()
            if #weapons <= 1 then
                print("   ‚ö†Ô∏è Cannot Sell: Need at least 2 weapons (have " .. #weapons .. ")")
                return false
            end
        end
        return true
    end
    
    ----------------------------------------------------------------
    -- UI MANAGEMENT
    ----------------------------------------------------------------
    local function openToolsMenu()
        if not UIController then
            warn("   ‚ö†Ô∏è UIController not available, using fallback...")
            return false
        end
        
        if UIController.Modules["Menu"] then
            pcall(function() UIController:Open("Menu") end)
            task.wait(0.5)
            
            local menuModule = UIController.Modules["Menu"]
            if menuModule.OpenTab then
                pcall(function() menuModule:OpenTab("Tools") end)
            elseif menuModule.SwitchTab then
                pcall(function() menuModule:SwitchTab("Tools") end)
            end
            
            task.wait(0.5)
            return true
        end
        
        return false
    end
    
    local function closeToolsMenu()
        if UIController and UIController.Close then
            pcall(function() UIController:Close("Menu") end)
            task.wait(0.3)
        end
    end
    
    local function getDamageFromUI(guid)
        local menuGui = playerGui:FindFirstChild("Menu")
        if not menuGui then return 0 end
        
        local toolsFrame = menuGui:FindFirstChild("Frame") and menuGui.Frame:FindFirstChild("Frame") 
                           and menuGui.Frame.Frame:FindFirstChild("Menus") 
                           and menuGui.Frame.Frame.Menus:FindFirstChild("Tools")
                           and menuGui.Frame.Frame.Menus.Tools:FindFirstChild("Frame")
        
        if not toolsFrame then return 0 end
        
        local weaponFrame = toolsFrame:FindFirstChild(guid)
        if not weaponFrame then return 0 end
        
        local stats = weaponFrame:FindFirstChild("Stats")
        if not stats then return 0 end
        
        local dmgLabel = stats:FindFirstChild("DMG")
        if not dmgLabel or not dmgLabel:IsA("TextLabel") then return 0 end
        
        local text = dmgLabel.Text
        local damageValue = tonumber(string.match(text, "([%d%.]+)"))
        
        return damageValue or 0
    end
    
    ----------------------------------------------------------------
    -- EQUIPPED WEAPON CHECK
    ----------------------------------------------------------------
    local function getEquippedWeaponGUID()
        print("üîç Checking equipped weapon...")
        
        -- Method 1: Check from Character.Tool (‡∏≠‡∏≤‡∏ß‡∏∏‡∏ò‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏°‡∏∑‡∏≠)
        local char = player.Character
        if not char then return nil end
        
        local tool = char:FindFirstChildWhichIsA("Tool")
        if not tool then 
            print("   ‚ö†Ô∏è No tool in hand!")
            return nil 
        end
        
        print(string.format("   üîß Tool in hand: %s", tool.Name))
        
        -- Method 2: Match ‡∏Å‡∏±‡∏ö Replica ‡πÇ‡∏î‡∏¢‡πÄ‡∏ä‡πá‡∏Ñ Equipped = true
        if not PlayerController or not PlayerController.Replica then return nil end
        
        local replica = PlayerController.Replica
        if not replica.Data or not replica.Data.Inventory or not replica.Data.Inventory.Equipments then
            return nil
        end
        
        local equipments = replica.Data.Inventory.Equipments
        
        -- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ó‡∏∏‡∏Å weapon ‡∏ß‡πà‡∏≤ Equipped = true ‡πÅ‡∏•‡∏∞ Type ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö tool.Name
        for id, item in pairs(equipments) do
            if type(item) == "table" and item.Type and item.GUID then
                local isEquipped = (item.Equipped == true)  -- ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ Equipped flag
                local isMatchingType = (item.Type == tool.Name or string.find(tool.Name, item.Type))
                
                print(string.format("   - %s | GUID: %s | Equipped: %s | Match: %s", 
                    item.Type, item.GUID, tostring(isEquipped), tostring(isMatchingType)))
                
                -- ‚úÖ ‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏£‡∏á‡∏ó‡∏±‡πâ‡∏á Type ‡πÅ‡∏•‡∏∞ Equipped flag
                if isEquipped and isMatchingType then
                    print(string.format("   ‚úÖ Found equipped weapon: %s (GUID: %s)", item.Type, item.GUID))
                    return item.GUID
                end
            end
        end
        
        warn("   ‚ùå Could not find equipped weapon GUID!")
        return nil
    end
    
    ----------------------------------------------------------------
    -- WEAPON MANAGEMENT
    ----------------------------------------------------------------
    local function isWeaponType(itemType)
        for _, weaponType in ipairs(WEAPON_TYPES) do
            if itemType == weaponType then
                return true
            end
        end
        return false
    end

    local function isWeaponEquippedFromUI(guid)
        local menuGui = playerGui:FindFirstChild("Menu")
        if not menuGui then return false end
        
        local toolsFrame = menuGui:FindFirstChild("Frame") and menuGui.Frame:FindFirstChild("Frame") 
                        and menuGui.Frame.Frame:FindFirstChild("Menus") 
                        and menuGui.Frame.Frame.Menus:FindFirstChild("Tools")
                        and menuGui.Frame.Frame.Menus.Tools:FindFirstChild("Frame")
        
        if not toolsFrame then return false end
        
        local weaponFrame = toolsFrame:FindFirstChild(guid)
        if not weaponFrame then return false end
        
        -- ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ path: weaponFrame.Equip.TextLabel.Text
        local equipButton = weaponFrame:FindFirstChild("Equip")
        if not equipButton then return false end
        
        local textLabel = equipButton:FindFirstChild("TextLabel")
        if not textLabel or not textLabel:IsA("TextLabel") then return false end
        
        -- ‚úÖ ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô "Unequip" ‡πÅ‡∏õ‡∏•‡∏ß‡πà‡∏≤ weapon ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å equipped ‡∏≠‡∏¢‡∏π‡πà
        return textLabel.Text == "Unequip"
    end

    function getPlayerWeapons()
        if not PlayerController or not PlayerController.Replica then
            warn("   ‚ö†Ô∏è Replica not available!")
            return {}
        end
        
        local replica = PlayerController.Replica
        
        if not replica.Data or not replica.Data.Inventory or not replica.Data.Inventory.Equipments then
            warn("   ‚ö†Ô∏è Equipments not found in Replica!")
            return {}
        end
        
        print("   üìÇ Opening Tools menu to read damage...")
        openToolsMenu()
        
        local equipments = replica.Data.Inventory.Equipments
        local weapons = {}
        
        for id, item in pairs(equipments) do
            if type(item) == "table" and item.Type and isWeaponType(item.Type) then
                local guid = item.GUID
                local quality = item.Quality or 0
                local damage = getDamageFromUI(guid)
                
                -- ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≤‡∏Å UI ‡∏ß‡πà‡∏≤ equipped ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                local isEquipped = isWeaponEquippedFromUI(guid)
                
                table.insert(weapons, {
                    ID = id,
                    Type = item.Type,
                    Damage = damage,
                    Quality = quality,
                    GUID = guid,
                    Data = item,
                    IsEquipped = isEquipped  -- ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° field ‡∏ô‡∏µ‡πâ
                })
                
                print(string.format("      - %s | Dmg: %.2f | GUID: %s | Equipped: %s", 
                    item.Type, damage, guid, tostring(isEquipped)))
            end
        end
        
        closeToolsMenu()
        
        return weapons
    end
    
    local function findBestWeapon()
        local weapons = getPlayerWeapons()
        
        if #weapons == 0 then
            return nil, "No weapons found in inventory!"
        end
        
        local bestWeapon = weapons[1]
        
        for _, weapon in ipairs(weapons) do
            if weapon.Damage > bestWeapon.Damage then
                bestWeapon = weapon
            elseif weapon.Damage == bestWeapon.Damage and weapon.Quality > bestWeapon.Quality then
                bestWeapon = weapon
            end
        end
        
        return bestWeapon, nil
    end
    
    local function findWeakestWeapon()
        local weapons = getPlayerWeapons()
        
        if #weapons == 0 then
            return nil, "No weapons found in inventory!"
        end
        
        if #weapons <= SELL_CONFIG.KEEP_BEST_COUNT then
            return nil, "Not enough weapons to sell!"
        end
        
        print("\nüîç Finding weakest weapon to sell...")
        
        -- ‚úÖ STEP 1: ‡∏´‡∏≤ Weakest weapon ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ equipped (‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≤‡∏Å UI)
        local weakestWeapon = nil
        for _, weapon in ipairs(weapons) do
            if not weapon.IsEquipped then  -- ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≤‡∏Å IsEquipped flag
                if not weakestWeapon then
                    weakestWeapon = weapon
                elseif weapon.Damage < weakestWeapon.Damage then
                    weakestWeapon = weapon
                elseif weapon.Damage == weakestWeapon.Damage and weapon.Quality < weakestWeapon.Quality then
                    weakestWeapon = weapon
                end
            else
                print(string.format("   ‚ö†Ô∏è Skipping equipped weapon: %s (Dmg: %.2f, Quality: %.1f)", 
                    weapon.Type, weapon.Damage, weapon.Quality))
            end
        end
        
        -- ‚úÖ STEP 2: ‡∏ñ‡πâ‡∏≤‡πÄ‡∏à‡∏≠ weakest ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ equipped ‚Üí ‡πÉ‡∏ä‡πâ‡πÄ‡∏•‡∏¢
        if weakestWeapon then
            print(string.format("   ‚úÖ Selected weakest (not equipped): %s | Dmg: %.2f | GUID: %s", 
                weakestWeapon.Type, weakestWeapon.Damage, weakestWeapon.GUID))
            return weakestWeapon, nil
        end
        
        -- ‚ö° STEP 3: FALLBACK - ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ weakest ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ equipped
        -- ‡πÉ‡∏´‡πâ‡∏Ç‡∏≤‡∏¢‡∏≠‡∏≤‡∏ß‡∏∏‡∏ò‡πÉ‡∏î‡πÜ ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ equipped (‡πÑ‡∏°‡πà‡∏™‡∏ô‡∏î‡∏≤‡πÄ‡∏°‡∏à)
        print("   ‚ö†Ô∏è [FALLBACK] Weakest weapon is equipped! Selecting any sellable weapon...")
        for _, weapon in ipairs(weapons) do
            if not weapon.IsEquipped then
                print(string.format("   ‚Üí Selected fallback: %s | Dmg: %.2f | GUID: %s", 
                    weapon.Type, weapon.Damage, weapon.GUID))
                return weapon, nil
            end
        end
        
        -- ‚úÖ STEP 4: ‡∏ñ‡πâ‡∏≤‡∏ó‡∏∏‡∏Å‡∏≠‡∏≤‡∏ß‡∏∏‡∏ò‡∏ñ‡∏π‡∏Å equipped (‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£‡πÄ‡∏Å‡∏¥‡∏î)
        return nil, "All weapons are equipped or no valid weapon to sell!"
    end
    






    local function printWeaponsSummary()
        print("\n   ‚öîÔ∏è  === WEAPONS INVENTORY ===")
        
        local weapons = getPlayerWeapons()
        
        if #weapons == 0 then
            warn("   ‚ùå No weapons found!")
            return
        end
        
        print(string.format("   ‚úÖ Found %d weapon(s):", #weapons))
        
        table.sort(weapons, function(a, b)
            if a.Damage ~= b.Damage then
                return a.Damage > b.Damage
            else
                return a.Quality > b.Quality
            end
        end)
        
        for i, weapon in ipairs(weapons) do
            local marker = ""
            if i == 1 then marker = " üëë BEST" end
            if i == #weapons and #weapons > 1 and not weapon.IsEquipped then 
                marker = " üóëÔ∏è WORST" 
            end
            if weapon.IsEquipped then 
                marker = marker .. " ‚ö° EQUIPPED" 
            end
            
            print(string.format("      %d. %s - Dmg: %.2f | Quality: %.1f%s", 
                i, weapon.Type, weapon.Damage, weapon.Quality, marker))
        end
        
        print("   " .. string.rep("=", 30) .. "\n")
    end
    
    ----------------------------------------------------------------
    -- FORCE RESTORE STATE
    ----------------------------------------------------------------
    local function forceRestoreState()
        print("   üîß Restoring Player State...")
        
        local char = player.Character
        if char then
            local status = char:FindFirstChild("Status")
            if status then
                for _, tag in ipairs(status:GetChildren()) do
                    if tag.Name == "DisableBackpack" or tag.Name == "NoMovement" or tag.Name == "Talking" then
                        tag:Destroy()
                    end
                end
            end
            
            if char:FindFirstChild("Humanoid") then
                char.Humanoid.WalkSpeed = 16
                char.Humanoid.JumpPower = 50
            end
        end
        
        local gui = player:FindFirstChild("PlayerGui")
        if gui then
            local dUI = gui:FindFirstChild("DialogueUI")
            if dUI then dUI.Enabled = false end
            
            local main = gui:FindFirstChild("Main")
            if main then main.Enabled = true end
            
            local backpack = gui:FindFirstChild("BackpackGui")
            if backpack then backpack.Enabled = true end
        end
        
        local cam = Workspace.CurrentCamera
        if cam then
            cam.CameraType = Enum.CameraType.Custom
        end
        
        pcall(function()
            local dialogueRE = ReplicatedStorage.Shared.Packages.Knit.Services.DialogueService.RE.DialogueEvent
            dialogueRE:FireServer("Closed")
        end)
        
        print("   ‚úÖ State restored!")
    end
    
    ----------------------------------------------------------------
    -- ACTIONS
    ----------------------------------------------------------------
    local function doEquipBestWeapon()
        print("‚öîÔ∏è  Objective: Equipping Best Weapon...")
        
        printWeaponsSummary()
        
        local bestWeapon, errorMsg = findBestWeapon()
        
        if not bestWeapon then
            warn(string.format("   ‚ùå ERROR: %s", errorMsg))
            return false
        end
        
        print(string.format("   üéØ Selected: %s (Dmg: %.2f | Quality: %.1f)", bestWeapon.Type, bestWeapon.Damage, bestWeapon.Quality))
        
        if not CharacterService then
            warn("   ‚ùå CharacterService not available!")
            return false
        end
        
        local success, err = pcall(function()
            CharacterService:EquipItem(bestWeapon.Data)
        end)
        
        if success then
            print("   ‚úÖ Equipped successfully!")
            return true
        else
            warn("   ‚ùå Failed to equip: " .. tostring(err))
            return false
        end
    end
    
    local function doSellWeakestWeapon()
        print("üí∞ Objective: Selling Weakest Weapon...")
        
        printWeaponsSummary()
        
        local weakestWeapon, errorMsg = findWeakestWeapon()
        
        if not weakestWeapon then
            warn(string.format("   ‚ùå ERROR: %s", errorMsg))
            return false
        end
        
        print(string.format("   üéØ Selected: %s (Dmg: %.2f | Quality: %.1f)", weakestWeapon.Type, weakestWeapon.Damage, weakestWeapon.Quality))
        
        local basket = {}
        basket[weakestWeapon.GUID] = true
        
        local proximity = Workspace:FindFirstChild("Proximity")
        local npc = proximity and (proximity:FindFirstChild(SELL_CONFIG.NPC_NAME) or proximity:FindFirstChild("Greedy Cey"))
        
        if not npc then
            warn("   ‚ùå NPC not found!")
            return false
        end
        
        if not ProximityService or not DialogueService then
            warn("   ‚ùå Services not available!")
            return false
        end
        
        print("   üîå Opening dialogue...")
        local success1 = pcall(function()
            ProximityService:ForceDialogue(npc, "SellConfirm")
        end)
        
        if not success1 then
            warn("   ‚ùå Failed to open dialogue")
            return false
        end
        
        task.wait(0.2)
        
        print("   üí∏ Selling weapon...")
        local success2 = pcall(function()
            DialogueService:RunCommand("SellConfirm", { Basket = basket })
        end)
        
        if success2 then
            print("   ‚úÖ Sold successfully!")
            task.wait(0.1)
            forceRestoreState()
            return true
        else
            warn("   ‚ùå Sell failed")
            forceRestoreState()
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- üî• SMART QUEST RUNNER (Priority-based + Flexible)
    ----------------------------------------------------------------
    local function RunQuest4_Smart()
        print(string.rep("=", 50))
        print("üöÄ QUEST 4: Getting Equipped!")
        print("üéØ SMART SYSTEM: Priority-based + Flexible")
        print("üìã Priority Order: Equip ‚Üí Sell")
        print(string.rep("=", 50))
        
        local questID, objList = getQuestObjectives("Getting Equipped!")
        
        if not questID then
            warn("‚ùå Quest 'Getting Equipped!' not found!")
            Quest4Active = false
            return
        end
        
        print("‚úÖ Quest found (ID: " .. questID .. ")")
        
        -- Collect all objectives
        local objectives = {}
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                local text = getObjectiveText(item)
                local objType = getObjectiveType(text)
                
                table.insert(objectives, {
                    order = tonumber(item.Name),
                    frame = item,
                    text = text,
                    type = objType
                })
            end
        end
        
        -- üî• Sort by priority
        table.sort(objectives, function(a, b)
            local function getPriority(type)
                for i, priorityType in ipairs(PRIORITY_ORDER) do
                    if string.find(type, priorityType) then
                        return i
                    end
                end
                return 999
            end
            return getPriority(a.type) < getPriority(b.type)
        end)
        
        print("\n" .. string.rep("=", 50))
        print("‚öôÔ∏è  Quest Objectives (Priority Order):")
        for i, obj in ipairs(objectives) do
            local complete = isObjectiveComplete(obj.frame)
            print(string.format("   %d. [%s] %s [%s]", i, obj.type, obj.text, complete and "‚úÖ" or "‚è≥"))
        end
        print(string.rep("=", 50))
        
        -- üî• Main loop: Process objectives by priority
        local maxAttempts = 5
        local attempt = 0
        
        while isQuest4StillActive() and attempt < maxAttempts do
            attempt = attempt + 1
            print(string.format("\nüîÑ Quest Cycle #%d", attempt))
            
            local allComplete = true
            local didSomething = false
            
            for _, obj in ipairs(objectives) do
                if not isQuest4StillActive() then
                    print("üõë Quest disappeared!")
                    break
                end
                
                local complete = isObjectiveComplete(obj.frame)
                
                if not complete then
                    allComplete = false
                    
                    -- üî• Check if we can do this objective now
                    if not canDoObjective(obj.type) then
                        print(string.format("   ‚è≠Ô∏è  Skipping [%s] - Cannot do right now", obj.type))
                        continue
                    end
                    
                    print(string.format("\nüìã Processing [%s]: %s", obj.type, obj.text))
                    
                    -- Execute objective
                    local success = false
                    
                    if obj.type == "Equip" then
                        success = doEquipBestWeapon()
                        didSomething = true
                        task.wait(1.5)
                        
                    elseif obj.type == "Sell" then
                        success = doSellWeakestWeapon()
                        didSomething = true
                        task.wait(1.5)
                        
                    else
                        warn("   ‚ö†Ô∏è Unknown objective type: " .. obj.type)
                    end
                    
                    if success then
                        print(string.format("   ‚úÖ Action completed!"))
                    else
                        warn(string.format("   ‚ö†Ô∏è Action failed, will retry"))
                    end
                    
                    -- Check if complete
                    task.wait(1)
                    if isObjectiveComplete(obj.frame) then
                        print(string.format("‚úÖ [%s] Complete!", obj.type))
                    else
                        print(string.format("‚è≥ [%s] Still in progress", obj.type))
                    end
                end
            end
            
            if allComplete then
                print("\nüéâ All objectives complete!")
                break
            end
            
            if not didSomething then
                warn("\n‚ö†Ô∏è No objectives could be completed this cycle!")
                print("   Waiting 2s before retry...")
                task.wait(2)
            end
        end
        
        -- Final check
        task.wait(1)
        
        local allComplete = true
        for _, obj in ipairs(objectives) do
            if not isObjectiveComplete(obj.frame) then
                allComplete = false
                warn(string.format("   ‚ö†Ô∏è [%s] incomplete: %s", obj.type, obj.text))
            end
        end
        
        if allComplete then
            print("\n" .. string.rep("=", 50))
            print("‚úÖ Quest 4 Complete!")
            print(string.rep("=", 50))
        else
            warn("\n" .. string.rep("=", 50))
            warn("‚ö†Ô∏è Quest 4 incomplete after " .. attempt .. " cycles")
            warn(string.rep("=", 50))
        end
        
        Quest4Active = false
    end
    
    ----------------------------------------------------------------
    -- START
    ----------------------------------------------------------------
    RunQuest4_Smart()
end

----------------------------------------------------------------
-- QUEST 5 ORIGINAL (from 5.lua)
----------------------------------------------------------------
local function RunQuest05()
    -- QUEST 5: "New Pickaxe!" (SMART SYSTEM: Priority-based + Flexible + Dynamic Zombie Tracking)
    -- Priority Order: 1) Purchase ‚Üí 2) Kill Zombies ‚Üí 3) Mine Rocks
    
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local Workspace = game:GetService("Workspace")
    
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    ----------------------------------------------------------------
    -- CONFIG
    ----------------------------------------------------------------
    local Quest5Active = true
    local IsMiningActive = false
    local IsKillingActive = false
    
    local QUEST_CONFIG = {
        QUEST_NAME = "New Pickaxe!",
        PICKAXE_NAME = "Bronze Pickaxe",
        PICKAXE_AMOUNT = 1,
        NPC_POSITION = Vector3.new(-81.03, 28.51, 84.68),
        MINING_PATH = "Island1CaveMid",
        ROCK_NAME = "Rock",
        STARTING_POSITION = Vector3.new(50, -10, -200),
        UNDERGROUND_OFFSET = 4,
        ZOMBIE_UNDERGROUND_OFFSET = 5,
        ZOMBIE_MAX_DISTANCE = 50,
        LAYING_ANGLE = 90,
        MOVE_SPEED = 20,
        
        -- üî• NEW: Priority Order
        PRIORITY_ORDER = {
            "Purchase",   -- 1. ‡∏ã‡∏∑‡πâ‡∏≠ Pickaxe ‡∏Å‡πà‡∏≠‡∏ô
            "Kill",       -- 2. ‡∏Ü‡πà‡∏≤ Zombie
            "Mine",       -- 3. ‡∏Ç‡∏∏‡∏î‡πÅ‡∏£‡πà (‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢)
        }
    }
    
    ----------------------------------------------------------------
    -- KNIT SETUP
    ----------------------------------------------------------------
    local KnitPackage = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit")
    local Knit = require(KnitPackage)
    
    if not Knit.OnStart then 
        pcall(function() Knit.Start():await() end)
    end
    
    local CharacterService = nil
    local PlayerController = nil
    local ProximityService = nil
    
    pcall(function()
        CharacterService = Knit.GetService("CharacterService")
        PlayerController = Knit.GetController("PlayerController")
        ProximityService = Knit.GetService("ProximityService")
    end)
    
    local ToolController = nil
    local ToolActivatedFunc = nil
    
    pcall(function()
        for _, v in pairs(getgc(true)) do
            if type(v) == "table" then
                if rawget(v, "Name") == "ToolController" and rawget(v, "ToolActivated") then
                    ToolController = v
                    ToolActivatedFunc = v.ToolActivated
                    break
                end
            end
        end
    end)
    
    local SERVICES = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")
    local PURCHASE_RF = SERVICES:WaitForChild("ProximityService"):WaitForChild("RF"):WaitForChild("Purchase")
    local CHAR_RF = SERVICES:WaitForChild("CharacterService"):WaitForChild("RF"):WaitForChild("EquipItem")
    local TOOL_RF_BACKUP = SERVICES:WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("ToolActivated")
    
    local MINING_FOLDER_PATH = Workspace:WaitForChild("Rocks")
    local LIVING_FOLDER = Workspace:WaitForChild("Living")
    
    if CharacterService then print("‚úÖ CharacterService Ready!") else warn("‚ö†Ô∏è CharacterService not found") end
    if PlayerController then print("‚úÖ PlayerController Ready!") else warn("‚ö†Ô∏è PlayerController not found") end
    if ProximityService then print("‚úÖ ProximityService Ready!") else warn("‚ö†Ô∏è ProximityService not found") end
    if ToolController then print("‚úÖ ToolController Ready!") else warn("‚ö†Ô∏è ToolController not found") end
    if PURCHASE_RF then print("‚úÖ Purchase Remote Ready!") else warn("‚ö†Ô∏è Purchase Remote not found") end
    
    ----------------------------------------------------------------
    -- STATE MANAGEMENT
    ----------------------------------------------------------------
    local State = {
        currentTarget = nil,
        targetDestroyed = false,
        hpWatchConn = nil,
        noclipConn = nil,
        moveConn = nil,
        positionLockConn = nil,
        bodyVelocity = nil,
        bodyGyro = nil,
        currentObjectiveFrame = nil,
    }
    
    local function cleanupState()
        if State.hpWatchConn then State.hpWatchConn:Disconnect() State.hpWatchConn = nil end
        if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.positionLockConn then State.positionLockConn:Disconnect() State.positionLockConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        State.currentTarget = nil
        State.targetDestroyed = false
        if ToolController then ToolController.holdingM1 = false end
    end
    
    ----------------------------------------------------------------
    -- RESPAWN HANDLER
    ----------------------------------------------------------------
    local function setupRespawnHandler()
        player.CharacterAdded:Connect(function(character)
            print("üíÄ Character respawned!")
            
            local hrp = character:WaitForChild("HumanoidRootPart", 5)
            if not hrp then return end
            
            task.wait(1)
            
            if (IsMiningActive or IsKillingActive) and Quest5Active then
                print("üîÑ Returning to action after respawn...")
                task.wait(2)
            end
        end)
    end
    
    ----------------------------------------------------------------
    -- QUEST SYSTEM
    ----------------------------------------------------------------
    local function getQuestObjectives(questName)
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil, nil end
        
        local list = gui:FindFirstChild("Main") and gui.Main:FindFirstChild("Screen") 
                     and gui.Main.Screen:FindFirstChild("Quests") and gui.Main.Screen.Quests:FindFirstChild("List")
        if not list then return nil, nil end
        
        local questID = nil
        for _, child in ipairs(list:GetChildren()) do
            local id = string.match(child.Name, "^Introduction(%d+)Title$")
            if id and child:FindFirstChild("Frame") and child.Frame:FindFirstChild("TextLabel") then
                if child.Frame.TextLabel.Text == questName then
                    questID = id
                    break
                end
            end
        end
        
        if not questID then return nil, nil end
        
        local objList = list:FindFirstChild("Introduction" .. questID .. "List")
        return questID, objList
    end
    
    local function isObjectiveComplete(item)
        if not item then return false end
        local check = item:FindFirstChild("Main") and item.Main:FindFirstChild("Frame") and item.Main.Frame:FindFirstChild("Check")
        return check and check.Visible
    end
    
    local function getObjectiveText(item)
        local lbl = item:FindFirstChild("Main") and item.Main:FindFirstChild("TextLabel")
        return lbl and lbl.Text or ""
    end
    
    local function isQuest5StillActive()
        if not Quest5Active then return false end
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        if not questID or not objList then
            print("üõë Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' not found!")
            Quest5Active = false
            return false
        end
        
        return true
    end
    
    local function isCurrentObjectiveComplete()
        if State.currentObjectiveFrame then
            return isObjectiveComplete(State.currentObjectiveFrame)
        end
        return false
    end
    
    -- üî• NEW: Classify objective type
    local function getObjectiveType(text)
        if string.find(text, "Purchase") or string.find(text, "Buy") or string.find(text, "Pickaxe") then
            return "Purchase"
        elseif string.find(text, "Kill") or string.find(text, "Zombie") or string.find(text, "Defeat") then
            return "Kill"
        elseif string.find(text, "Get Ore") or string.find(text, "Mine") or string.find(text, "Rock") then
            return "Mine"
        else
            return "Unknown"
        end
    end
    
    -- üî• NEW: Check if objective can be done now (Quest 5 has no dependencies)
    local function canDoObjective(objType)
        -- Quest 5 ‡πÑ‡∏°‡πà‡∏°‡∏µ dependency ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô Quest 7 (Forge ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏£‡πà)
        -- ‡∏ó‡∏∏‡∏Å objective ‡∏ó‡∏≥‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢
        return true
    end
    
    ----------------------------------------------------------------
    -- HELPER FUNCTIONS
    ----------------------------------------------------------------
    local HOTKEY_MAP = {
        ["1"] = Enum.KeyCode.One, ["2"] = Enum.KeyCode.Two, ["3"] = Enum.KeyCode.Three,
        ["4"] = Enum.KeyCode.Four, ["5"] = Enum.KeyCode.Five, ["6"] = Enum.KeyCode.Six,
        ["7"] = Enum.KeyCode.Seven, ["8"] = Enum.KeyCode.Eight, ["9"] = Enum.KeyCode.Nine, ["0"] = Enum.KeyCode.Zero
    }
    
    local function pressKey(keyCode)
        if not keyCode then return end
        VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
        task.wait(0.05)
        VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
    end
    
    local function findPickaxeSlotKey()
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil end
        local hotbar = gui:FindFirstChild("BackpackGui") and gui.BackpackGui:FindFirstChild("Backpack") and gui.BackpackGui.Backpack:FindFirstChild("Hotbar")
        if hotbar then
            for _, slotFrame in ipairs(hotbar:GetChildren()) do
                local frame = slotFrame:FindFirstChild("Frame")
                local label = frame and frame:FindFirstChild("ToolName")
                if label and label:IsA("TextLabel") and string.find(label.Text, "Pickaxe") then
                    return HOTKEY_MAP[slotFrame.Name]
                end
            end
        end
        return nil
    end
    
    local function findWeaponSlotKey()
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil end
        local hotbar = gui:FindFirstChild("BackpackGui") and gui.BackpackGui:FindFirstChild("Backpack") and gui.BackpackGui.Backpack:FindFirstChild("Hotbar")
        if hotbar then
            for _, slotFrame in ipairs(hotbar:GetChildren()) do
                local frame = slotFrame:FindFirstChild("Frame")
                local label = frame and frame:FindFirstChild("ToolName")
                if label and label:IsA("TextLabel") and not string.find(label.Text, "Pickaxe") and label.Text ~= "" then
                    return HOTKEY_MAP[slotFrame.Name], label.Text
                end
            end
        end
        return nil, nil
    end
    
    local function checkMiningError()
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return false end
        local notif = gui:FindFirstChild("Notifications")
        if notif and notif:FindFirstChild("Screen") and notif.Screen:FindFirstChild("NotificationsFrame") then
            for _, child in ipairs(notif.Screen.NotificationsFrame:GetChildren()) do
                local lbl = child:FindFirstChild("TextLabel", true)
                if lbl and string.find(lbl.Text, "Someone else is already mining") then return true end
            end
        end
        return false
    end
    
    local function getRockUndergroundPosition(rockModel)
        if not rockModel or not rockModel.Parent then return nil end
        
        local pivotCFrame = nil
        
        pcall(function()
            if rockModel.GetPivot then
                pivotCFrame = rockModel:GetPivot()
            elseif rockModel.WorldPivot then
                pivotCFrame = rockModel.WorldPivot
            end
        end)
        
        if pivotCFrame then
            local pos = pivotCFrame.Position
            return Vector3.new(pos.X, pos.Y - QUEST_CONFIG.UNDERGROUND_OFFSET, pos.Z)
        end
        
        if rockModel.PrimaryPart then
            local pos = rockModel.PrimaryPart.Position
            return Vector3.new(pos.X, pos.Y - QUEST_CONFIG.UNDERGROUND_OFFSET, pos.Z)
        end
        
        local part = rockModel:FindFirstChildWhichIsA("BasePart")
        if part then
            local pos = part.Position
            return Vector3.new(pos.X, pos.Y - QUEST_CONFIG.UNDERGROUND_OFFSET, pos.Z)
        end
        
        return nil
    end
    
    local function getZombieUndergroundPosition(zombieModel)
        if not zombieModel or not zombieModel.Parent then return nil end
        
        local hrp = zombieModel:FindFirstChild("HumanoidRootPart")
        if hrp then
            local pos = hrp.Position
            return Vector3.new(pos.X, pos.Y - QUEST_CONFIG.ZOMBIE_UNDERGROUND_OFFSET, pos.Z)
        end
        
        return nil
    end
    
    ----------------------------------------------------------------
    -- HP CHECKER
    ----------------------------------------------------------------
    local function getRockHP(rock)
        if not rock or not rock.Parent then return 0 end
        
        local success, result = pcall(function()
            return rock:GetAttribute("Health") or 0
        end)
        
        return success and result or 0
    end
    
    local function isTargetValid(rock)
        if not rock or not rock.Parent then return false end
        if not rock:FindFirstChildWhichIsA("BasePart") then return false end
        
        local hp = getRockHP(rock)
        return hp > 0
    end
    
    local function getZombieHP(zombie)
        if not zombie or not zombie.Parent then return 0 end
        local humanoid = zombie:FindFirstChild("Humanoid")
        if humanoid then return humanoid.Health or 0 end
        return 0
    end
    
    local function isZombieValid(zombie)
        if not zombie or not zombie.Parent then return false end
        return getZombieHP(zombie) > 0
    end
    
    ----------------------------------------------------------------
    -- TARGET FINDER
    ----------------------------------------------------------------
    local function findNearestRock()
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return nil end
        
        local targetRock, minDist = nil, math.huge
        
        for _, folder in ipairs(MINING_FOLDER_PATH:GetChildren()) do
            if folder:IsA("Folder") or folder:IsA("Model") then
                for _, child in ipairs(folder:GetChildren()) do
                    if child:IsA("SpawnLocation") or child.Name == "SpawnLocation" then
                        local rock = child:FindFirstChild(QUEST_CONFIG.ROCK_NAME)
                        if isTargetValid(rock) then
                            local pos = getRockUndergroundPosition(rock)
                            if pos then
                                local dist = (pos - hrp.Position).Magnitude
                                if dist < minDist then
                                    minDist = dist
                                    targetRock = rock
                                end
                            end
                        end
                    end
                end
            end
        end
        
        return targetRock, minDist
    end
    
    local function findNearestZombie()
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return nil end
        
        local targetZombie, minDist = nil, math.huge
        
        for _, child in ipairs(LIVING_FOLDER:GetChildren()) do
            if string.match(child.Name, "^Zombie%d+") or string.match(child.Name, "^EliteZombie%d+") then
                if isZombieValid(child) then
                    local pos = getZombieUndergroundPosition(child)
                    if pos then
                        local dist = (pos - hrp.Position).Magnitude
                        if dist < minDist then
                            minDist = dist
                            targetZombie = child
                        end
                    end
                end
            end
        end
        
        return targetZombie, minDist
    end
    
    ----------------------------------------------------------------
    -- NOCLIP
    ----------------------------------------------------------------
    local function enableNoclip()
        if State.noclipConn then return end
        
        local char = player.Character
        if not char then return end
        
        State.noclipConn = RunService.Stepped:Connect(function()
            if not char or not char.Parent then
                if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
                return
            end
            
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end
    
    local function disableNoclip()
        if State.noclipConn then
            State.noclipConn:Disconnect()
            State.noclipConn = nil
        end
    end
    
    ----------------------------------------------------------------
    -- SMOOTH BODY VELOCITY MOVEMENT
    ----------------------------------------------------------------
    local function smoothMoveTo(targetPos, callback)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        enableNoclip()
        
        local bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Parent = hrp
        State.bodyVelocity = bv
        
        local bg = Instance.new("BodyGyro")
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.P = 10000
        bg.D = 500
        bg.Parent = hrp
        State.bodyGyro = bg
        
        print(string.format("   üöÄ Moving to (%.1f, %.1f, %.1f)...", targetPos.X, targetPos.Y, targetPos.Z))
        
        State.moveConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                if bv then bv:Destroy() end
                if bg then bg:Destroy() end
                State.bodyVelocity = nil
                State.bodyGyro = nil
                return
            end
            
            local currentPos = hrp.Position
            local direction = (targetPos - currentPos)
            local distance = direction.Magnitude
            
            if distance < 2 then
                print("   ‚úÖ Reached target!")
                
                bv.Velocity = Vector3.zero
                task.wait(0.1)
                
                bv:Destroy()
                bg:Destroy()
                State.bodyVelocity = nil
                State.bodyGyro = nil
                
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                
                if callback then callback() end
                return
            end
            
            local speed = math.min(QUEST_CONFIG.MOVE_SPEED, distance * 10)
            local velocity = direction.Unit * speed
            
            bv.Velocity = velocity
            bg.CFrame = CFrame.lookAt(currentPos, targetPos)
        end)
        
        return true
    end
    
    ----------------------------------------------------------------
    -- POSITION LOCK
    ----------------------------------------------------------------
    local function lockPositionLayingDown(targetPos)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        if State.positionLockConn then State.positionLockConn:Disconnect() State.positionLockConn = nil end
        
        local angle = math.rad(QUEST_CONFIG.LAYING_ANGLE)
        local baseCFrame = CFrame.new(targetPos)
        local layingCFrame = baseCFrame * CFrame.Angles(angle, 0, 0)
        
        State.positionLockConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.positionLockConn then State.positionLockConn:Disconnect() State.positionLockConn = nil end
                return
            end
            
            hrp.CFrame = layingCFrame
            hrp.Velocity = Vector3.zero
            hrp.AssemblyLinearVelocity = Vector3.zero
        end)
        
        print("   üõèÔ∏è Position locked (laying down)")
    end
    
    local function lockPositionFollowTarget(targetModel)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp or not targetModel then return end
        
        if State.positionLockConn then State.positionLockConn:Disconnect() State.positionLockConn = nil end
        
        local angle = math.rad(QUEST_CONFIG.LAYING_ANGLE)
        
        State.positionLockConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.positionLockConn then State.positionLockConn:Disconnect() State.positionLockConn = nil end
                return
            end
            
            if not targetModel or not targetModel.Parent then
                if State.positionLockConn then State.positionLockConn:Disconnect() State.positionLockConn = nil end
                return
            end
            
            local targetPos = getZombieUndergroundPosition(targetModel)
            if targetPos then
                local baseCFrame = CFrame.new(targetPos)
                local layingCFrame = baseCFrame * CFrame.Angles(angle, 0, 0)
                
                hrp.CFrame = layingCFrame
                hrp.Velocity = Vector3.zero
                hrp.AssemblyLinearVelocity = Vector3.zero
            end
        end)
        
        print("   üéØ Position locked (following target)")
    end
    
    local function unlockPosition()
        SoftUnlockPosition()
    end
    
    ----------------------------------------------------------------
    -- WATCH HP
    ----------------------------------------------------------------
    local function watchRockHP(rock)
        if State.hpWatchConn then State.hpWatchConn:Disconnect() end
        if not rock then return end
        
        State.hpWatchConn = rock:GetAttributeChangedSignal("Health"):Connect(function()
            local hp = rock:GetAttribute("Health") or 0
            print(string.format("   ‚ö° [HP Changed!] New HP: %d", hp))
            
            if hp <= 0 then
                print("   üí• HP = 0 detected! Switching target...")
                State.targetDestroyed = true
                if ToolController then ToolController.holdingM1 = false end
                unlockPosition()
            end
        end)
    end
    
    local function watchZombieHP(zombie)
        if State.hpWatchConn then State.hpWatchConn:Disconnect() end
        if not zombie then return end
        
        local humanoid = zombie:FindFirstChild("Humanoid")
        if not humanoid then return end
        
        State.hpWatchConn = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
            local hp = humanoid.Health or 0
            print(string.format("   ‚ö° [HP Changed!] New HP: %.1f", hp))
            
            if hp <= 0 then
                print("   üíÄ Zombie died! Switching target...")
                State.targetDestroyed = true
                if ToolController then ToolController.holdingM1 = false end
                unlockPosition()
            end
        end)
    end
    
    ----------------------------------------------------------------
    -- WEAPON MANAGEMENT
    ----------------------------------------------------------------
    local function getBestWeapon()
        if not PlayerController or not PlayerController.Replica then return nil end
        
        local replica = PlayerController.Replica
        if not replica.Data or not replica.Data.Inventory or not replica.Data.Inventory.Equipments then
            return nil
        end
        
        local equipments = replica.Data.Inventory.Equipments
        local bestWeapon = nil
        local highestDmg = 0
        
        for id, item in pairs(equipments) do
            if type(item) == "table" and item.Type then
                if not string.find(item.Type, "Pickaxe") then
                    local dmg = item.Dmg or 0
                    if dmg > highestDmg then
                        highestDmg = dmg
                        bestWeapon = item
                    end
                end
            end
        end
        
        return bestWeapon
    end
    
    ----------------------------------------------------------------
    -- ACTIONS
    ----------------------------------------------------------------
    local function doPurchaseBronzePickaxe()
        print("üõí Objective: Purchasing Bronze Pickaxe...")
        
        if not PURCHASE_RF then
            warn("   ‚ùå Purchase Remote not available!")
            return false
        end
        
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        
        if hrp then
            local npcPos = QUEST_CONFIG.NPC_POSITION
            local currentDist = (npcPos - hrp.Position).Magnitude
            
            print(string.format("   üö∂ Moving to NPC at (%.2f, %.2f, %.2f) (%.1f studs away)...", 
                npcPos.X, npcPos.Y, npcPos.Z, currentDist))
            
            local moveComplete = false
            smoothMoveTo(npcPos, function()
                moveComplete = true
            end)
            
            local timeout = 15
            local startTime = tick()
            while not moveComplete and tick() - startTime < timeout do
                task.wait(0.1)
            end
            
            if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
            if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
            if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
            
            print("   ‚úÖ Reached NPC!")
            print("   ‚è∏Ô∏è  Waiting 1.5s before purchase...")
            task.wait(1.5)
        end
        
        print(string.format("   üí∞ Purchasing: %s (Amount: %d)", QUEST_CONFIG.PICKAXE_NAME, QUEST_CONFIG.PICKAXE_AMOUNT))
        
        local args = {
            QUEST_CONFIG.PICKAXE_NAME,
            QUEST_CONFIG.PICKAXE_AMOUNT
        }
        
        local success, result = pcall(function()
            return PURCHASE_RF:InvokeServer(unpack(args))
        end)
        
        if success then
            print("   ‚úÖ Purchase successful!")
            return true
        else
            warn("   ‚ùå Purchase failed: " .. tostring(result))
            return false
        end
    end
    
    local function doMineRocks()
        print("‚õèÔ∏è Objective: Mining Rocks...")
        
        IsMiningActive = true
        
        print("\n" .. string.rep("-", 30))
        print("‚õèÔ∏è Starting underground mining loop...")
        print(string.rep("-", 30))
        
        while isQuest5StillActive() and not isCurrentObjectiveComplete() do
            local char = player.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            
            if not hrp then
                warn("   ‚ö†Ô∏è Waiting for character...")
                task.wait(2)
                continue
            end
            
            cleanupState()
            
            local targetRock, dist = findNearestRock()
            
            if not targetRock then
                warn("   ‚ùå No Rocks found, waiting...")
                task.wait(2)
                continue
            end
            
            State.currentTarget = targetRock
            State.targetDestroyed = false
            
            local targetPos = getRockUndergroundPosition(targetRock)
            if not targetPos then
                warn("   ‚ùå Cannot get rock position!")
                task.wait(1)
                continue
            end
            
            local currentHP = getRockHP(targetRock)
            print(string.format("   üéØ Target: %s (dist: %d, HP: %d)", 
                targetRock.Parent.Name, math.floor(dist), currentHP))
            
            watchRockHP(targetRock)
            
            local moveStarted = false
            smoothMoveTo(targetPos, function()
                lockPositionLayingDown(targetPos)
                moveStarted = true
            end)
            
            local timeout = 15
            local startTime = tick()
            while not moveStarted and tick() - startTime < timeout do
                task.wait(0.1)
            end
            
            if not moveStarted then
                lockPositionLayingDown(targetPos)
            end
            
            task.wait(0.5)
            
            while not State.targetDestroyed and isQuest5StillActive() and not isCurrentObjectiveComplete() do
                if not char or not char.Parent then
                    print("   üíÄ Character died!")
                    break
                end
                
                if not targetRock or not targetRock.Parent then
                    print("   üí• Target removed!")
                    State.targetDestroyed = true
                    break
                end
                
                if checkMiningError() then
                    print("   ‚ö†Ô∏è Someone else mining!")
                    State.targetDestroyed = true
                    if ToolController then ToolController.holdingM1 = false end
                    break
                end
                
                local toolInHand = char:FindFirstChildWhichIsA("Tool")
                local isPickaxeHeld = toolInHand and string.find(toolInHand.Name, "Pickaxe")
                
                if not isPickaxeHeld then
                    if ToolController then ToolController.holdingM1 = false end
                    local key = findPickaxeSlotKey()
                    if key then 
                        pressKey(key) 
                        task.wait(0.3)
                    else 
                        pcall(function() CHAR_RF:InvokeServer({Runes = {}, Name = QUEST_CONFIG.PICKAXE_NAME}) end)
                        task.wait(0.5) 
                    end
                else
                    if ToolController and ToolActivatedFunc then
                        ToolController.holdingM1 = true
                        pcall(function() ToolActivatedFunc(ToolController, toolInHand) end)
                    else
                        pcall(function() TOOL_RF_BACKUP:InvokeServer(toolInHand.Name, true) end)
                    end
                end
                
                task.wait(0.15)
            end
            
            unlockPosition()
            
            if isCurrentObjectiveComplete() then
                print("‚úÖ Objective (Mine Rocks) Complete!")
                break
            end
            
            print("   üîÑ Finding next target...")
            task.wait(0.5)
        end
        
        print("\nüõë Mining ended")
        IsMiningActive = false
        unlockPosition()
        disableNoclip()
        cleanupState()
    end
    
    local function doKillZombies()
        print("‚öîÔ∏è Objective: Killing Zombies (Dynamic Tracking)...")
        
        IsKillingActive = true
        
        print("\n" .. string.rep("-", 30))
        print("‚öîÔ∏è Starting zombie hunting with dynamic tracking...")
        print(string.rep("-", 30))
        
        while isQuest5StillActive() and not isCurrentObjectiveComplete() do
            local char = player.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            
            if not hrp then
                warn("   ‚ö†Ô∏è Waiting for character...")
                task.wait(2)
                continue
            end
            
            cleanupState()
            
            local targetZombie, dist = findNearestZombie()
            
            if not targetZombie then
                warn("   ‚ùå No Zombies found, waiting...")
                task.wait(2)
                continue
            end
            
            State.currentTarget = targetZombie
            State.targetDestroyed = false
            
            local targetPos = getZombieUndergroundPosition(targetZombie)
            if not targetPos then
                warn("   ‚ùå Cannot get zombie position!")
                task.wait(1)
                continue
            end
            
            local currentHP = getZombieHP(targetZombie)
            print(string.format("   üéØ Target: %s (dist: %d, HP: %.1f)", 
                targetZombie.Name, math.floor(dist), currentHP))
            
            watchZombieHP(targetZombie)
            
            local moveStarted = false
            smoothMoveTo(targetPos, function()
                lockPositionFollowTarget(targetZombie)
                moveStarted = true
            end)
            
            local timeout = 15
            local startTime = tick()
            while not moveStarted and tick() - startTime < timeout do
                task.wait(0.1)
            end
            
            if not moveStarted then
                lockPositionFollowTarget(targetZombie)
            end
            
            task.wait(0.5)
            
            while not State.targetDestroyed and isQuest5StillActive() and not isCurrentObjectiveComplete() do
                if not char or not char.Parent then
                    print("   üíÄ Character died!")
                    break
                end
                
                if not targetZombie or not targetZombie.Parent or not isZombieValid(targetZombie) then
                    print("   üíÄ Zombie died or removed!")
                    State.targetDestroyed = true
                    unlockPosition() 
                    break
                end
                
                local currentZombiePos = getZombieUndergroundPosition(targetZombie)
                if currentZombiePos and hrp then
                    local distToZombie = (currentZombiePos - hrp.Position).Magnitude
                    if distToZombie > QUEST_CONFIG.ZOMBIE_MAX_DISTANCE then
                        print(string.format("   ‚ö†Ô∏è Zombie moved too far! (%.1f studs) Switching target...", distToZombie))
                        State.targetDestroyed = true
                        unlockPosition()
                        break
                    end
                end
                
                local toolInHand = char:FindFirstChildWhichIsA("Tool")
                local isWeaponHeld = toolInHand and not string.find(toolInHand.Name, "Pickaxe")
                
                if not isWeaponHeld then
                    if ToolController then ToolController.holdingM1 = false end
                    
                    local bestWeapon = getBestWeapon()
                    if bestWeapon then
                        print(string.format("   üó°Ô∏è Equipping weapon: %s", bestWeapon.Type))
                        pcall(function() 
                            CharacterService:EquipItem(bestWeapon)
                        end)
                        task.wait(0.5)
                    else
                        local key, weaponName = findWeaponSlotKey()
                        if key then
                            print(string.format("   üó°Ô∏è Equipping via hotkey: %s", weaponName))
                            pressKey(key)
                            task.wait(0.3)
                        else
                            warn("   ‚ö†Ô∏è No weapon found!")
                            task.wait(1)
                        end
                    end
                else
                    if ToolController and ToolActivatedFunc then
                        ToolController.holdingM1 = true
                        pcall(function() ToolActivatedFunc(ToolController, toolInHand) end)
                    else
                        pcall(function() TOOL_RF_BACKUP:InvokeServer(toolInHand.Name, true) end)
                    end
                end
                
                task.wait(0.15)
            end
            
            unlockPosition()
            
            if isCurrentObjectiveComplete() then
                print("‚úÖ Objective (Kill Zombies) Complete!")
                break
            end
            
            print("   üîÑ Finding next target...")
            task.wait(0.5)
        end
        
        print("\nüõë Zombie hunting ended")
        IsKillingActive = false
        unlockPosition()
        disableNoclip()
        cleanupState()
    end
    
    ----------------------------------------------------------------
    -- üî• SMART QUEST RUNNER (Priority-based + Flexible)
    ----------------------------------------------------------------
    local function RunQuest5_Smart()
        print(string.rep("=", 50))
        print("üöÄ QUEST 5: " .. QUEST_CONFIG.QUEST_NAME)
        print("üéØ SMART SYSTEM: Priority-based + Flexible")
        print("üìã Priority Order: Purchase ‚Üí Kill ‚Üí Mine")
        print(string.rep("=", 50))
        
        setupRespawnHandler()
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        
        if not questID then
            warn("‚ùå Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' not found!")
            Quest5Active = false
            return
        end
        
        print("‚úÖ Quest found (ID: " .. questID .. ")")
        
        -- Collect all objectives
        local objectives = {}
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                local text = getObjectiveText(item)
                local objType = getObjectiveType(text)
                
                table.insert(objectives, {
                    order = tonumber(item.Name),
                    frame = item,
                    text = text,
                    type = objType
                })
            end
        end
        
        -- üî• Sort by priority instead of original order
        table.sort(objectives, function(a, b)
            local function getPriority(type)
                for i, priorityType in ipairs(QUEST_CONFIG.PRIORITY_ORDER) do
                    if string.find(type, priorityType) then
                        return i
                    end
                end
                return 999
            end
            return getPriority(a.type) < getPriority(b.type)
        end)
        
        print("\n" .. string.rep("=", 50))
        print("‚öôÔ∏è  Quest Objectives (Priority Order):")
        for i, obj in ipairs(objectives) do
            local complete = isObjectiveComplete(obj.frame)
            print(string.format("   %d. [%s] %s [%s]", i, obj.type, obj.text, complete and "‚úÖ" or "‚è≥"))
        end
        print(string.rep("=", 50))
        
        -- üî• Main loop: Process objectives by priority
        local maxAttempts = 10
        local attempt = 0
        
        while isQuest5StillActive() and attempt < maxAttempts do
            attempt = attempt + 1
            print(string.format("\nüîÑ Quest Cycle #%d", attempt))
            
            local allComplete = true
            local didSomething = false
            
            for _, obj in ipairs(objectives) do
                if not isQuest5StillActive() then
                    print("üõë Quest disappeared!")
                    break
                end
                
                local complete = isObjectiveComplete(obj.frame)
                
                if not complete then
                    allComplete = false
                    
                    -- üî• Check if we can do this objective now
                    if not canDoObjective(obj.type) then
                        print(string.format("   ‚è≠Ô∏è  Skipping [%s] - Cannot do right now", obj.type))
                        continue
                    end
                    
                    State.currentObjectiveFrame = obj.frame
                    
                    print(string.format("\nüìã Processing [%s]: %s", obj.type, obj.text))
                    
                    -- Execute objective
                    if obj.type == "Purchase" then
                        doPurchaseBronzePickaxe()
                        didSomething = true
                        task.wait(2)
                        
                    elseif obj.type == "Kill" then
                        doKillZombies()
                        didSomething = true
                        task.wait(1)
                        
                    elseif obj.type == "Mine" then
                        doMineRocks()
                        didSomething = true
                        task.wait(1)
                        
                    else
                        warn("   ‚ö†Ô∏è Unknown objective type: " .. obj.type)
                    end
                    
                    -- Check if complete
                    task.wait(1)
                    if isObjectiveComplete(obj.frame) then
                        print(string.format("‚úÖ [%s] Complete!", obj.type))
                    else
                        print(string.format("‚è≥ [%s] Still in progress", obj.type))
                    end
                end
            end
            
            if allComplete then
                print("\nüéâ All objectives complete!")
                break
            end
            
            if not didSomething then
                warn("\n‚ö†Ô∏è No objectives could be completed this cycle!")
                print("   Waiting 3s before retry...")
                task.wait(3)
            end
        end
        
        -- Final check
        task.wait(2)
        
        local allComplete = true
        for _, obj in ipairs(objectives) do
            if not isObjectiveComplete(obj.frame) then
                allComplete = false
                warn(string.format("   ‚ö†Ô∏è [%s] incomplete: %s", obj.type, obj.text))
            end
        end
        
        if allComplete then
            print("\n" .. string.rep("=", 50))
            print("‚úÖ Quest 5 Complete!")
            print(string.rep("=", 50))
        else
            warn("\n" .. string.rep("=", 50))
            warn("‚ö†Ô∏è Quest 5 incomplete after " .. attempt .. " cycles")
            warn(string.rep("=", 50))
        end
        
        Quest5Active = false
        IsMiningActive = false
        IsKillingActive = false
        unlockPosition()
        disableNoclip()
        cleanupState()
    end
    
    ----------------------------------------------------------------
    -- START
    ----------------------------------------------------------------
    RunQuest5_Smart()
end

----------------------------------------------------------------
-- QUEST 6 ORIGINAL (from 6.lua)
----------------------------------------------------------------
local function RunQuest06()
    -- QUEST 6 ONLY: "Preparing For Battle!" (FIXED: smoothMoveTo + Lock Position)
    
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Workspace = game:GetService("Workspace")
    
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    ----------------------------------------------------------------
    -- CONFIG
    ----------------------------------------------------------------
    local Quest6Active = true
    
    local FORGE_CONFIG = {
        REQUIRED_ORE_COUNT = 3,
        ITEM_TYPE = "Armor",
        FORGE_DELAY = 2,
        FORGE_POSITION = Vector3.new(-192.3, 29.5, 168.1),  -- üÜï Fixed position
        MOVE_SPEED = 20,
    }
    
    ----------------------------------------------------------------
    -- SERVICES & REMOTES
    ----------------------------------------------------------------
    local SERVICES = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")
    local PROXIMITY_RF = SERVICES:WaitForChild("ProximityService"):WaitForChild("RF"):WaitForChild("Forge")
    
    local FORGE_OBJECT = Workspace:WaitForChild("Proximity"):WaitForChild("Forge")
    
    ----------------------------------------------------------------
    -- KNIT SETUP
    ----------------------------------------------------------------
    local KnitPackage = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit")
    local Knit = require(KnitPackage)
    
    if not Knit.OnStart then 
        pcall(function() Knit.Start():await() end)
    end
    
    local ForgeController = nil
    local ForgeService = nil
    local PlayerController = nil
    local UIController = nil
    
    pcall(function()
        ForgeController = Knit.GetController("ForgeController")
        ForgeService = Knit.GetService("ForgeService")
        PlayerController = Knit.GetController("PlayerController")
    end)
    
    -- Hook UIController from getgc
    pcall(function()
        for _, v in pairs(getgc(true)) do
            if type(v) == "table" then
                if rawget(v, "Open") and rawget(v, "Close") and rawget(v, "Modules") then
                    UIController = v
                    break
                end
            end
        end
    end)
    
    if ForgeService then print("‚úÖ ForgeService Ready!") else warn("‚ö†Ô∏è ForgeService not found") end
    if PlayerController then print("‚úÖ PlayerController Ready!") else warn("‚ö†Ô∏è PlayerController not found") end
    if UIController then print("‚úÖ UIController Ready!") else warn("‚ö†Ô∏è UIController not found") end
    
    ----------------------------------------------------------------
    -- STATE
    ----------------------------------------------------------------
    local State = {
        moveConn = nil,
        noclipConn = nil,
        bodyVelocity = nil,
        bodyGyro = nil,
    }
    
    local function cleanupState()
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
    end
    
    ----------------------------------------------------------------
    -- NOCLIP & MOVEMENT
    ----------------------------------------------------------------
    local function enableNoclip()
        if State.noclipConn then return end
        
        local char = player.Character
        if not char then return end
        
        State.noclipConn = RunService.Stepped:Connect(function()
            if not char or not char.Parent then
                if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
                return
            end
            
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end
    
    local function disableNoclip()
        if State.noclipConn then
            State.noclipConn:Disconnect()
            State.noclipConn = nil
        end
    end
    
    -- üÜï smoothMoveTo with BodyVelocity + BodyGyro
    local function smoothMoveTo(targetPos, callback)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        -- Cleanup previous movement
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        -- Enable noclip
        enableNoclip()
        
        -- Create BodyVelocity
        local bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Parent = hrp
        State.bodyVelocity = bv
        
        -- Create BodyGyro
        local bg = Instance.new("BodyGyro")
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.P = 10000
        bg.D = 500
        bg.Parent = hrp
        State.bodyGyro = bg
        
        print(string.format("   üöÄ Moving to (%.1f, %.1f, %.1f)...", targetPos.X, targetPos.Y, targetPos.Z))
        
        State.moveConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                if bv then bv:Destroy() end
                if bg then bg:Destroy() end
                State.bodyVelocity = nil
                State.bodyGyro = nil
                return
            end
            
            local currentPos = hrp.Position
            local direction = (targetPos - currentPos)
            local distance = direction.Magnitude
            
            if distance < 2 then
                print("   ‚úÖ Reached target!")
                
                bv.Velocity = Vector3.zero
                task.wait(0.1)
                
                bv:Destroy()
                bg:Destroy()
                State.bodyVelocity = nil
                State.bodyGyro = nil
                
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                
                if callback then callback() end
                return
            end
            
            local speed = math.min(FORGE_CONFIG.MOVE_SPEED, distance * 10)
            local velocity = direction.Unit * speed
            
            bv.Velocity = velocity
            bg.CFrame = CFrame.lookAt(currentPos, targetPos)
        end)
        
        return true
    end
    
    ----------------------------------------------------------------
    -- UI MANAGEMENT
    ----------------------------------------------------------------
    local function closeForgeUI()
        print("\n   üö™ Closing Forge UI...")
        
        local closed = false
        
        -- Method 1: UIController.Close
        if UIController and UIController.Close then
            pcall(function()
                if UIController.Modules and UIController.Modules["Forge"] then
                    UIController:Close("Forge")
                    print("      ‚úÖ Closed via UIController")
                    closed = true
                end
            end)
        end
        
        -- Method 2: ForgeController
        if not closed and ForgeController then
            pcall(function()
                if ForgeController.Close then
                    ForgeController:Close()
                    print("      ‚úÖ Closed via ForgeController")
                    closed = true
                elseif ForgeController.CloseForge then
                    ForgeController:CloseForge()
                    print("      ‚úÖ Closed via ForgeController.CloseForge")
                    closed = true
                end
            end)
        end
        
        -- Method 3: PlayerGui (direct UI close)
        if not closed then
            pcall(function()
                local forgeGui = playerGui:FindFirstChild("Forge") or playerGui:FindFirstChild("ForgeUI")
                if forgeGui then
                    forgeGui.Enabled = false
                    print("      ‚úÖ Closed via PlayerGui")
                    closed = true
                end
            end)
        end
        
        if not closed then
            warn("      ‚ö†Ô∏è Could not close Forge UI (may already be closed)")
        end
        
        task.wait(0.5)
    end
    
    ----------------------------------------------------------------
    -- QUEST SYSTEM
    ----------------------------------------------------------------
    local function getQuestObjectives(questName)
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil, nil end
        
        local list = gui:FindFirstChild("Main") and gui.Main:FindFirstChild("Screen") 
                     and gui.Main.Screen:FindFirstChild("Quests") and gui.Main.Screen.Quests:FindFirstChild("List")
        if not list then return nil, nil end
        
        local questID = nil
        for _, child in ipairs(list:GetChildren()) do
            local id = string.match(child.Name, "^Introduction(%d+)Title$")
            if id and child:FindFirstChild("Frame") and child.Frame:FindFirstChild("TextLabel") then
                if child.Frame.TextLabel.Text == questName then
                    questID = id
                    break
                end
            end
        end
        
        if not questID then return nil, nil end
        
        local objList = list:FindFirstChild("Introduction" .. questID .. "List")
        return questID, objList
    end
    
    local function isQuestComplete(questName)
        local questID, objList = getQuestObjectives(questName)
        
        if not questID or not objList then
            return true
        end
        
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                local check = item:FindFirstChild("Main") and item.Main:FindFirstChild("Frame") and item.Main.Frame:FindFirstChild("Check")
                if check and not check.Visible then
                    return false
                end
            end
        end
        
        return true
    end
    
    local function isQuest6StillActive()
        if not Quest6Active then return false end
        
        if isQuestComplete("Preparing For Battle") then  -- ‚úÖ ‡πÅ‡∏Å‡πâ‡πÅ‡∏•‡πâ‡∏ß
            print("üõë Quest 'Preparing For Battle' completed!")  -- ‚úÖ ‡πÅ‡∏Å‡πâ‡πÅ‡∏•‡πâ‡∏ß
            Quest6Active = false
            return false
        end
        
        local questID, objList = getQuestObjectives("Preparing For Battle")  -- ‚úÖ ‡πÅ‡∏Å‡πâ‡πÅ‡∏•‡πâ‡∏ß
        if not questID or not objList then
            print("üõë Quest 'Preparing For Battle' not found!")  -- ‚úÖ ‡πÅ‡∏Å‡πâ‡πÅ‡∏•‡πâ‡∏ß
            Quest6Active = false
            return false
        end
        
        return true
    end
    
    ----------------------------------------------------------------
    -- INVENTORY SYSTEM
    ----------------------------------------------------------------
    local function getPlayerInventory()
        local inventory = {}
        
        if not PlayerController then
            warn("   ‚ö†Ô∏è PlayerController not available!")
            return inventory
        end
        
        if not PlayerController.Replica then
            print("   ‚è≥ Waiting for Replica...")
            task.wait(2)
        end
        
        if not PlayerController.Replica then
            warn("   ‚ùå Replica still not available!")
            return inventory
        end
        
        local replica = PlayerController.Replica
        
        if replica and replica.Data and replica.Data.Inventory then
            print("   ‚úÖ Reading from Replica.Data.Inventory")
            
            for itemName, amount in pairs(replica.Data.Inventory) do
                if type(amount) == "number" and amount > 0 then
                    inventory[itemName] = amount
                end
            end
        else
            warn("   ‚ùå Replica.Data.Inventory not found!")
            
            if replica and replica.Data then
                print("   üîç Available keys in Replica.Data:")
                for k, v in pairs(replica.Data) do
                    print("      ‚Ä¢ " .. tostring(k) .. " = " .. tostring(type(v)))
                end
            end
        end
        
        return inventory
    end
    
    local function getAvailableOres()
        local inventory = getPlayerInventory()
        local ores = {}
        
        local oreTypes = {"Copper","Stone", "Iron","Sand Stone", "Tin", "Cardboardite", "Silver", "Gold", "Bananite", "Mushroomite", "Platinum","Aite"}
        
        for _, oreName in ipairs(oreTypes) do
            if inventory[oreName] and inventory[oreName] > 0 then
                table.insert(ores, {Name = oreName, Amount = inventory[oreName]})
            end
        end
        
        if #ores == 0 then
            print("   üîç Scanning all items for ores...")
            for itemName, amount in pairs(inventory) do
                if string.find(itemName, "Ore") or string.find(itemName, "ore") then
                    table.insert(ores, {Name = itemName, Amount = amount})
                end
            end
        end
        
        return ores
    end
    
    local function selectRandomOres(count)
        local availableOres = getAvailableOres()
        
        if #availableOres == 0 then
            return nil, "No ores found in inventory!"
        end
        
        local totalOres = 0
        for _, ore in ipairs(availableOres) do
            totalOres = totalOres + ore.Amount
        end
        
        if totalOres < count then
            return nil, string.format("Not enough ores! Need %d, have %d", count, totalOres)
        end
        
        local orePool = {}
        for _, ore in ipairs(availableOres) do
            for i = 1, ore.Amount do
                table.insert(orePool, ore.Name)
            end
        end
        
        local selected = {}
        for i = 1, count do
            if #orePool == 0 then break end
            
            local randomIndex = math.random(1, #orePool)
            local oreName = table.remove(orePool, randomIndex)
            
            selected[oreName] = (selected[oreName] or 0) + 1
        end
        
        return selected, nil
    end
    
    local function printInventorySummary()
        print("\n   üì¶ === INVENTORY CHECK ===")
        
        local ores = getAvailableOres()
        
        if #ores == 0 then
            warn("   ‚ùå No ores found in inventory!")
            
            local inv = getPlayerInventory()
            if next(inv) then
                print("   üìã All items in inventory:")
                for item, amount in pairs(inv) do
                    print(string.format("      ‚Ä¢ %s: %d", item, amount))
                end
            else
                warn("   ‚ö†Ô∏è Inventory is completely empty!")
            end
            return
        end
        
        print("   ‚úÖ Available Ores:")
        local total = 0
        for _, ore in ipairs(ores) do
            print(string.format("      ‚Ä¢ %s: %d", ore.Name, ore.Amount))
            total = total + ore.Amount
        end
        print(string.format("      üìä Total: %d ores", total))
        print("   " .. string.rep("=", 28) .. "\n")
    end
    
    ----------------------------------------------------------------
    -- FORGE SYSTEM
    ----------------------------------------------------------------
    getgenv().ForgeHookActive = getgenv().ForgeHookActive or false
    
    local function setupForgeHook()
        if getgenv().ForgeHookActive then
            print("   ‚ö†Ô∏è Forge Hook already active")
            return
        end
        
        if not ForgeService then
            warn("   ‚ùå ForgeService not available!")
            return
        end
        
        print("   ü™ù Installing Forge Hook...")
        local originalChangeSequence = ForgeService.ChangeSequence
        
        ForgeService.ChangeSequence = function(self, sequenceName, args)
            print("      üîÑ Sequence: " .. sequenceName)
            
            local success, result = pcall(originalChangeSequence, self, sequenceName, args)
            
            task.spawn(function()
                if sequenceName == "Melt" then
                    print("      ‚è© Auto: Pouring in 8s...")
                    task.wait(8)
                    self:ChangeSequence("Pour", {ClientTime = 8.5, InContact = true})
                    
                elseif sequenceName == "Pour" then
                    print("      ‚è© Auto: Hammering in 5s...")
                    task.wait(5)
                    self:ChangeSequence("Hammer", {ClientTime = 5.2})
                    
                elseif sequenceName == "Hammer" then
                    print("      ‚è© Auto: Watering in 6s...")
                    task.wait(6)
                    self:ChangeSequence("Water", {ClientTime = 6.5})
                    
                elseif sequenceName == "Water" then
                    print("      ‚è© Auto: Showcasing in 3s...")
                    task.wait(3)
                    self:ChangeSequence("Showcase", {})
                    
                elseif sequenceName == "Showcase" then
                    print("      ‚úÖ Forge completed!")
                end
            end)
            
            return success, result
        end
        
        getgenv().ForgeHookActive = true
        print("   ‚úÖ Forge Hook installed!")
    end
    
    -- üÜï IMPROVED: Use smoothMoveTo with fixed position
    local function moveToForge()
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        local forgePos = FORGE_CONFIG.FORGE_POSITION
        local currentDist = (forgePos - hrp.Position).Magnitude
        
        print(string.format("   üö∂ Moving to Forge at (%.1f, %.1f, %.1f) (%.1f studs away)...", 
            forgePos.X, forgePos.Y, forgePos.Z, currentDist))
        
        -- Use smoothMoveTo with noclip + lock position
        local moveComplete = false
        smoothMoveTo(forgePos, function()
            moveComplete = true
        end)
        
        -- Wait for movement to complete
        local timeout = 15
        local startTime = tick()
        while not moveComplete and tick() - startTime < timeout do
            task.wait(0.1)
        end
        
        -- Cleanup movement
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        print("   ‚úÖ Reached Forge!")
        
        -- Wait 1.5 seconds before opening UI
        print("   ‚è∏Ô∏è  Waiting 1.5s before opening Forge UI...")
        task.wait(1.5)
        
        return true
    end
    
    local function startForge(oreSelection)
        print("   üî• Starting Forge with:")
        for oreName, amount in pairs(oreSelection) do
            print(string.format("      ‚Ä¢ %s x%d", oreName, amount))
        end
        
        local success = pcall(function()
            PROXIMITY_RF:InvokeServer(FORGE_OBJECT)
        end)
        
        if not success then
            warn("   ‚ùå Failed to invoke Forge remote")
            return false
        end
        
        task.wait(1)
        
        if not ForgeService then
            warn("   ‚ùå ForgeService not available!")
            return false
        end
        
        local forgeSuccess = pcall(function()
            ForgeService:ChangeSequence("Melt", {
                Ores = oreSelection,
                ItemType = FORGE_CONFIG.ITEM_TYPE,
                FastForge = false
            })
        end)
        
        if forgeSuccess then
            print("   ‚úÖ Forge Melt started!")
            return true
        else
            warn("   ‚ö†Ô∏è Could not start forge melt")
            return false
        end
    end
    
    local function doForgeLoop()
        print("üî• Action: Auto Forging...")
        
        setupForgeHook()
        
        moveToForge()
        
        local forgeCount = 0
        local consecutiveFailures = 0
        
        while isQuest6StillActive() do
            forgeCount = forgeCount + 1
            print(string.format("\n   üî® Forge Attempt #%d", forgeCount))
            
            printInventorySummary()
            
            local oreSelection, errorMsg = selectRandomOres(FORGE_CONFIG.REQUIRED_ORE_COUNT)
            
            if not oreSelection then
                warn(string.format("\n‚ùå ERROR: %s", errorMsg))
                consecutiveFailures = consecutiveFailures + 1
                
                if consecutiveFailures >= 3 then
                    warn("‚ùå Failed 3 times in a row. Cannot continue forging!")
                    warn("üí° Please mine more ores and try again.")
                    Quest6Active = false
                    break
                end
                
                warn(string.format("‚è≥ Waiting 5s before retry... (%d/3 failures)", consecutiveFailures))
                task.wait(5)
                continue
            end
            
            consecutiveFailures = 0
            
            local success = startForge(oreSelection)
            
            if success then
                print("   ‚è≥ Waiting for forge to complete...")
                task.wait(25)
            else
                warn("   ‚ö†Ô∏è Forge failed, retrying in 3s...")
                task.wait(3)
            end
            
            if not isQuest6StillActive() then
                print("   ‚úÖ Quest complete!")
                break
            end
            
            print(string.format("   ‚è∏Ô∏è Cooling down for %ds...", FORGE_CONFIG.FORGE_DELAY))
            task.wait(FORGE_CONFIG.FORGE_DELAY)
        end
        
        print("\nüõë Quest 6 forging ended")
    end
    
    ----------------------------------------------------------------
    -- MAIN RUNNER
    ----------------------------------------------------------------
    local function Run_Quest6()
        print(string.rep("=", 50))
        print("üöÄ QUEST 6: Preparing For Battle")  -- ‚úÖ ‡πÄ‡∏≠‡∏≤ ! ‡∏≠‡∏≠‡∏Å
        print(string.rep("=", 50))
        
        local questID, objList = getQuestObjectives("Preparing For Battle")  -- ‚úÖ ‡πÅ‡∏Å‡πâ‡πÅ‡∏•‡πâ‡∏ß
        
        if not questID then
            warn("‚ùå Quest 'Preparing For Battle' not found!")  -- ‚úÖ ‡πÅ‡∏Å‡πâ‡πÅ‡∏•‡πâ‡∏ß
    
            warn("üí° Make sure the quest is active in your quest log.")
            Quest6Active = false
            return
        end
        
        print("‚úÖ Quest found (ID: " .. questID .. ")")
        
        print("\n" .. string.rep("=", 50))
        print("üî• Starting Forge Sequence...")
        print(string.rep("=", 50))
        
        doForgeLoop()
        
        closeForgeUI()
        
        if Quest6Active == false and not isQuestComplete("Preparing For Battle!") then
            warn("\n" .. string.rep("=", 50))
            warn("‚ùå Quest 6 Failed!")
            warn("Reason: Not enough ores to continue")
            warn(string.rep("=", 50))
        else
            print("\n" .. string.rep("=", 50))
            print("‚úÖ Quest 6 Complete!")
            print(string.rep("=", 50))
        end
        
        Quest6Active = false
        disableNoclip()
        cleanupState()
    end
    
    ----------------------------------------------------------------
    -- START
    ----------------------------------------------------------------
    Run_Quest6()
end

----------------------------------------------------------------
-- QUEST 7 ORIGINAL (from 7.lua)
----------------------------------------------------------------
local function RunQuest07()
    -- QUEST 7: "Forging Under Pressure!" - SMART SYSTEM (FIXED VERSION)
    -- ‚úÖ Priority: Purchase ‚Üí Kill ‚Üí Mine ‚Üí Forge
    -- ‚úÖ Sell System: ‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≤‡∏Å UI (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Pickaxe Name + Weapon/Armor GUID)
    -- ‚úÖ ‡∏Ç‡∏≤‡∏¢‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ Equipped (‡∏£‡∏ß‡∏° Pickaxe ‡∏î‡πâ‡∏ß‡∏¢)
    -- ‚úÖ FIXED: ‡∏õ‡∏¥‡∏î Forge UI ‡∏´‡∏•‡∏±‡∏á Forge ‡πÄ‡∏™‡∏£‡πá‡∏à (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô Quest 3)
    
    
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local Workspace = game:GetService("Workspace")
    
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    ----------------------------------------------------------------
    -- CONFIG
    ----------------------------------------------------------------
    local Quest7Active = true
    local IsMiningActive = false
    local IsKillingActive = false
    local IsForgingActive = false
    
    local QUEST_CONFIG = {
        QUEST_NAME = "Forging Under Pressure",
        PICKAXE_NAME = "Iron Pickaxe",
        PICKAXE_AMOUNT = 1,
        NPC_POSITION = Vector3.new(-81.03, 28.51, 84.68),
        ZOMBIE_UNDERGROUND_OFFSET = 6,
        ZOMBIE_MAX_DISTANCE = 50,
        REQUIRED_ORE_COUNT = 3,
        ITEM_TYPE = "Armor",
        FORGE_DELAY = 2,
        FORGE_POSITION = Vector3.new(-192.3, 29.5, 168.1),
        ROCK_NAME = "Pebble",
        UNDERGROUND_OFFSET = 4,
        MIN_ORES_FOR_FORGE = 10,
        LAYING_ANGLE = 90,
        MOVE_SPEED = 20,
        SELL_NPC_NAME = "Marbles",
        SELL_NPC_POSITION = Vector3.new(49.84, 29.17, 85.84),
        PRIORITY_ORDER = {"Purchase", "Kill", "Mine", "Forge"},
    }
    
    ----------------------------------------------------------------
    -- KNIT SETUP
    ----------------------------------------------------------------
    local KnitPackage = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit")
    local Knit = require(KnitPackage)
    
    if not Knit.OnStart then 
        pcall(function() Knit.Start():await() end)
    end
    
    local CharacterService = nil
    local PlayerController = nil
    local ProximityService = nil
    local ForgeService = nil
    local DialogueService = nil
    local UIController = nil
    
    pcall(function()
        CharacterService = Knit.GetService("CharacterService")
        PlayerController = Knit.GetController("PlayerController")
        ProximityService = Knit.GetService("ProximityService")
        ForgeService = Knit.GetService("ForgeService")
        DialogueService = Knit.GetService("DialogueService")
    end)
    
    local ToolController = nil
    local ToolActivatedFunc = nil
    
    pcall(function()
        for _, v in pairs(getgc(true)) do
            if type(v) == "table" then
                if rawget(v, "Name") == "ToolController" and rawget(v, "ToolActivated") then
                    ToolController = v
                    ToolActivatedFunc = v.ToolActivated
                    break
                end
            end
        end
    end)
    
    pcall(function()
        for _, v in pairs(getgc(true)) do
            if type(v) == "table" then
                if rawget(v, "Open") and rawget(v, "Close") and rawget(v, "Modules") then
                    UIController = v
                    break
                end
            end
        end
    end)
    
    local SERVICES = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")
    
    local PURCHASE_RF = nil
    pcall(function()
        PURCHASE_RF = SERVICES:WaitForChild("ProximityService", 5):WaitForChild("RF", 3):WaitForChild("Purchase", 3)
    end)
    
    local CHAR_RF = nil
    pcall(function()
        CHAR_RF = SERVICES:WaitForChild("CharacterService", 5):WaitForChild("RF", 3):WaitForChild("EquipItem", 3)
    end)
    
    local TOOL_RF_BACKUP = nil
    pcall(function()
        TOOL_RF_BACKUP = SERVICES:WaitForChild("ToolService", 5):WaitForChild("RF", 3):WaitForChild("ToolActivated", 3)
    end)
    
    local PROXIMITY_RF = nil
    pcall(function()
        PROXIMITY_RF = SERVICES:WaitForChild("ProximityService", 5):WaitForChild("RF", 3):WaitForChild("Forge", 3)
    end)
    
    local MINING_FOLDER_PATH = Workspace:WaitForChild("Rocks")
    local LIVING_FOLDER = Workspace:WaitForChild("Living")
    
    local FORGE_OBJECT = nil
    pcall(function()
        FORGE_OBJECT = Workspace:WaitForChild("Proximity", 5):WaitForChild("Forge", 3)
    end)
    
    if CharacterService then print("‚úÖ CharacterService Ready!") else warn("‚ö†Ô∏è CharacterService not found") end
    if PlayerController then print("‚úÖ PlayerController Ready!") else warn("‚ö†Ô∏è PlayerController not found") end
    if ToolController then print("‚úÖ ToolController Ready!") else warn("‚ö†Ô∏è ToolController not found") end
    if ForgeService then print("‚úÖ ForgeService Ready!") else warn("‚ö†Ô∏è ForgeService not found") end
    if DialogueService then print("‚úÖ DialogueService Ready!") else warn("‚ö†Ô∏è DialogueService not found") end
    if ProximityService then print("‚úÖ ProximityService Ready!") else warn("‚ö†Ô∏è ProximityService not found") end
    if UIController then print("‚úÖ UIController Ready!") else warn("‚ö†Ô∏è UIController not found") end
    if PURCHASE_RF then print("‚úÖ Purchase Remote Ready!") else warn("‚ö†Ô∏è Purchase Remote not found") end
    if FORGE_OBJECT then print("‚úÖ Forge Object Ready!") else warn("‚ö†Ô∏è Forge Object not found") end
    
    ----------------------------------------------------------------
    -- STATE MANAGEMENT
    ----------------------------------------------------------------
    local State = {
        currentTarget = nil,
        targetDestroyed = false,
        hpWatchConn = nil,
        noclipConn = nil,
        moveConn = nil,
        positionLockConn = nil,
        bodyVelocity = nil,
        bodyGyro = nil,
        currentObjectiveFrame = nil,
    }
    
    local function cleanupState()
        if State.hpWatchConn then State.hpWatchConn:Disconnect() State.hpWatchConn = nil end
        if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.positionLockConn then State.positionLockConn:Disconnect() State.positionLockConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        State.currentTarget = nil
        State.targetDestroyed = false
        
        if ToolController then
            ToolController.holdingM1 = false
        end
    end
    
    ----------------------------------------------------------------
    -- QUEST SYSTEM
    ----------------------------------------------------------------
    local function getQuestObjectives(questName)
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil, nil end
        
        local list = gui:FindFirstChild("Main") and gui.Main:FindFirstChild("Screen") 
                     and gui.Main.Screen:FindFirstChild("Quests") and gui.Main.Screen.Quests:FindFirstChild("List")
        if not list then return nil, nil end
        
        local questID = nil
        for _, child in ipairs(list:GetChildren()) do
            local id = string.match(child.Name, "^Introduction(%d+)Title$")
            if id and child:FindFirstChild("Frame") and child.Frame:FindFirstChild("TextLabel") then
                if child.Frame.TextLabel.Text == questName then
                    questID = id
                    break
                end
            end
        end
        
        if not questID then return nil, nil end
        
        local objList = list:FindFirstChild("Introduction" .. questID .. "List")
        return questID, objList
    end
    
    local function isObjectiveComplete(item)
        if not item then return false end
        local check = item:FindFirstChild("Main") and item.Main:FindFirstChild("Frame") and item.Main.Frame:FindFirstChild("Check")
        return check and check.Visible
    end
    
    local function getObjectiveText(item)
        local lbl = item:FindFirstChild("Main") and item.Main:FindFirstChild("TextLabel")
        return lbl and lbl.Text or ""
    end
    
    local function isQuest7StillActive()
        if not Quest7Active then return false end
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        if not questID or not objList then
            print("üõë Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' not found!")
            Quest7Active = false
            return false
        end
        
        return true
    end
    
    local function isCurrentObjectiveComplete()
        if State.currentObjectiveFrame then
            return isObjectiveComplete(State.currentObjectiveFrame)
        end
        return false
    end
    
    local function getObjectiveType(text)
        if string.find(text, "Purchase") or string.find(text, "Buy") or string.find(text, "Pickaxe") then
            return "Purchase"
        elseif string.find(text, "Kill") or string.find(text, "Zombie") or string.find(text, "Defeat") then
            return "Kill"
        elseif string.find(text, "Get Ore") or string.find(text, "Mine") or string.find(text, "Pebble") then
            return "Mine"
        elseif string.find(text, "Forge") or string.find(text, "forge") or string.find(text, "Item") then
            return "Forge"
        else
            return "Unknown"
        end
    end
    
    ----------------------------------------------------------------
    -- INVENTORY SYSTEM
    ----------------------------------------------------------------
    local function getPlayerInventory()
        local inventory = {}
        
        if not PlayerController or not PlayerController.Replica then
            warn("PlayerController/Replica not available!")
            return inventory
        end
        
        local replica = PlayerController.Replica
        if replica and replica.Data and replica.Data.Inventory then
            for itemName, amount in pairs(replica.Data.Inventory) do
                if type(amount) == "number" and amount > 0 then
                    inventory[itemName] = amount
                end
            end
        end
        
        return inventory
    end
    
    local function getAvailableOres()
        local inventory = getPlayerInventory()
        local ores = {}
        
        local oreTypes = {"Copper", "Stone", "Iron", "Sand Stone", "Tin", "Cardboardite", "Silver", "Gold", "Bananite", "Mushroomite", "Platinum", "Aite"}
        
        for _, oreName in ipairs(oreTypes) do
            if inventory[oreName] and inventory[oreName] > 0 then
                table.insert(ores, {Name = oreName, Amount = inventory[oreName]})
            end
        end
        
        if #ores == 0 then
            for itemName, amount in pairs(inventory) do
                if string.find(itemName, "Ore") or string.find(itemName, "ore") then
                    table.insert(ores, {Name = itemName, Amount = amount})
                end
            end
        end
        
        return ores
    end
    
    function getTotalOreCount()
        local ores = getAvailableOres()
        local total = 0
        for _, ore in ipairs(ores) do
            total = total + ore.Amount
        end
        return total
    end
    
    local function selectRandomOres(count)
        local availableOres = getAvailableOres()
        
        if #availableOres == 0 then
            return nil, "No ores found in inventory!"
        end
        
        local totalOres = 0
        for _, ore in ipairs(availableOres) do
            totalOres = totalOres + ore.Amount
        end
        
        if totalOres < count then
            return nil, string.format("Not enough ores! Need %d, have %d", count, totalOres)
        end
        
        local orePool = {}
        for _, ore in ipairs(availableOres) do
            for i = 1, ore.Amount do
                table.insert(orePool, ore.Name)
            end
        end
        
        local selected = {}
        for i = 1, count do
            if #orePool == 0 then break end
            local randomIndex = math.random(1, #orePool)
            local oreName = table.remove(orePool, randomIndex)
            selected[oreName] = (selected[oreName] or 0) + 1
        end
        
        return selected, nil
    end
    
    local function printInventorySummary()
        print("üì¶ INVENTORY CHECK:")
        local ores = getAvailableOres()
        
        if #ores == 0 then
            warn("   ‚ùå No ores found in inventory!")
            local inv = getPlayerInventory()
            if next(inv) then
                print("   üìã All items in inventory:")
                for item, amount in pairs(inv) do
                    print(string.format("      - %s: %d", item, amount))
                end
            else
                warn("   ‚ö†Ô∏è Inventory is completely empty!")
            end
            return
        end
        
        print("   üíé Available Ores:")
        local total = 0
        for _, ore in ipairs(ores) do
            print(string.format("      - %s: %d", ore.Name, ore.Amount))
            total = total + ore.Amount
        end
        print(string.format("   üìä Total: %d ores", total))
        print("   " .. string.rep("-", 28))
    end
    
    local function canDoObjective(objType)
        if objType == "Forge" then
            local totalOres = getTotalOreCount()
            if totalOres < QUEST_CONFIG.REQUIRED_ORE_COUNT then
                print(string.format("‚è∏Ô∏è  Cannot Forge: Only %d/%d ores available", totalOres, QUEST_CONFIG.REQUIRED_ORE_COUNT))
                return false
            end
        end
        return true
    end
    
    ----------------------------------------------------------------
    -- HELPER FUNCTIONS
    ----------------------------------------------------------------
    local HOTKEY_MAP = {
        ["1"] = Enum.KeyCode.One,
        ["2"] = Enum.KeyCode.Two,
        ["3"] = Enum.KeyCode.Three,
        ["4"] = Enum.KeyCode.Four,
        ["5"] = Enum.KeyCode.Five,
        ["6"] = Enum.KeyCode.Six,
        ["7"] = Enum.KeyCode.Seven,
        ["8"] = Enum.KeyCode.Eight,
        ["9"] = Enum.KeyCode.Nine,
        ["0"] = Enum.KeyCode.Zero
    }
    
    local function pressKey(keyCode)
        if not keyCode then return end
        VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
        task.wait(0.05)
        VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
    end
    
    local function findPickaxeSlotKey()
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil end
        
        local hotbar = gui:FindFirstChild("BackpackGui") and gui.BackpackGui:FindFirstChild("Backpack") and gui.BackpackGui.Backpack:FindFirstChild("Hotbar")
        if hotbar then
            for _, slotFrame in ipairs(hotbar:GetChildren()) do
                local frame = slotFrame:FindFirstChild("Frame")
                local label = frame and frame:FindFirstChild("ToolName")
                if label and label:IsA("TextLabel") and string.find(label.Text, "Pickaxe") then
                    return HOTKEY_MAP[slotFrame.Name]
                end
            end
        end
        
        return nil
    end
    
    local function findWeaponSlotKey()
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil end
        
        local hotbar = gui:FindFirstChild("BackpackGui") and gui.BackpackGui:FindFirstChild("Backpack") and gui.BackpackGui.Backpack:FindFirstChild("Hotbar")
        if hotbar then
            for _, slotFrame in ipairs(hotbar:GetChildren()) do
                local frame = slotFrame:FindFirstChild("Frame")
                local label = frame and frame:FindFirstChild("ToolName")
                if label and label:IsA("TextLabel") and not string.find(label.Text, "Pickaxe") and label.Text ~= "" then
                    return HOTKEY_MAP[slotFrame.Name], label.Text
                end
            end
        end
        
        return nil, nil
    end
    
    local function checkMiningError()
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return false end
        
        local notif = gui:FindFirstChild("Notifications")
        if notif and notif:FindFirstChild("Screen") and notif.Screen:FindFirstChild("NotificationsFrame") then
            for _, child in ipairs(notif.Screen.NotificationsFrame:GetChildren()) do
                local lbl = child:FindFirstChild("TextLabel", true)
                if lbl and string.find(lbl.Text, "Someone else is already mining") then
                    return true
                end
            end
        end
        
        return false
    end
    
    ----------------------------------------------------------------
    -- ROCK HELPERS
    ----------------------------------------------------------------
    local function getRockUndergroundPosition(rockModel)
        if not rockModel or not rockModel.Parent then return nil end
        
        local pivotCFrame = nil
        pcall(function()
            if rockModel.GetPivot then
                pivotCFrame = rockModel:GetPivot()
            elseif rockModel.WorldPivot then
                pivotCFrame = rockModel.WorldPivot
            end
        end)
        
        if pivotCFrame then
            local pos = pivotCFrame.Position
            return Vector3.new(pos.X, pos.Y - QUEST_CONFIG.UNDERGROUND_OFFSET, pos.Z)
        end
        
        if rockModel.PrimaryPart then
            local pos = rockModel.PrimaryPart.Position
            return Vector3.new(pos.X, pos.Y - QUEST_CONFIG.UNDERGROUND_OFFSET, pos.Z)
        end
        
        local part = rockModel:FindFirstChildWhichIsA("BasePart")
        if part then
            local pos = part.Position
            return Vector3.new(pos.X, pos.Y - QUEST_CONFIG.UNDERGROUND_OFFSET, pos.Z)
        end
        
        return nil
    end
    
    local function getRockHP(rock)
        if not rock or not rock.Parent then return 0 end
        local success, result = pcall(function()
            return rock:GetAttribute("Health") or 0
        end)
        return success and result or 0
    end
    
    local function isTargetValid(rock)
        if not rock or not rock.Parent then return false end
        if not rock:FindFirstChildWhichIsA("BasePart") then return false end
        local hp = getRockHP(rock)
        return hp > 0
    end
    
    local function findNearestRock()
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return nil end
        
        local targetRock, minDist = nil, math.huge
        
        for _, folder in ipairs(MINING_FOLDER_PATH:GetChildren()) do
            if folder:IsA("Folder") or folder:IsA("Model") then
                for _, child in ipairs(folder:GetChildren()) do
                    if child:IsA("SpawnLocation") or child.Name == "SpawnLocation" then
                        local rock = child:FindFirstChild(QUEST_CONFIG.ROCK_NAME)
                        if isTargetValid(rock) then
                            local pos = getRockUndergroundPosition(rock)
                            if pos then
                                local dist = (pos - hrp.Position).Magnitude
                                if dist < minDist then
                                    minDist = dist
                                    targetRock = rock
                                end
                            end
                        end
                    end
                end
            end
        end
        
        return targetRock, minDist
    end
    
    local function watchRockHP(rock)
        if State.hpWatchConn then State.hpWatchConn:Disconnect() end
        if not rock then return end
        
        State.hpWatchConn = rock:GetAttributeChangedSignal("Health"):Connect(function()
            local hp = rock:GetAttribute("Health") or 0
            print(string.format("üí• HP Changed! New HP: %d", hp))
            if hp == 0 then
                print("‚úÖ HP = 0 detected! Switching target...")
                State.targetDestroyed = true
                if ToolController then ToolController.holdingM1 = false end
                unlockPosition()
            end
        end)
    end
    
    ----------------------------------------------------------------
    -- ZOMBIE HELPERS
    ----------------------------------------------------------------
    local function getZombieUndergroundPosition(zombieModel)
        if not zombieModel or not zombieModel.Parent then return nil end
        
        local hrp = zombieModel:FindFirstChild("HumanoidRootPart")
        if hrp then
            local pos = hrp.Position
            return Vector3.new(pos.X, pos.Y - QUEST_CONFIG.ZOMBIE_UNDERGROUND_OFFSET, pos.Z)
        end
        
        return nil
    end
    
    local function getZombieHP(zombie)
        if not zombie or not zombie.Parent then return 0 end
        local humanoid = zombie:FindFirstChild("Humanoid")
        if humanoid then
            return humanoid.Health or 0
        end
        return 0
    end
    
    local function isZombieValid(zombie)
        if not zombie or not zombie.Parent then return false end
        return getZombieHP(zombie) > 0
    end
    
    local function findNearestZombie()
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return nil end
        
        local targetZombie, minDist = nil, math.huge
        
        for _, child in ipairs(LIVING_FOLDER:GetChildren()) do
            if string.match(child.Name, "Zombie%d+") or string.match(child.Name, "EliteZombie%d+") then
                if isZombieValid(child) then
                    local pos = getZombieUndergroundPosition(child)
                    if pos then
                        local dist = (pos - hrp.Position).Magnitude
                        if dist < minDist then
                            minDist = dist
                            targetZombie = child
                        end
                    end
                end
            end
        end
        
        return targetZombie, minDist
    end
    
    local function watchZombieHP(zombie)
        if State.hpWatchConn then State.hpWatchConn:Disconnect() end
        if not zombie then return end
        
        local humanoid = zombie:FindFirstChild("Humanoid")
        if not humanoid then return end
        
        State.hpWatchConn = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
            local hp = humanoid.Health or 0
            print(string.format("üí• HP Changed! New HP: %.1f", hp))
            if hp == 0 then
                print("‚úÖ Zombie died! Switching target...")
                State.targetDestroyed = true
                if ToolController then ToolController.holdingM1 = false end
                unlockPosition()
            end
        end)
    end
    
    local function getBestWeapon()
        if not PlayerController or not PlayerController.Replica then return nil end
        
        local replica = PlayerController.Replica
        if not replica.Data or not replica.Data.Inventory or not replica.Data.Inventory.Equipments then
            return nil
        end
        
        local equipments = replica.Data.Inventory.Equipments
        local bestWeapon = nil
        local highestDmg = 0
        
        for id, item in pairs(equipments) do
            if type(item) == "table" and item.Type then
                if not string.find(item.Type, "Pickaxe") then
                    local dmg = item.Dmg or 0
                    if dmg > highestDmg then
                        highestDmg = dmg
                        bestWeapon = item
                    end
                end
            end
        end
        
        return bestWeapon
    end
    
    ----------------------------------------------------------------
    -- NOCLIP & MOVEMENT
    ----------------------------------------------------------------
    local function enableNoclip()
        if State.noclipConn then return end
        
        local char = player.Character
        if not char then return end
        
        State.noclipConn = RunService.Stepped:Connect(function()
            if not char or not char.Parent then
                if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
                return
            end
            
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end
    
    local function disableNoclip()
        if State.noclipConn then
            State.noclipConn:Disconnect()
            State.noclipConn = nil
        end
    end
    
    local function smoothMoveTo(targetPos, callback)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        enableNoclip()
        
        local bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Parent = hrp
        State.bodyVelocity = bv
        
        local bg = Instance.new("BodyGyro")
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.P = 10000
        bg.D = 500
        bg.Parent = hrp
        State.bodyGyro = bg
        
        print(string.format("   üöÄ Moving to (%.1f, %.1f, %.1f)...", targetPos.X, targetPos.Y, targetPos.Z))
        
        State.moveConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                if bv then bv:Destroy() end
                if bg then bg:Destroy() end
                State.bodyVelocity = nil
                State.bodyGyro = nil
                return
            end
            
            local currentPos = hrp.Position
            local direction = (targetPos - currentPos)
            local distance = direction.Magnitude
            
            if distance < 2 then
                print("   ‚úÖ Reached target!")
                
                bv.Velocity = Vector3.zero
                task.wait(0.1)
                
                bv:Destroy()
                bg:Destroy()
                State.bodyVelocity = nil
                State.bodyGyro = nil
                
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                
                if callback then callback() end
                return
            end
            
            local speed = math.min(QUEST_CONFIG.MOVE_SPEED, distance * 10)
            local velocity = direction.Unit * speed
            
            bv.Velocity = velocity
            bg.CFrame = CFrame.lookAt(currentPos, targetPos)
        end)
        
        return true
    end
    
    ----------------------------------------------------------------
    -- POSITION LOCK
    ----------------------------------------------------------------
    local function lockPositionLayingDown(targetPos)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        if State.positionLockConn then
            State.positionLockConn:Disconnect()
            State.positionLockConn = nil
        end
        
        local angle = math.rad(QUEST_CONFIG.LAYING_ANGLE)
        local baseCFrame = CFrame.new(targetPos)
        local layingCFrame = baseCFrame * CFrame.Angles(angle, 0, 0)
        
        State.positionLockConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.positionLockConn then
                    State.positionLockConn:Disconnect()
                    State.positionLockConn = nil
                end
                return
            end
            
            hrp.CFrame = layingCFrame
            hrp.Velocity = Vector3.zero
            hrp.AssemblyLinearVelocity = Vector3.zero
        end)
        
        print("üîí Position locked (laying down)")
    end
    
    local function lockPositionFollowTarget(targetModel)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp or not targetModel then return end
        
        if State.positionLockConn then
            State.positionLockConn:Disconnect()
            State.positionLockConn = nil
        end
        
        local angle = math.rad(QUEST_CONFIG.LAYING_ANGLE)
        
        State.positionLockConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.positionLockConn then
                    State.positionLockConn:Disconnect()
                    State.positionLockConn = nil
                end
                return
            end
            
            if not targetModel or not targetModel.Parent then
                if State.positionLockConn then
                    State.positionLockConn:Disconnect()
                    State.positionLockConn = nil
                end
                return
            end
            
            local targetPos = getZombieUndergroundPosition(targetModel)
            if targetPos then
                local baseCFrame = CFrame.new(targetPos)
                local layingCFrame = baseCFrame * CFrame.Angles(angle, 0, 0)
                
                hrp.CFrame = layingCFrame
                hrp.Velocity = Vector3.zero
                hrp.AssemblyLinearVelocity = Vector3.zero
            end
        end)
        
        print("üîí Position locked (following target)")
    end
    
    local function unlockPosition()
        if State.positionLockConn then
            State.positionLockConn:Disconnect()
            State.positionLockConn = nil
            print("üîì Position unlocked!")
        end
    end
    
    ----------------------------------------------------------------
    -- SELL SYSTEM (FIXED - ‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≤‡∏Å UI ‡πÅ‡∏ó‡∏ô Replica)
    ----------------------------------------------------------------
    local function getEquippedItemsFromUI()
        local equipped = {}
        
        print("   üîç Checking equipped items from UI...")
        
        -- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≤‡∏Å PlayerGui.Menu.Frame.Frame.Menus.Tools.Frame
        local menuUI = playerGui:FindFirstChild("Menu")
                       and playerGui.Menu:FindFirstChild("Frame")
                       and playerGui.Menu.Frame:FindFirstChild("Frame")
                       and playerGui.Menu.Frame.Frame:FindFirstChild("Menus")
                       and playerGui.Menu.Frame.Frame.Menus:FindFirstChild("Tools")
                       and playerGui.Menu.Frame.Frame.Menus.Tools:FindFirstChild("Frame")
        
        if not menuUI then
            warn("   ‚ö†Ô∏è Menu UI not found!")
            return equipped
        end
        
        for _, child in ipairs(menuUI:GetChildren()) do
            local equipButton = child:FindFirstChild("Equip")
            local equipLabel = equipButton and equipButton:FindFirstChild("TextLabel")
            
            if equipLabel and equipLabel:IsA("TextLabel") then
                local isEquipped = (equipLabel.Text == "Unequip")
                
                if isEquipped then
                    -- child.Name ‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡πá‡∏ô GUID ‡∏´‡∏£‡∏∑‡∏≠ ‡∏ä‡∏∑‡πà‡∏≠ Pickaxe
                    local identifier = child.Name
                    equipped[identifier] = true
                    
                    print(string.format("      ‚úÖ Equipped: %s (UI)", identifier))
                end
            end
        end
        
        return equipped
    end
    
    local function getSellableItems()
        if not PlayerController or not PlayerController.Replica then
            return {}
        end
        
        local replica = PlayerController.Replica
        if not replica.Data or not replica.Data.Inventory or not replica.Data.Inventory.Equipments then
            return {}
        end
        
        local sellable = {}
        
        -- ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ Equipped ‡∏à‡∏≤‡∏Å UI ‡πÅ‡∏ó‡∏ô Replica
        local equippedItems = getEquippedItemsFromUI()
        
        for id, item in pairs(replica.Data.Inventory.Equipments) do
            if type(item) == "table" and item.Type then
                local isPickaxe = string.find(item.Type, "Pickaxe")
                
                -- ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≤‡∏Å UI (‡∏ó‡∏±‡πâ‡∏á GUID ‡πÅ‡∏•‡∏∞ Type/Name)
                local isEquipped = false
                
                -- 1. ‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≤‡∏Å GUID
                if item.GUID and equippedItems[item.GUID] then
                    isEquipped = true
                end
                
                -- 2. ‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≤‡∏Å Type (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Pickaxe ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠‡πÅ‡∏ó‡∏ô GUID)
                if equippedItems[item.Type] then
                    isEquipped = true
                end
                
                -- 3. ‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≤‡∏Å Name
                if item.Name and equippedItems[item.Name] then
                    isEquipped = true
                end
                
                -- ‚úÖ ‡∏Ç‡∏≤‡∏¢‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ Equipped (‡∏£‡∏ß‡∏° Pickaxe ‡∏î‡πâ‡∏ß‡∏¢)
                if not isEquipped then
                    -- Identifier: Pickaxe ‡πÉ‡∏ä‡πâ Type, ‡∏≠‡∏∑‡πà‡∏ô‡πÜ‡πÉ‡∏ä‡πâ GUID
                    local identifier = isPickaxe and item.Type or item.GUID
                    
                    table.insert(sellable, {
                        ID = id,
                        Identifier = identifier,
                        Type = item.Type,
                        Name = item.Name or item.Type,
                        Dmg = item.Dmg or 0,
                        IsPickaxe = isPickaxe
                    })
                end
            end
        end
        
        return sellable
    end
    
    local function doSellUnequippedItems()
        print("üí∞ Selling Unequipped Items...")
        
        local sellableItems = getSellableItems()
        
        if #sellableItems == 0 then
            print("   ‚úÖ No items to sell (all equipped)")
            return true
        end
        
        print(string.format("   üìã Found %d unequipped items to sell:", #sellableItems))
        for i, item in ipairs(sellableItems) do
            local idType = item.IsPickaxe and "Name" or "GUID"
            print(string.format("      %d. %s (%s: %s, Dmg: %d)", 
                i, item.Name, idType, item.Identifier, item.Dmg))
        end
        
        -- ‡∏´‡∏≤ Sell NPC
        local proximity = Workspace:FindFirstChild("Proximity")
        local npc = proximity and (proximity:FindFirstChild(QUEST_CONFIG.SELL_NPC_NAME) or proximity:FindFirstChild("Greedy Cey"))
        
        if not npc then
            warn("   ‚ùå Sell NPC not found!")
            return false
        end
        
        if not ProximityService or not DialogueService then
            warn("   ‚ùå Required services not available!")
            return false
        end
        
        local soldCount = 0
        
        for _, item in ipairs(sellableItems) do
            print(string.format("   üí∞ Selling %s...", item.Name))
            
            -- 1. ‡πÄ‡∏õ‡∏¥‡∏î Dialogue
            local success1 = pcall(function()
                ProximityService:ForceDialogue(npc, "SellConfirm")
            end)
            
            if not success1 then
                warn("      ‚ùå Failed to open dialogue")
                continue
            end
            
            task.wait(0.2)
            
            -- 2. ‡∏™‡πà‡∏á Basket (‡πÉ‡∏ä‡πâ Identifier)
            local basket = {[item.Identifier] = true}
            
            local success2 = pcall(function()
                DialogueService:RunCommand("SellConfirm", {Basket = basket})
            end)
            
            if success2 then
                soldCount = soldCount + 1
                print(string.format("      ‚úÖ Sold!"))
                task.wait(0.3)
            else
                warn(string.format("      ‚ùå Failed to sell %s", item.Name))
            end
            
            -- 3. Force restore UI
            pcall(function()
                local char = player.Character
                if char then
                    local status = char:FindFirstChild("Status")
                    if status then
                        for _, tag in ipairs(status:GetChildren()) do
                            if tag.Name == "DisableBackpack" or tag.Name == "NoMovement" or tag.Name == "Talking" then
                                tag:Destroy()
                            end
                        end
                    end
                end
                
                local gui = player:FindFirstChild("PlayerGui")
                if gui then
                    local dUI = gui:FindFirstChild("DialogueUI")
                    if dUI then dUI.Enabled = false end
                end
            end)
            
            task.wait(0.5)
        end
        
        print(string.format("   ‚úÖ Sell complete! Sold %d/%d items", soldCount, #sellableItems))
        
        -- Final restore
        local gui = player:FindFirstChild("PlayerGui")
        if gui then
            local main = gui:FindFirstChild("Main")
            if main then main.Enabled = true end
            
            local backpack = gui:FindFirstChild("BackpackGui")
            if backpack then backpack.Enabled = true end
        end
        
        return true
    end
    
    ----------------------------------------------------------------
    -- UI MANAGEMENT
    ----------------------------------------------------------------
    local function closeForgeUI()
        print("üîß Closing Forge UI...")
        
        local closed = false
        
        if UIController and UIController.Close then
            pcall(function()
                if UIController.Modules and UIController.Modules.Forge then
                    UIController:Close("Forge")
                    print("   ‚úÖ Closed via UIController")
                    closed = true
                end
            end)
        end
        
        if not closed then
            pcall(function()
                local forgeGui = playerGui:FindFirstChild("Forge") or playerGui:FindFirstChild("ForgeUI")
                if forgeGui then
                    forgeGui.Enabled = false
                    print("   ‚úÖ Closed via PlayerGui")
                    closed = true
                end
            end)
        end
        
        if not closed then
            warn("   ‚ö†Ô∏è Could not close Forge UI (may already be closed)")
        end
        
        task.wait(0.3)
    end
    
    local function restoreUI()
        print("üîß Restoring UI State...")
        
        local char = player.Character
        if char then
            local status = char:FindFirstChild("Status")
            if status then
                for _, tag in ipairs(status:GetChildren()) do
                    if tag.Name == "DisableBackpack" or tag.Name == "NoMovement" or tag.Name == "Talking" then
                        pcall(function() tag:Destroy() end)
                    end
                end
            end
            
            local humanoid = char:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = 16
                humanoid.JumpPower = 50
            end
        end
        
        local gui = player:FindFirstChild("PlayerGui")
        if gui then
            local main = gui:FindFirstChild("Main")
            if main then main.Enabled = true end
            
            local backpack = gui:FindFirstChild("BackpackGui")
            if backpack then backpack.Enabled = true end
            
            local dialogueUI = gui:FindFirstChild("DialogueUI")
            if dialogueUI then dialogueUI.Enabled = false end
        end
        
        local cam = Workspace.CurrentCamera
        if cam then
            cam.CameraType = Enum.CameraType.Custom
        end
        
        print("‚úÖ UI State restored!")
    end
    
    ----------------------------------------------------------------
    -- FORGE SYSTEM
    ----------------------------------------------------------------
    getgenv().ForgeHookActive = getgenv().ForgeHookActive or false
    
    local function setupForgeHook()
        if getgenv().ForgeHookActive then
            print("‚öôÔ∏è  Forge Hook already active")
            return
        end
        
        if not ForgeService then
            warn("‚ùå ForgeService not available!")
            return
        end
        
        print("üîß Installing Forge Hook...")
        
        local originalChangeSequence = ForgeService.ChangeSequence
        
        ForgeService.ChangeSequence = function(self, sequenceName, args)
            print("üî® Sequence: " .. sequenceName)
            
            local success, result = pcall(originalChangeSequence, self, sequenceName, args)
            
            task.spawn(function()
                if sequenceName == "Melt" then
                    print("   ‚è≥ Auto Pouring in 8s...")
                    task.wait(8)
                    self:ChangeSequence("Pour", {ClientTime = 8.5, InContact = true})
                elseif sequenceName == "Pour" then
                    print("   ‚è≥ Auto Hammering in 5s...")
                    task.wait(5)
                    self:ChangeSequence("Hammer", {ClientTime = 5.2})
                elseif sequenceName == "Hammer" then
                    print("   ‚è≥ Auto Watering in 6s...")
                    task.wait(6)
                    self:ChangeSequence("Water", {ClientTime = 6.5})
                elseif sequenceName == "Water" then
                    print("   ‚è≥ Auto Showcasing in 3s...")
                    task.wait(3)
                    self:ChangeSequence("Showcase", {})
                elseif sequenceName == "Showcase" then
                    print("   ‚úÖ Forge completed!")
                    -- ‚úÖ ‡πÑ‡∏°‡πà‡∏õ‡∏¥‡∏î UI ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà (‡πÉ‡∏´‡πâ doForge() ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£)
                end
            end)
            
            return success, result
        end
        
        getgenv().ForgeHookActive = true
        print("‚úÖ Forge Hook installed!")
    end
    
    local function moveToForge()
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        local forgePos = QUEST_CONFIG.FORGE_POSITION
        local currentDist = (forgePos - hrp.Position).Magnitude
        
        print(string.format("üö∂ Moving to Forge at (%.1f, %.1f, %.1f) (%.1f studs away)...", 
            forgePos.X, forgePos.Y, forgePos.Z, currentDist))
        
        local moveComplete = false
        smoothMoveTo(forgePos, function()
            moveComplete = true
        end)
        
        local timeout = 15
        local startTime = tick()
        while not moveComplete and tick() - startTime < timeout do
            task.wait(0.1)
        end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        print("‚úÖ Reached Forge!")
        print("   ‚è≥ Waiting 1.5s before opening Forge UI...")
        task.wait(1.5)
        
        return true
    end
    
    local function startForge(oreSelection)
        print("üî® Starting Forge with:")
        for oreName, amount in pairs(oreSelection) do
            print(string.format("   - %s x%d", oreName, amount))
        end
        
        if not FORGE_OBJECT then
            warn("‚ùå Forge Object not found!")
            return false
        end
        
        pcall(function()
            PROXIMITY_RF:InvokeServer(FORGE_OBJECT)
        end)
        
        task.wait(1)
        
        if not ForgeService then return false end
        
        local forgeSuccess = pcall(function()
            ForgeService:ChangeSequence("Melt", {
                Ores = oreSelection,
                ItemType = QUEST_CONFIG.ITEM_TYPE,
                FastForge = false
            })
        end)
        
        if forgeSuccess then
            print("‚úÖ Forge Melt started!")
            return true
        else
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- OBJECTIVES
    ----------------------------------------------------------------
    local function doPurchaseIronPickaxe()
        print("üõí Objective 1: Purchasing Iron Pickaxe...")
        
        if not PURCHASE_RF then
            warn("   ‚ùå Purchase Remote not available!")
            return false
        end
        
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        
        if hrp then
            local npcPos = QUEST_CONFIG.NPC_POSITION
            local currentDist = (npcPos - hrp.Position).Magnitude
            
            print(string.format("   üö∂ Moving to NPC at (%.2f, %.2f, %.2f) (%.1f studs away)...", 
                npcPos.X, npcPos.Y, npcPos.Z, currentDist))
            
            local moveComplete = false
            smoothMoveTo(npcPos, function()
                moveComplete = true
            end)
            
            local timeout = 15
            local startTime = tick()
            while not moveComplete and tick() - startTime < timeout do
                task.wait(0.1)
            end
            
            if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
            if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
            if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
            
            print("   ‚úÖ Reached NPC!")
            print("   ‚è≥ Waiting 1.5s before purchase...")
            task.wait(1.5)
        end
        
        print(string.format("   üí∞ Purchasing %s (Amount: %d)", QUEST_CONFIG.PICKAXE_NAME, QUEST_CONFIG.PICKAXE_AMOUNT))
        
        local args = {QUEST_CONFIG.PICKAXE_NAME, QUEST_CONFIG.PICKAXE_AMOUNT}
        local success, result = pcall(function()
            return PURCHASE_RF:InvokeServer(unpack(args))
        end)
        
        if success then
            print("   ‚úÖ Purchase successful!")
            return true
        else
            warn("   ‚ùå Purchase failed: " .. tostring(result))
            return false
        end
    end
    
    local function doMinePebble()
        print("‚õèÔ∏è  Objective 4: Mining Pebble...")
        
        IsMiningActive = true
        
        print("   " .. string.rep("-", 30))
        print("   üîÑ Starting Pebble mining loop...")
        print("   " .. string.rep("-", 30))
        
        while isQuest7StillActive() and not isCurrentObjectiveComplete() do
            local char = player.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            
            if not hrp then
                warn("   ‚ö†Ô∏è Waiting for character...")
                task.wait(2)
                continue
            end
            
            cleanupState()
            
            local targetRock, dist = findNearestRock()
            if not targetRock then
                warn("   ‚ö†Ô∏è No Pebble found, waiting...")
                task.wait(2)
                continue
            end
            
            State.currentTarget = targetRock
            State.targetDestroyed = false
            
            local targetPos = getRockUndergroundPosition(targetRock)
            if not targetPos then
                warn("   ‚ö†Ô∏è Cannot get pebble position!")
                task.wait(1)
                continue
            end
            
            local currentHP = getRockHP(targetRock)
            print(string.format("   üéØ Target: %s (dist: %d, HP: %d)", targetRock.Parent.Name, math.floor(dist), currentHP))
            
            watchRockHP(targetRock)
            
            local moveStarted = false
            smoothMoveTo(targetPos, function()
                lockPositionLayingDown(targetPos)
                moveStarted = true
            end)
            
            local timeout = 15
            local startTime = tick()
            while not moveStarted and tick() - startTime < timeout do
                task.wait(0.1)
            end
            
            if not moveStarted then
                lockPositionLayingDown(targetPos)
            end
            
            task.wait(0.5)
            
            while not State.targetDestroyed and isQuest7StillActive() and not isCurrentObjectiveComplete() do
                if not char or not char.Parent then
                    print("   ‚ö†Ô∏è Character died!")
                    break
                end
                
                if not targetRock or not targetRock.Parent then
                    print("   ‚ö†Ô∏è Target removed!")
                    State.targetDestroyed = true
                    break
                end
                
                if checkMiningError() then
                    print("   ‚ö†Ô∏è Someone else mining!")
                    State.targetDestroyed = true
                    if ToolController then ToolController.holdingM1 = false end
                    break
                end
                
                local toolInHand = char:FindFirstChildWhichIsA("Tool")
                local isPickaxeHeld = toolInHand and string.find(toolInHand.Name, "Pickaxe")
                
                if not isPickaxeHeld then
                    if ToolController then ToolController.holdingM1 = false end
                    
                    local key = findPickaxeSlotKey()
                    if key then
                        pressKey(key)
                        task.wait(0.3)
                    else
                        pcall(function()
                            CHAR_RF:InvokeServer({Runes = {}}, {Name = QUEST_CONFIG.PICKAXE_NAME})
                        end)
                        task.wait(0.5)
                    end
                else
                    if ToolController and ToolActivatedFunc then
                        ToolController.holdingM1 = true
                        pcall(function()
                            ToolActivatedFunc(ToolController, toolInHand)
                        end)
                    else
                        pcall(function()
                            TOOL_RF_BACKUP:InvokeServer(toolInHand.Name, true)
                        end)
                    end
                end
                
                task.wait(0.15)
            end
            
            unlockPosition()
            
            if isCurrentObjectiveComplete() then
                print("   ‚úÖ Objective 4 (Mine Pebble) Complete!")
                break
            end
            
            print("   üîÑ Finding next target...")
            task.wait(0.5)
        end
        
        print("   ‚õèÔ∏è  Mining ended")
        IsMiningActive = false
        unlockPosition()
        disableNoclip()
        cleanupState()
    end
    
    local function doKillZombies()
        print("‚öîÔ∏è  Objective 2: Killing Zombies...")
        
        IsKillingActive = true
        
        print("   " .. string.rep("-", 30))
        print("   üîÑ Starting Zombie hunting loop...")
        print("   " .. string.rep("-", 30))
        
        while isQuest7StillActive() and not isCurrentObjectiveComplete() do
            local char = player.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            
            if not hrp then
                warn("   ‚ö†Ô∏è Waiting for character...")
                task.wait(2)
                continue
            end
            
            cleanupState()
            
            local targetZombie, dist = findNearestZombie()
            if not targetZombie then
                warn("   ‚ö†Ô∏è No Zombies found, waiting...")
                task.wait(2)
                continue
            end
            
            State.currentTarget = targetZombie
            State.targetDestroyed = false
            
            local targetPos = getZombieUndergroundPosition(targetZombie)
            if not targetPos then
                warn("   ‚ö†Ô∏è Cannot get zombie position!")
                task.wait(1)
                continue
            end
            
            local currentHP = getZombieHP(targetZombie)
            print(string.format("   üéØ Target: %s (dist: %d, HP: %.1f)", targetZombie.Name, math.floor(dist), currentHP))
            
            watchZombieHP(targetZombie)
            
            local moveStarted = false
            smoothMoveTo(targetPos, function()
                lockPositionFollowTarget(targetZombie)
                moveStarted = true
            end)
            
            local timeout = 15
            local startTime = tick()
            while not moveStarted and tick() - startTime < timeout do
                task.wait(0.1)
            end
            
            if not moveStarted then
                lockPositionFollowTarget(targetZombie)
            end
            
            task.wait(0.5)
            
            while not State.targetDestroyed and isQuest7StillActive() and not isCurrentObjectiveComplete() do
                if not char or not char.Parent then
                    print("   ‚ö†Ô∏è Character died!")
                    break
                end
                
                if not targetZombie or not targetZombie.Parent or not isZombieValid(targetZombie) then
                    print("   ‚ö†Ô∏è Target removed or died!")
                    State.targetDestroyed = true
                    unlockPosition()  
                    break
                end
                
                local currentZombiePos = getZombieUndergroundPosition(targetZombie)
                if currentZombiePos and hrp then
                    local distToZombie = (currentZombiePos - hrp.Position).Magnitude
                    if distToZombie > QUEST_CONFIG.ZOMBIE_MAX_DISTANCE then
                        print(string.format("   ‚ö†Ô∏è Zombie moved too far! (%.1f studs) Switching target...", distToZombie))
                        State.targetDestroyed = true
                        unlockPosition()
                        break
                    end
                end
                
                local toolInHand = char:FindFirstChildWhichIsA("Tool")
                local isWeaponHeld = toolInHand and not string.find(toolInHand.Name, "Pickaxe")
                
                if not isWeaponHeld then
                    if ToolController then ToolController.holdingM1 = false end
                    
                    local bestWeapon = getBestWeapon()
                    if bestWeapon then
                        print(string.format("   ‚öîÔ∏è  Equipping weapon: %s", bestWeapon.Type))
                        pcall(function()
                            CharacterService:EquipItem(bestWeapon)
                        end)
                        task.wait(0.5)
                    else
                        local key, weaponName = findWeaponSlotKey()
                        if key then
                            print(string.format("   ‚öîÔ∏è  Equipping via hotkey: %s", weaponName))
                            pressKey(key)
                            task.wait(0.3)
                        else
                            warn("   ‚ùå No weapon found!")
                            task.wait(1)
                        end
                    end
                else
                    if ToolController and ToolActivatedFunc then
                        ToolController.holdingM1 = true
                        pcall(function()
                            ToolActivatedFunc(ToolController, toolInHand)
                        end)
                    else
                        pcall(function()
                            TOOL_RF_BACKUP:InvokeServer(toolInHand.Name, true)
                        end)
                    end
                end
                
                task.wait(0.15)
            end
            
            unlockPosition()
            
            if isCurrentObjectiveComplete() then
                print("   ‚úÖ Objective 2 (Kill Zombies) Complete!")
                break
            end
            
            print("   üîÑ Finding next target...")
            task.wait(0.5)
        end
        
        print("   ‚öîÔ∏è  Zombie hunting ended")
        IsKillingActive = false
        unlockPosition()
        disableNoclip()
        cleanupState()
    end
    
    local function doForge()
        print("üî® Objective 3: Forging Armor...")
        
        IsForgingActive = true
        
        print("\n" .. string.rep("=", 50))
        print("üìã Step 1: Selling Unequipped Items")
        print(string.rep("=", 50))
        
        doSellUnequippedItems()
        
        print("\n" .. string.rep("=", 50))
        print("üî® Step 2: Starting Forge")
        print(string.rep("=", 50))
        
        setupForgeHook()
        moveToForge()
        
        local forgeAttempts = 0
        
        while isQuest7StillActive() and not isCurrentObjectiveComplete() do
            forgeAttempts = forgeAttempts + 1
            print(string.format("\nüî® Forge Attempt #%d", forgeAttempts))
            
            printInventorySummary()
            
            local totalOres = getTotalOreCount()
            if totalOres < QUEST_CONFIG.REQUIRED_ORE_COUNT then
                warn(string.format("‚ùå Not enough ores! Have %d, need %d", totalOres, QUEST_CONFIG.REQUIRED_ORE_COUNT))
                warn("‚ö†Ô∏è This shouldn't happen - Mine objective should be done first!")
                break
            end
            
            local oreSelection, errorMsg = selectRandomOres(QUEST_CONFIG.REQUIRED_ORE_COUNT)
            if not oreSelection then
                warn(string.format("‚ùå ERROR: %s", errorMsg))
                break
            end
            
            local success = startForge(oreSelection)
            if success then
                print("   ‚è≥ Waiting for forge to complete...")
                task.wait(27)
            else
                warn("   ‚ùå Forge failed, retrying in 3s...")
                task.wait(3)
            end
            
            if isCurrentObjectiveComplete() then
                print("   ‚úÖ Objective 3 (Forge) Complete!")
                break
            end
            
            print(string.format("   ‚è∏Ô∏è  Cooling down for %ds...", QUEST_CONFIG.FORGE_DELAY))
            task.wait(QUEST_CONFIG.FORGE_DELAY)
        end
        
        -- ‚úÖ FIXED: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î UI (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô Quest 3)
        print("\nüö™ Closing Forge UI...")
        closeForgeUI()
        task.wait(0.5)
        restoreUI()
        
        print("   üî® Forging ended")
        IsForgingActive = false
        disableNoclip()
        cleanupState()
    end
    
    ----------------------------------------------------------------
    -- SMART QUEST RUNNER
    ----------------------------------------------------------------
    local function RunQuest7Smart()
        print(string.rep("=", 50))
        print("üöÄ QUEST 7: " .. QUEST_CONFIG.QUEST_NAME)
        print("‚öôÔ∏è  SMART SYSTEM: Priority-based + Flexible")
        print("üìã Priority Order: Purchase ‚Üí Kill ‚Üí Mine ‚Üí Forge")
        print("üí∞ Sell System: ‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≤‡∏Å UI (Pickaxe Name + Weapon/Armor GUID)")
        print(string.rep("=", 50))
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        
        if not questID then
            warn("‚ùå Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' not found!")
            Quest7Active = false
            return
        end
        
        print("‚úÖ Quest found (ID: " .. questID .. ")\n")
        
        local objectives = {}
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                local text = getObjectiveText(item)
                local objType = getObjectiveType(text)
                table.insert(objectives, {
                    order = tonumber(item.Name),
                    frame = item,
                    text = text,
                    type = objType
                })
            end
        end
        
        table.sort(objectives, function(a, b)
            local function getPriority(type)
                for i, priorityType in ipairs(QUEST_CONFIG.PRIORITY_ORDER) do
                    if string.find(type, priorityType) then
                        return i
                    end
                end
                return 999
            end
            return getPriority(a.type) < getPriority(b.type)
        end)
        
        print(string.rep("=", 50))
        print("üìã Quest Objectives (Priority Order):")
        for i, obj in ipairs(objectives) do
            local complete = isObjectiveComplete(obj.frame)
            print(string.format("   %d. [%s] %s %s", i, obj.type, obj.text, complete and "‚úÖ" or "‚è≥"))
        end
        print(string.rep("=", 50))
        
        local maxAttempts = 10
        local attempt = 0
        
        while isQuest7StillActive() and attempt < maxAttempts do
            attempt = attempt + 1
            print(string.format("\nüîÑ Quest Cycle #%d", attempt))
            
            local allComplete = true
            local didSomething = false
            
            for _, obj in ipairs(objectives) do
                if not isQuest7StillActive() then
                    print("üõë Quest disappeared!")
                    break
                end
                
                local complete = isObjectiveComplete(obj.frame)
                
                if not complete then
                    allComplete = false
                    
                    if not canDoObjective(obj.type) then
                        print(string.format("‚è∏Ô∏è  Skipping [%s] - Cannot do right now", obj.type))
                        continue
                    end
                    
                    State.currentObjectiveFrame = obj.frame
                    
                    print(string.format("\n‚ñ∂Ô∏è  Processing [%s]: %s", obj.type, obj.text))
                    
                    if obj.type == "Purchase" then
                        doPurchaseIronPickaxe()
                        didSomething = true
                        task.wait(2)
                    elseif obj.type == "Kill" then
                        doKillZombies()
                        didSomething = true
                        task.wait(1)
                    elseif obj.type == "Mine" then
                        doMinePebble()
                        didSomething = true
                        task.wait(1)
                    elseif obj.type == "Forge" then
                        doForge()
                        didSomething = true
                        task.wait(1)
                    else
                        warn("‚ùå Unknown objective type: " .. obj.type)
                    end
                    
                    task.wait(1)
                    
                    if isObjectiveComplete(obj.frame) then
                        print(string.format("‚úÖ [%s] Complete!", obj.type))
                    else
                        print(string.format("‚è≥ [%s] Still in progress", obj.type))
                    end
                end
            end
            
            if allComplete then
                print("\nüéâ All objectives complete!")
                break
            end
            
            if not didSomething then
                warn("‚ö†Ô∏è No objectives could be completed this cycle!")
                print("   ‚è≥ Waiting 3s before retry...")
                task.wait(3)
            end
        end
        
        task.wait(2)
        
        local allComplete = true
        for _, obj in ipairs(objectives) do
            if not isObjectiveComplete(obj.frame) then
                allComplete = false
                warn(string.format("‚ùå [%s] incomplete: %s", obj.type, obj.text))
            end
        end
        
        if allComplete then
            print("\n" .. string.rep("=", 50))
            print("üèÜ Quest 7 Complete!")
            print(string.rep("=", 50))
        else
            warn("\n" .. string.rep("=", 50))
            warn("‚ö†Ô∏è Quest 7 incomplete after " .. attempt .. " cycles")
            warn(string.rep("=", 50))
        end
        
        Quest7Active = false
        IsMiningActive = false
        IsKillingActive = false
        IsForgingActive = false
        unlockPosition()
        disableNoclip()
        cleanupState()
    end
    
    ----------------------------------------------------------------
    -- START
    ----------------------------------------------------------------
    RunQuest7Smart()
end

----------------------------------------------------------------
-- QUEST 8 ORIGINAL (from 8.lua)
----------------------------------------------------------------
local function RunQuest08()
    -- QUEST 8: "Reporting In!" (Body Move + Dialogue with Sensei Moro)
    -- Objective: ‡πÑ‡∏õ‡∏´‡∏≤ Sensei Moro ‡πÅ‡∏•‡∏∞‡∏Å‡∏î CheckQuest
    
    
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Workspace = game:GetService("Workspace")
    
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    ----------------------------------------------------------------
    -- CONFIG
    ----------------------------------------------------------------
    local Quest8Active = true
    
    local QUEST_CONFIG = {
        QUEST_NAME = "Reporting In",
        NPC_NAME = "Sensei Moro",
        QUEST_OPTION_ARG = "CheckQuest",
        MOVE_SPEED = 20,
        NPC_STOP_DISTANCE = 5,  -- ‡∏´‡∏¢‡∏∏‡∏î‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å NPC 5 studs
    }
    
    ----------------------------------------------------------------
    -- KNIT SETUP
    ----------------------------------------------------------------
    local KnitPackage = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit")
    local Knit = require(KnitPackage)
    
    if not Knit.OnStart then 
        pcall(function() Knit.Start():await() end)
    end
    
    local ProximityService = nil
    local DialogueService = nil
    
    pcall(function()
        ProximityService = Knit.GetService("ProximityService")
        DialogueService = Knit.GetService("DialogueService")
    end)
    
    local SERVICES = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")
    
    local DIALOGUE_RF = nil
    pcall(function()
        DIALOGUE_RF = SERVICES:WaitForChild("ProximityService", 5):WaitForChild("RF", 3):WaitForChild("Dialogue", 3)
    end)
    
    local RUNCOMMAND_RF = nil
    pcall(function()
        RUNCOMMAND_RF = SERVICES:WaitForChild("DialogueService", 5):WaitForChild("RF", 3):WaitForChild("RunCommand", 3)
    end)
    
    local DIALOGUE_RE = nil
    pcall(function()
        DIALOGUE_RE = SERVICES:WaitForChild("DialogueService", 5):WaitForChild("RE", 3):WaitForChild("DialogueEvent", 3)
    end)
    
    if ProximityService then print("‚úÖ ProximityService Ready!") else warn("‚ö†Ô∏è ProximityService not found") end
    if DialogueService then print("‚úÖ DialogueService Ready!") else warn("‚ö†Ô∏è DialogueService not found") end
    if DIALOGUE_RF then print("‚úÖ Dialogue Remote Ready!") else warn("‚ö†Ô∏è Dialogue Remote not found") end
    if RUNCOMMAND_RF then print("‚úÖ RunCommand Remote Ready!") else warn("‚ö†Ô∏è RunCommand Remote not found") end
    
    ----------------------------------------------------------------
    -- STATE MANAGEMENT
    ----------------------------------------------------------------
    local State = {
        noclipConn = nil,
        moveConn = nil,
        bodyVelocity = nil,
        bodyGyro = nil,
    }
    
    local function cleanupState()
        if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
    end
    
    ----------------------------------------------------------------
    -- QUEST SYSTEM
    ----------------------------------------------------------------
    local function getQuestObjectives(questName)
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil, nil end
        
        local list = gui:FindFirstChild("Main") and gui.Main:FindFirstChild("Screen") 
                     and gui.Main.Screen:FindFirstChild("Quests") and gui.Main.Screen.Quests:FindFirstChild("List")
        if not list then return nil, nil end
        
        local questID = nil
        for _, child in ipairs(list:GetChildren()) do
            local id = string.match(child.Name, "^Introduction(%d+)Title$")
            if id and child:FindFirstChild("Frame") and child.Frame:FindFirstChild("TextLabel") then
                if child.Frame.TextLabel.Text == questName then
                    questID = id
                    break
                end
            end
        end
        
        if not questID then return nil, nil end
        
        local objList = list:FindFirstChild("Introduction" .. questID .. "List")
        return questID, objList
    end
    
    local function isObjectiveComplete(item)
        if not item then return false end
        local check = item:FindFirstChild("Main") and item.Main:FindFirstChild("Frame") and item.Main.Frame:FindFirstChild("Check")
        return check and check.Visible
    end
    
    local function getObjectiveText(item)
        local lbl = item:FindFirstChild("Main") and item.Main:FindFirstChild("TextLabel")
        return lbl and lbl.Text or ""
    end
    
    local function isQuest8StillActive()
        if not Quest8Active then return false end
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        if not questID or not objList then
            print("üõë Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' not found!")
            Quest8Active = false
            return false
        end
        
        return true
    end
    
    local function areAllObjectivesComplete()
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        if not questID or not objList then return true end
        
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                if not isObjectiveComplete(item) then
                    return false
                end
            end
        end
        
        return true
    end
    
    ----------------------------------------------------------------
    -- NPC HELPERS
    ----------------------------------------------------------------
    local function getNpcModel(name)
        local prox = Workspace:FindFirstChild("Proximity")
        return prox and prox:FindFirstChild(name)
    end
    
    local function getNpcPosition(npcModel)
        if not npcModel then return nil end
        
        local targetPart = npcModel.PrimaryPart or npcModel:FindFirstChildWhichIsA("BasePart")
        if not targetPart then return nil end
        
        return targetPart.Position
    end
    
    ----------------------------------------------------------------
    -- NOCLIP & MOVEMENT
    ----------------------------------------------------------------
    local function enableNoclip()
        if State.noclipConn then return end
        
        local char = player.Character
        if not char then return end
        
        State.noclipConn = RunService.Stepped:Connect(function()
            if not char or not char.Parent then
                if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
                return
            end
            
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end
    
    local function disableNoclip()
        if State.noclipConn then
            State.noclipConn:Disconnect()
            State.noclipConn = nil
        end
    end
    
    local function smoothMoveTo(targetPos, callback)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        enableNoclip()
        
        local bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Parent = hrp
        State.bodyVelocity = bv
        
        local bg = Instance.new("BodyGyro")
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.P = 10000
        bg.D = 500
        bg.Parent = hrp
        State.bodyGyro = bg
        
        print(string.format("   üöÄ Moving to (%.1f, %.1f, %.1f)...", targetPos.X, targetPos.Y, targetPos.Z))
        
        State.moveConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                if bv then bv:Destroy() end
                if bg then bg:Destroy() end
                State.bodyVelocity = nil
                State.bodyGyro = nil
                return
            end
            
            local currentPos = hrp.Position
            local direction = (targetPos - currentPos)
            local distance = direction.Magnitude
            
            if distance < QUEST_CONFIG.NPC_STOP_DISTANCE then
                print("   ‚úÖ Reached NPC!")
                
                bv.Velocity = Vector3.zero
                task.wait(0.1)
                
                bv:Destroy()
                bg:Destroy()
                State.bodyVelocity = nil
                State.bodyGyro = nil
                
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                
                if callback then callback() end
                return
            end
            
            local speed = math.min(QUEST_CONFIG.MOVE_SPEED, distance * 10)
            local velocity = direction.Unit * speed
            
            bv.Velocity = velocity
            bg.CFrame = CFrame.lookAt(currentPos, targetPos)
        end)
        
        return true
    end
    
    ----------------------------------------------------------------
    -- UI RESTORE
    ----------------------------------------------------------------
    local function forceRestoreUI()
        print("üîß Forcing UI Restore...")
        
        local char = player.Character
        if char then
            local status = char:FindFirstChild("Status")
            if status then
                for _, tag in ipairs(status:GetChildren()) do
                    if tag.Name == "DisableBackpack" or tag.Name == "NoMovement" or tag.Name == "Talking" then
                        pcall(function() tag:Destroy() end)
                        print("   - Removed Status Tag: " .. tag.Name)
                    end
                end
            end
            
            local humanoid = char:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = 16
                humanoid.JumpPower = 50
            end
        end
        
        local gui = player:FindFirstChild("PlayerGui")
        if gui then
            local dUI = gui:FindFirstChild("DialogueUI")
            if dUI then
                dUI.Enabled = false
                local bb = dUI:FindFirstChild("ResponseBillboard")
                if bb then bb.Visible = false end
            end
            
            local main = gui:FindFirstChild("Main")
            if main then 
                main.Enabled = true 
                print("   - Main UI Restored")
            end
            
            local backpack = gui:FindFirstChild("BackpackGui")
            if backpack then 
                backpack.Enabled = true 
                print("   - Backpack Restored")
            end
            
            local compass = gui:FindFirstChild("Compass")
            if compass then compass.Enabled = true end
            
            local mobile = gui:FindFirstChild("MobileButtons")
            if mobile then mobile.Enabled = true end
        end
        
        local cam = Workspace.CurrentCamera
        if cam then
            cam.CameraType = Enum.CameraType.Custom
            cam.FieldOfView = 70
        end
        
        if DIALOGUE_RE then
            pcall(function() DIALOGUE_RE:FireServer("Closed") end)
        end
        
        print("‚úÖ UI Restore Complete")
    end
    
    ----------------------------------------------------------------
    -- DIALOGUE SYSTEM
    ----------------------------------------------------------------
    local function startDialogue(npcModel)
        if not DIALOGUE_RF then
            warn("   ‚ùå Dialogue Remote not available!")
            return false
        end
        
        print("üìû Starting Dialogue with " .. QUEST_CONFIG.NPC_NAME .. "...")
        
        local success = pcall(function()
            DIALOGUE_RF:InvokeServer(npcModel)
        end)
        
        if success then
            print("   ‚úÖ Dialogue started!")
            return true
        else
            warn("   ‚ùå Failed to start dialogue")
            return false
        end
    end
    
    local function selectQuestOption(optionName)
        if not RUNCOMMAND_RF then
            warn("   ‚ùå RunCommand Remote not available!")
            return false
        end
        
        print("‚úÖ Selecting Option: " .. optionName)
        
        local success = pcall(function()
            RUNCOMMAND_RF:InvokeServer(optionName)
        end)
        
        if success then
            print("   ‚úÖ Option selected!")
            return true
        else
            warn("   ‚ùå Failed to select option")
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- MAIN QUEST EXECUTION
    ----------------------------------------------------------------
    local function doReportToSenseiMoro()
        print("üìã Objective: Report to Sensei Moro...")
        
        local npcModel = getNpcModel(QUEST_CONFIG.NPC_NAME)
        if not npcModel then
            warn("   ‚ùå NPC not found: " .. QUEST_CONFIG.NPC_NAME)
            return false
        end
        
        local targetPos = getNpcPosition(npcModel)
        if not targetPos then
            warn("   ‚ùå Cannot get NPC position!")
            return false
        end
        
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp then
            local currentDist = (targetPos - hrp.Position).Magnitude
            print(string.format("   üö∂ Moving to %s at (%.1f, %.1f, %.1f) (%.1f studs away)...", 
                QUEST_CONFIG.NPC_NAME, targetPos.X, targetPos.Y, targetPos.Z, currentDist))
        end
        
        local moveComplete = false
        smoothMoveTo(targetPos, function()
            moveComplete = true
        end)
        
        local timeout = 20
        local startTime = tick()
        while not moveComplete and tick() - startTime < timeout do
            task.wait(0.1)
        end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        if not moveComplete then
            warn("   ‚ùå Failed to reach NPC (timeout)")
            return false
        end
        
        print("\nüìû Interacting with Sensei Moro...")
        task.wait(0.5)
        
        local dialogueSuccess = startDialogue(npcModel)
        if not dialogueSuccess then
            warn("   ‚ùå Dialogue failed!")
            return false
        end
        
        print("   ‚è≥ Waiting for dialogue to open...")
        task.wait(1.5)
        
        local optionSuccess = selectQuestOption(QUEST_CONFIG.QUEST_OPTION_ARG)
        if not optionSuccess then
            warn("   ‚ùå Option selection failed!")
        end
        
        print("   ‚è≥ Processing...")
        task.wait(1)
        
        forceRestoreUI()
        
        print("   ‚úÖ Dialogue complete!")
        return true
    end
    
    ----------------------------------------------------------------
    -- SMART QUEST RUNNER
    ----------------------------------------------------------------
    local function RunQuest8()
        print(string.rep("=", 50))
        print("üöÄ QUEST 8: " .. QUEST_CONFIG.QUEST_NAME)
        print("üéØ Objective: Report to Sensei Moro")
        print(string.rep("=", 50))
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        
        if not questID then
            warn("‚ùå Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' not found!")
            Quest8Active = false
            cleanupState()
            disableNoclip()
            return
        end
        
        print("‚úÖ Quest found (ID: " .. questID .. ")")
        
        print("\n" .. string.rep("=", 50))
        print("‚öôÔ∏è  Quest Objectives:")
        local objectiveCount = 0
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                objectiveCount = objectiveCount + 1
                local text = getObjectiveText(item)
                local complete = isObjectiveComplete(item)
                print(string.format("   %d. %s [%s]", objectiveCount, text, complete and "‚úÖ" or "‚è≥"))
            end
        end
        print(string.rep("=", 50))
        
        if areAllObjectivesComplete() then
            print("\n‚úÖ Quest already complete!")
            cleanupState()
            disableNoclip()
            return
        end
        
        local maxAttempts = 3
        local attempt = 0
        
        while isQuest8StillActive() and not areAllObjectivesComplete() and attempt < maxAttempts do
            attempt = attempt + 1
            print(string.format("\nüîÑ Attempt #%d", attempt))
            
            local success = doReportToSenseiMoro()
            
            if success then
                print("   ‚úÖ Reporting complete!")
                task.wait(2)
                
                if areAllObjectivesComplete() then
                    print("\nüéâ All objectives complete!")
                    break
                else
                    print("   ‚ö†Ô∏è Quest not marked complete, retrying...")
                    task.wait(2)
                end
            else
                warn("   ‚ùå Reporting failed, retrying in 3s...")
                task.wait(3)
            end
        end
        
        task.wait(1)
        
        if areAllObjectivesComplete() then
            print("\n" .. string.rep("=", 50))
            print("‚úÖ Quest 8 Complete!")
            print(string.rep("=", 50))
        else
            warn("\n" .. string.rep("=", 50))
            warn("‚ö†Ô∏è Quest 8 incomplete after " .. attempt .. " attempts")
            warn(string.rep("=", 50))
        end
        
        Quest8Active = false
        cleanupState()
        disableNoclip()
    end
    
    ----------------------------------------------------------------
    -- START
    ----------------------------------------------------------------
    RunQuest8()
end

----------------------------------------------------------------
-- QUEST 9 ORIGINAL (from 9.lua)
----------------------------------------------------------------
local function RunQuest09()
    -- QUEST 9: "The First Upgrade!" (Auto Enhance to +3)
    -- ‚úÖ ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á Move ‡πÑ‡∏õ‡∏´‡∏≤ NPC
    -- ‚úÖ ‡πÉ‡∏ä‡πâ Remote EnhanceEquipment ‡∏ï‡∏£‡∏á‡πÜ
    -- ‚úÖ Loop Enhance ‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤ Quest ‡∏à‡∏∞‡πÄ‡∏™‡∏£‡πá‡∏à
    
    
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    ----------------------------------------------------------------
    -- CONFIG
    ----------------------------------------------------------------
    local Quest9Active = true
    
    local QUEST_CONFIG = {
        QUEST_NAME = "The First Upgrade",
        TARGET_UPGRADE_LEVEL = 3,  -- ‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏µ‡∏ö‡∏ß‡∏Å‡∏ñ‡∏∂‡∏á +3
        ENHANCE_DELAY = 1.0,       -- ‡∏£‡∏≠ 1 ‡∏ß‡∏¥ ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á Enhance ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏£‡∏±‡πâ‡∏á
        MAX_ENHANCE_ATTEMPTS = 50, -- ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏•‡∏π‡∏õ‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏à‡∏ö
    }
    
    ----------------------------------------------------------------
    -- KNIT SETUP
    ----------------------------------------------------------------
    local KnitPackage = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit")
    local Knit = require(KnitPackage)
    
    if not Knit.OnStart then 
        pcall(function() Knit.Start():await() end)
    end
    
    local PlayerController = nil
    local EnhanceService = nil
    
    pcall(function()
        PlayerController = Knit.GetController("PlayerController")
        EnhanceService = Knit.GetService("EnhanceService")
    end)
    
    local SERVICES = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")
    
    local ENHANCE_RF = nil
    pcall(function()
        ENHANCE_RF = SERVICES:WaitForChild("EnhanceService", 5):WaitForChild("RF", 3):WaitForChild("EnhanceEquipment", 3)
    end)
    
    local FIND_EQUIPMENT_RF = nil
    pcall(function()
        FIND_EQUIPMENT_RF = SERVICES:WaitForChild("EnhanceService", 5):WaitForChild("RF", 3):WaitForChild("FindEquipmentByGUID", 3)
    end)
    
    if PlayerController then print("‚úÖ PlayerController Ready!") else warn("‚ö†Ô∏è PlayerController not found") end
    if EnhanceService then print("‚úÖ EnhanceService Ready!") else warn("‚ö†Ô∏è EnhanceService not found") end
    if ENHANCE_RF then print("‚úÖ Enhance Remote Ready!") else warn("‚ö†Ô∏è Enhance Remote not found") end
    if FIND_EQUIPMENT_RF then print("‚úÖ FindEquipment Remote Ready!") else warn("‚ö†Ô∏è FindEquipment Remote not found") end
    
    ----------------------------------------------------------------
    -- QUEST SYSTEM
    ----------------------------------------------------------------
    local function getQuestObjectives(questName)
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil, nil end
        
        local list = gui:FindFirstChild("Main") and gui.Main:FindFirstChild("Screen") 
                     and gui.Main.Screen:FindFirstChild("Quests") and gui.Main.Screen.Quests:FindFirstChild("List")
        if not list then return nil, nil end
        
        local questID = nil
        for _, child in ipairs(list:GetChildren()) do
            local id = string.match(child.Name, "^Introduction(%d+)Title$")
            if id and child:FindFirstChild("Frame") and child.Frame:FindFirstChild("TextLabel") then
                if child.Frame.TextLabel.Text == questName then
                    questID = id
                    break
                end
            end
        end
        
        if not questID then return nil, nil end
        
        local objList = list:FindFirstChild("Introduction" .. questID .. "List")
        return questID, objList
    end
    
    local function isObjectiveComplete(item)
        if not item then return false end
        local check = item:FindFirstChild("Main") and item.Main:FindFirstChild("Frame") and item.Main.Frame:FindFirstChild("Check")
        return check and check.Visible
    end
    
    local function getObjectiveText(item)
        local lbl = item:FindFirstChild("Main") and item.Main:FindFirstChild("TextLabel")
        return lbl and lbl.Text or ""
    end
    
    local function isQuest9StillActive()
        if not Quest9Active then return false end
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        if not questID or not objList then
            print("üõë Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' not found!")
            Quest9Active = false
            return false
        end
        
        return true
    end
    
    local function areAllObjectivesComplete()
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        if not questID or not objList then return true end
        
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                if not isObjectiveComplete(item) then
                    return false
                end
            end
        end
        
        return true
    end
    
    ----------------------------------------------------------------
    -- EQUIPMENT HELPERS
    ----------------------------------------------------------------
    local function getPlayerEquipments()
        if not PlayerController or not PlayerController.Replica then
            warn("   ‚ö†Ô∏è Replica not available!")
            return {}
        end
        
        local replica = PlayerController.Replica
        
        if not replica.Data or not replica.Data.Inventory or not replica.Data.Inventory.Equipments then
            warn("   ‚ö†Ô∏è Equipments not found in Replica!")
            return {}
        end
        
        local equipments = replica.Data.Inventory.Equipments
        local items = {}
        
        for id, item in pairs(equipments) do
            if type(item) == "table" and item.Type and item.GUID then
                -- ‡∏´‡πâ‡∏≤‡∏° Pickaxe
                if not string.find(item.Type, "Pickaxe") then
                    table.insert(items, {
                        ID = id,
                        GUID = item.GUID,
                        Type = item.Type,
                        Name = item.Name or item.Type,
                        Upgrade = item.Upgrade or 0,
                        Quality = item.Quality or 0,
                        Dmg = item.Dmg or 0,
                    })
                end
            end
        end
        
        return items
    end
    
    local function findLowestUpgradeItem()
        local items = getPlayerEquipments()
        
        if #items == 0 then
            return nil, "No enhanceable items found!"
        end
        
        -- ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å Upgrade ‡∏ô‡πâ‡∏≠‡∏¢‡∏™‡∏∏‡∏î -> ‡∏°‡∏≤‡∏Å‡∏™‡∏∏‡∏î
        table.sort(items, function(a, b)
            if a.Upgrade ~= b.Upgrade then
                return a.Upgrade < b.Upgrade
            else
                -- ‡∏ñ‡πâ‡∏≤ Upgrade ‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ô ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Dmg ‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î
                return a.Dmg < b.Dmg
            end
        end)
        
        return items[1], nil
    end
    
    local function getItemCurrentUpgrade(guid)
        if not FIND_EQUIPMENT_RF then return nil end
        
        local success, result = pcall(function()
            return FIND_EQUIPMENT_RF:InvokeServer(guid)
        end)
        
        if success and result and type(result) == "table" then
            return result.Upgrade or 0
        end
        
        return nil
    end
    
    ----------------------------------------------------------------
    -- ENHANCE SYSTEM
    ----------------------------------------------------------------
    local function enhanceItem(guid)
        if not ENHANCE_RF then
            warn("   ‚ùå Enhance Remote not available!")
            return false, "Remote not available"
        end
        
        local success, result = pcall(function()
            return ENHANCE_RF:InvokeServer(guid)
        end)
        
        if success then
            -- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            if result == true or (type(result) == "table" and result.Success) then
                return true, "Success"
            elseif type(result) == "table" and result.Error then
                return false, result.Error
            else
                return false, "Unknown result"
            end
        else
            return false, tostring(result)
        end
    end
    
    local function printItemInfo(item)
        print(string.format("   üéØ Selected Item: %s", item.Name))
        print(string.format("      - Type: %s", item.Type))
        print(string.format("      - Current Upgrade: +%d", item.Upgrade))
        print(string.format("      - Dmg: %.1f", item.Dmg))
        print(string.format("      - Quality: %.1f", item.Quality))
        print(string.format("      - GUID: %s", item.GUID))
    end
    
    ----------------------------------------------------------------
    -- MAIN QUEST EXECUTION
    ----------------------------------------------------------------
    local function doEnhanceToPlus3()
        print("‚ö° Objective: Enhance Item to +3...")
        
        local targetItem, errorMsg = findLowestUpgradeItem()
        
        if not targetItem then
            warn("   ‚ùå ERROR: " .. errorMsg)
            return false
        end
        
        printItemInfo(targetItem)
        
        if targetItem.Upgrade >= QUEST_CONFIG.TARGET_UPGRADE_LEVEL then
            print(string.format("   ‚úÖ Item already at +%d or higher!", targetItem.Upgrade))
            return true
        end
        
        print(string.format("\n   üî® Starting Enhancement Loop (Target: +%d)...\n", QUEST_CONFIG.TARGET_UPGRADE_LEVEL))
        
        local enhanceCount = 0
        local successCount = 0
        local failCount = 0
        
        while isQuest9StillActive() and not areAllObjectivesComplete() do
            enhanceCount = enhanceCount + 1
            
            if enhanceCount > QUEST_CONFIG.MAX_ENHANCE_ATTEMPTS then
                warn(string.format("   ‚ö†Ô∏è Max attempts reached (%d)! Stopping...", QUEST_CONFIG.MAX_ENHANCE_ATTEMPTS))
                break
            end
            
            -- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            local currentUpgrade = getItemCurrentUpgrade(targetItem.GUID)
            
            if currentUpgrade then
                print(string.format("   üìä Current Status: +%d / +%d", currentUpgrade, QUEST_CONFIG.TARGET_UPGRADE_LEVEL))
                
                if currentUpgrade >= QUEST_CONFIG.TARGET_UPGRADE_LEVEL then
                    print(string.format("   üéâ Target reached! Item is now +%d", currentUpgrade))
                    break
                end
            end
            
            -- ‡∏•‡∏≠‡∏á Enhance
            print(string.format("   ‚ö° Enhance Attempt #%d...", enhanceCount))
            
            local success, result = enhanceItem(targetItem.GUID)
            
            if success then
                successCount = successCount + 1
                print(string.format("      ‚úÖ Enhancement SUCCESS! (+%d successful)", successCount))
            else
                failCount = failCount + 1
                print(string.format("      ‚ùå Enhancement FAILED! (%s) (+%d failed)", result, failCount))
            end
            
            -- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡πÄ‡∏Ñ‡∏ß‡∏™‡πÄ‡∏™‡∏£‡πá‡∏à‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
            task.wait(0.5)
            if areAllObjectivesComplete() then
                print("\n   üéâ Quest objective completed!")
                break
            end
            
            -- ‡∏£‡∏≠‡∏Å‡πà‡∏≠‡∏ô Enhance ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ï‡πà‡∏≠‡πÑ‡∏õ
            print(string.format("   ‚è∏Ô∏è  Waiting %.1fs before next attempt...\n", QUEST_CONFIG.ENHANCE_DELAY))
            task.wait(QUEST_CONFIG.ENHANCE_DELAY)
        end
        
        print("\n   üìä Enhancement Summary:")
        print(string.format("      - Total Attempts: %d", enhanceCount))
        print(string.format("      - Successful: %d", successCount))
        print(string.format("      - Failed: %d", failCount))
        
        -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢
        local finalUpgrade = getItemCurrentUpgrade(targetItem.GUID)
        if finalUpgrade then
            print(string.format("      - Final Upgrade: +%d", finalUpgrade))
            
            if finalUpgrade >= QUEST_CONFIG.TARGET_UPGRADE_LEVEL then
                print("   ‚úÖ Enhancement complete!")
                return true
            else
                warn(string.format("   ‚ö†Ô∏è Failed to reach +%d (current: +%d)", QUEST_CONFIG.TARGET_UPGRADE_LEVEL, finalUpgrade))
                return false
            end
        end
        
        return false
    end
    
    ----------------------------------------------------------------
    -- SMART QUEST RUNNER
    ----------------------------------------------------------------
    local function RunQuest9()
        print(string.rep("=", 50))
        print("üöÄ QUEST 9: " .. QUEST_CONFIG.QUEST_NAME)
        print("üéØ Objective: Enhance Item to +" .. QUEST_CONFIG.TARGET_UPGRADE_LEVEL)
        print("‚úÖ Strategy: Remote-based Enhancement (No Movement)")
        print(string.rep("=", 50))
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        
        if not questID then
            warn("‚ùå Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' not found!")
            Quest9Active = false
            return
        end
        
        print("‚úÖ Quest found (ID: " .. questID .. ")")
        
        print("\n" .. string.rep("=", 50))
        print("‚öôÔ∏è  Quest Objectives:")
        local objectiveCount = 0
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                objectiveCount = objectiveCount + 1
                local text = getObjectiveText(item)
                local complete = isObjectiveComplete(item)
                print(string.format("   %d. %s [%s]", objectiveCount, text, complete and "‚úÖ" or "‚è≥"))
            end
        end
        print(string.rep("=", 50))
        
        if areAllObjectivesComplete() then
            print("\n‚úÖ Quest already complete!")
            return
        end
        
        print("\n" .. string.rep("=", 50))
        print("‚ö° Starting Enhancement Process...")
        print(string.rep("=", 50))
        
        local success = doEnhanceToPlus3()
        
        task.wait(1)
        
        if areAllObjectivesComplete() then
            print("\n" .. string.rep("=", 50))
            print("‚úÖ Quest 9 Complete!")
            print(string.rep("=", 50))
        else
            if success then
                print("\n   ‚ö†Ô∏è Enhancement complete but quest not marked done")
                print("   üí° Try checking quest status manually")
            else
                warn("\n" .. string.rep("=", 50))
                warn("‚ö†Ô∏è Quest 9 incomplete - Enhancement failed")
                warn(string.rep("=", 50))
            end
        end
        
        Quest9Active = false
    end
    
    ----------------------------------------------------------------
    -- START
    ----------------------------------------------------------------
    RunQuest9()
end

----------------------------------------------------------------
-- QUEST 10 ORIGINAL (from 10.lua)
----------------------------------------------------------------
local function RunQuest10()
    -- QUEST 10: "Runes of Power!" (FIXED - ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ Rune ‡∏à‡∏≤‡∏Å Stash UI)
    -- ‚úÖ ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ Rune ‡∏à‡∏≤‡∏Å PlayerGui.Menu.Frame.Frame.Menus.Stash.Background
    -- ‚úÖ ‡∏´‡∏≤ ItemName = "Flame Spark" ‡∏´‡∏£‡∏∑‡∏≠ "Blast Chip"
    -- ‚úÖ ‡πÄ‡∏≠‡∏≤ GUID ‡∏°‡∏≤‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ Attach Rune
    -- ‚úÖ ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡∏¥‡∏î Rune UI ‡∏Å‡πà‡∏≠‡∏ô!
    
    
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Workspace = game:GetService("Workspace")
    
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    ----------------------------------------------------------------
    -- CONFIG
    ----------------------------------------------------------------
    local Quest10Active = true
    local DEBUG_MODE = true  -- ‚úÖ ‡πÄ‡∏õ‡∏¥‡∏î Debug Mode
    
    local QUEST_CONFIG = {
        QUEST_NAME = "Runes of Power",
        NPC_NAME = "Runemaker",
        NPC_POSITION = Vector3.new(-271.7, 20.3, 141.9),
        MOVE_SPEED = 20,
        NPC_STOP_DISTANCE = 5,
        
        -- Rune ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ (‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏±‡∏ô‡πÉ‡∏î‡∏≠‡∏±‡∏ô‡∏´‡∏ô‡∏∂‡πà‡∏á)
        ALLOWED_RUNE_NAMES = {
            "Flame Spark",
            "Blast Chip",
        },
    }
    
    ----------------------------------------------------------------
    -- KNIT SETUP
    ----------------------------------------------------------------
    local KnitPackage = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit")
    local Knit = require(KnitPackage)
    
    if not Knit.OnStart then 
        pcall(function() Knit.Start():await() end)
    end
    
    local PlayerController = nil
    local ProximityService = nil
    local RuneService = nil
    
    pcall(function()
        PlayerController = Knit.GetController("PlayerController")
        ProximityService = Knit.GetService("ProximityService")
        RuneService = Knit.GetService("RuneService")
    end)
    
    local SERVICES = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")
    
    local PURCHASE_ATTACH_RF = nil
    pcall(function()
        PURCHASE_ATTACH_RF = SERVICES:WaitForChild("RuneService", 5):WaitForChild("RF", 3):WaitForChild("PurchaseAttach", 3)
    end)
    
    local GET_PRICE_INFO_RF = nil
    pcall(function()
        GET_PRICE_INFO_RF = SERVICES:WaitForChild("RuneService", 5):WaitForChild("RF", 3):WaitForChild("GetPriceInfo", 3)
    end)
    
    if PlayerController then print("‚úÖ PlayerController Ready!") else warn("‚ö†Ô∏è PlayerController not found") end
    if ProximityService then print("‚úÖ ProximityService Ready!") else warn("‚ö†Ô∏è ProximityService not found") end
    if RuneService then print("‚úÖ RuneService Ready!") else warn("‚ö†Ô∏è RuneService not found") end
    if PURCHASE_ATTACH_RF then print("‚úÖ PurchaseAttach Remote Ready!") else warn("‚ö†Ô∏è PurchaseAttach Remote not found") end
    
    ----------------------------------------------------------------
    -- STATE MANAGEMENT
    ----------------------------------------------------------------
    local State = {
        noclipConn = nil,
        moveConn = nil,
        bodyVelocity = nil,
        bodyGyro = nil,
    }
    
    local function cleanupState()
        if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
    end
    
    ----------------------------------------------------------------
    -- QUEST SYSTEM
    ----------------------------------------------------------------
    local function getQuestObjectives(questName)
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil, nil end
        
        local list = gui:FindFirstChild("Main") and gui.Main:FindFirstChild("Screen") 
                     and gui.Main.Screen:FindFirstChild("Quests") and gui.Main.Screen.Quests:FindFirstChild("List")
        if not list then return nil, nil end
        
        local questID = nil
        for _, child in ipairs(list:GetChildren()) do
            local id = string.match(child.Name, "^Introduction(%d+)Title$")
            if id and child:FindFirstChild("Frame") and child.Frame:FindFirstChild("TextLabel") then
                if child.Frame.TextLabel.Text == questName then
                    questID = id
                    break
                end
            end
        end
        
        if not questID then return nil, nil end
        
        local objList = list:FindFirstChild("Introduction" .. questID .. "List")
        return questID, objList
    end
    
    local function isObjectiveComplete(item)
        if not item then return false end
        local check = item:FindFirstChild("Main") and item.Main:FindFirstChild("Frame") and item.Main.Frame:FindFirstChild("Check")
        return check and check.Visible
    end
    
    local function getObjectiveText(item)
        local lbl = item:FindFirstChild("Main") and item.Main:FindFirstChild("TextLabel")
        return lbl and lbl.Text or ""
    end
    
    local function isQuest10StillActive()
        if not Quest10Active then return false end
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        if not questID or not objList then
            print("üõë Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' not found!")
            Quest10Active = false
            return false
        end
        
        return true
    end
    
    local function areAllObjectivesComplete()
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        if not questID or not objList then return true end
        
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                if not isObjectiveComplete(item) then
                    return false
                end
            end
        end
        
        return true
    end
    
    ----------------------------------------------------------------
    -- EQUIPMENT HELPERS
    ----------------------------------------------------------------
    local function getEquippedWeaponGUID()
        print("   üîç Checking equipped items from UI...")
        
        local menuUI = playerGui:FindFirstChild("Menu")
                       and playerGui.Menu:FindFirstChild("Frame")
                       and playerGui.Menu.Frame:FindFirstChild("Frame")
                       and playerGui.Menu.Frame.Frame:FindFirstChild("Menus")
                       and playerGui.Menu.Frame.Frame.Menus:FindFirstChild("Tools")
                       and playerGui.Menu.Frame.Frame.Menus.Tools:FindFirstChild("Frame")
        
        if menuUI then
            for _, child in ipairs(menuUI:GetChildren()) do
                if string.match(child.Name, "^%x+%-%x+%-%x+%-%x+%-%x+$") then
                    local equipButton = child:FindFirstChild("Equip")
                    local equipLabel = equipButton and equipButton:FindFirstChild("TextLabel")
                    
                    if equipLabel and equipLabel:IsA("TextLabel") then
                        local isEquipped = (equipLabel.Text == "Unequip")
                        
                        if PlayerController and PlayerController.Replica then
                            local replica = PlayerController.Replica
                            if replica.Data and replica.Data.Inventory and replica.Data.Inventory.Equipments then
                                for id, item in pairs(replica.Data.Inventory.Equipments) do
                                    if type(item) == "table" and item.GUID == child.Name then
                                        local isPickaxe = string.find(item.Type or "", "Pickaxe")
                                        
                                        if DEBUG_MODE then
                                            print(string.format("      - %s: UI_Equipped=%s, Pickaxe=%s, GUID=%s", 
                                                item.Type or "Unknown", 
                                                tostring(isEquipped), 
                                                tostring(isPickaxe), 
                                                item.GUID))
                                        end
                                        
                                        if not isPickaxe and isEquipped then
                                            return item.GUID, item.Type
                                        end
                                        
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
            end
        else
            warn("   ‚ö†Ô∏è Menu UI not found!")
        end
        
        print("   üîç Fallback: Checking from Replica...")
        
        if not PlayerController or not PlayerController.Replica then
            warn("   ‚ö†Ô∏è PlayerController/Replica not available!")
            return nil
        end
        
        local replica = PlayerController.Replica
        if not replica.Data or not replica.Data.Inventory or not replica.Data.Inventory.Equipments then
            warn("   ‚ö†Ô∏è Equipments not found in Replica!")
            return nil
        end
        
        local equipments = replica.Data.Inventory.Equipments
        
        for id, item in pairs(equipments) do
            if type(item) == "table" and item.Type and item.GUID then
                local isPickaxe = string.find(item.Type, "Pickaxe")
                local isEquipped = (item.Equipped == true)
                
                if DEBUG_MODE then
                    print(string.format("      - %s: Replica_Equipped=%s, Pickaxe=%s, GUID=%s", 
                        item.Type, tostring(isEquipped), tostring(isPickaxe), item.GUID))
                end
                
                if not isPickaxe and isEquipped then
                    return item.GUID, item.Type
                end
            end
        end
        
        warn("   ‚ùå No equipped weapon found (excluding Pickaxe)!")
        return nil
    end
    
    ----------------------------------------------------------------
    -- RUNE HELPERS (FIXED - ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏à‡∏≤‡∏Å Stash UI)
    ----------------------------------------------------------------
    local function getRunesFromStash()
        local runes = {}
        
        print("   üîç Searching for Runes in Stash UI...")
        
        -- Path: PlayerGui.Menu.Frame.Frame.Menus.Stash.Background
        local stashBackground = playerGui:FindFirstChild("Menu")
                               and playerGui.Menu:FindFirstChild("Frame")
                               and playerGui.Menu.Frame:FindFirstChild("Frame")
                               and playerGui.Menu.Frame.Frame:FindFirstChild("Menus")
                               and playerGui.Menu.Frame.Frame.Menus:FindFirstChild("Stash")
                               and playerGui.Menu.Frame.Frame.Menus.Stash:FindFirstChild("Background")
        
        if not stashBackground then
            warn("   ‚ùå Stash Background not found!")
            warn("   üí° Path: PlayerGui.Menu.Frame.Frame.Menus.Stash.Background")
            return runes
        end
        
        print("   ‚úÖ Found Stash Background!")
        print(string.format("   üìä Total children: %d", #stashBackground:GetChildren()))
        
        -- ‡∏ß‡∏ô loop ‡∏´‡∏≤ GUID ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        for _, child in ipairs(stashBackground:GetChildren()) do
            -- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô GUID pattern (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)
            if string.match(child.Name, "^%x+%-%x+%-%x+%-%x+%-%x+$") then
                local main = child:FindFirstChild("Main")
                if main then
                    local itemNameLabel = main:FindFirstChild("ItemName")
                    if itemNameLabel and itemNameLabel:IsA("TextLabel") then
                        local itemName = itemNameLabel.Text
                        local itemGUID = child.Name
                        
                        if DEBUG_MODE then
                            print(string.format("      - Found Item: %s (GUID: %s)", itemName, itemGUID))
                        end
                        
                        table.insert(runes, {
                            GUID = itemGUID,
                            Name = itemName,
                            Frame = child,
                        })
                    end
                end
            end
        end
        
        print(string.format("   üìä Total items found in Stash: %d", #runes))
        
        return runes
    end
    
    local function findAllowedRuneFromStash()
        local allItems = getRunesFromStash()
        
        if #allItems == 0 then
            return nil, "No items found in Stash!"
        end
        
        print(string.format("   üìã Found %d item(s) in Stash:", #allItems))
        
        -- ‡∏Å‡∏£‡∏≠‡∏á Rune ‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö ALLOWED_RUNE_NAMES
        local allowedRunes = {}
        
        for _, item in ipairs(allItems) do
            for _, allowedName in ipairs(QUEST_CONFIG.ALLOWED_RUNE_NAMES) do
                if item.Name == allowedName then
                    table.insert(allowedRunes, item)
                    print(string.format("      ‚úÖ Matched: %s (GUID: %s)", item.Name, item.GUID))
                end
            end
        end
        
        if #allowedRunes == 0 then
            warn(string.format("   ‚ùå No allowed runes found!"))
            warn(string.format("   üí° Looking for: %s", table.concat(QUEST_CONFIG.ALLOWED_RUNE_NAMES, ", ")))
            
            -- Debug: ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ
            if DEBUG_MODE then
                print("   üìã Available items in Stash:")
                for i, item in ipairs(allItems) do
                    print(string.format("      %d. %s (GUID: %s)", i, item.Name, item.GUID))
                end
            end
            
            return nil, string.format("No allowed runes found! (Looking for: %s)", table.concat(QUEST_CONFIG.ALLOWED_RUNE_NAMES, ", "))
        end
        
        -- ‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏•‡∏∑‡∏≠‡∏Å 1 ‡∏≠‡∏±‡∏ô
        local selectedRune = allowedRunes[math.random(1, #allowedRunes)]
        
        return selectedRune, nil
    end
    
    ----------------------------------------------------------------
    -- NOCLIP & MOVEMENT
    ----------------------------------------------------------------
    local function enableNoclip()
        if State.noclipConn then return end
        
        local char = player.Character
        if not char then return end
        
        State.noclipConn = RunService.Stepped:Connect(function()
            if not char or not char.Parent then
                if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
                return
            end
            
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end
    
    local function disableNoclip()
        if State.noclipConn then
            State.noclipConn:Disconnect()
            State.noclipConn = nil
        end
    end
    
    local function smoothMoveTo(targetPos, callback)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        enableNoclip()
        
        local bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Parent = hrp
        State.bodyVelocity = bv
        
        local bg = Instance.new("BodyGyro")
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.P = 10000
        bg.D = 500
        bg.Parent = hrp
        State.bodyGyro = bg
        
        print(string.format("   üöÄ Moving to (%.1f, %.1f, %.1f)...", targetPos.X, targetPos.Y, targetPos.Z))
        
        State.moveConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                if bv then bv:Destroy() end
                if bg then bg:Destroy() end
                State.bodyVelocity = nil
                State.bodyGyro = nil
                return
            end
            
            local currentPos = hrp.Position
            local direction = (targetPos - currentPos)
            local distance = direction.Magnitude
            
            if distance < QUEST_CONFIG.NPC_STOP_DISTANCE then
                print("   ‚úÖ Reached NPC!")
                
                bv.Velocity = Vector3.zero
                task.wait(0.1)
                
                bv:Destroy()
                bg:Destroy()
                State.bodyVelocity = nil
                State.bodyGyro = nil
                
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                
                if callback then callback() end
                return
            end
            
            local speed = math.min(QUEST_CONFIG.MOVE_SPEED, distance * 10)
            local velocity = direction.Unit * speed
            
            bv.Velocity = velocity
            bg.CFrame = CFrame.lookAt(currentPos, targetPos)
        end)
        
        return true
    end
    
    ----------------------------------------------------------------
    -- NPC INTERACTION
    ----------------------------------------------------------------
    local function getNpcModel(name)
        local prox = Workspace:FindFirstChild("Proximity")
        return prox and prox:FindFirstChild(name)
    end
    
    ----------------------------------------------------------------
    -- RUNE ATTACHMENT
    ----------------------------------------------------------------
    local function attachRuneToWeapon(weaponGUID, runeGUID)
        if not PURCHASE_ATTACH_RF then
            warn("   ‚ùå PurchaseAttach Remote not available!")
            return false
        end
        
        print(string.format("üîÆ Attaching Rune to Weapon..."))
        print(string.format("   - Weapon GUID: %s", weaponGUID))
        print(string.format("   - Rune GUID: %s", runeGUID))
        
        -- ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å GetPriceInfo ‡∏Å‡πà‡∏≠‡∏ô (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
        if GET_PRICE_INFO_RF then
            local success = pcall(function()
                GET_PRICE_INFO_RF:InvokeServer(weaponGUID, runeGUID, "Attach")
            end)
            
            if success then
                print("   ‚úÖ GetPriceInfo called")
            end
            
            task.wait(0.3)
        end
        
        -- ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å PurchaseAttach
        local success, result = pcall(function()
            return PURCHASE_ATTACH_RF:InvokeServer(weaponGUID, runeGUID)
        end)
        
        if success then
            print("   ‚úÖ Rune attached successfully!")
            return true
        else
            warn("   ‚ùå Failed to attach rune: " .. tostring(result))
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- MAIN QUEST EXECUTION
    ----------------------------------------------------------------
    local function doAttachRune()
        print("üîÆ Objective: Attach Rune to Weapon...")
        
        -- 1. Move ‡πÑ‡∏õ‡∏´‡∏≤ NPC
        local npcModel = getNpcModel(QUEST_CONFIG.NPC_NAME)
        if not npcModel then
            warn("   ‚ùå NPC not found: " .. QUEST_CONFIG.NPC_NAME)
            return false
        end
        
        local npcPos = QUEST_CONFIG.NPC_POSITION
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        
        if hrp then
            local currentDist = (npcPos - hrp.Position).Magnitude
            print(string.format("   üö∂ Moving to %s at (%.1f, %.1f, %.1f) (%.1f studs away)...", 
                QUEST_CONFIG.NPC_NAME, npcPos.X, npcPos.Y, npcPos.Z, currentDist))
        end
        
        local moveComplete = false
        smoothMoveTo(npcPos, function()
            moveComplete = true
        end)
        
        local timeout = 20
        local startTime = tick()
        while not moveComplete and tick() - startTime < timeout do
            task.wait(0.1)
        end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        if not moveComplete then
            warn("   ‚ö†Ô∏è Failed to reach NPC")
            return false
        end
        
        print("   ‚úÖ Reached NPC!")
        task.wait(1)
        
        -- 2. ‡∏´‡∏≤ Equipped Weapon
        print("\nüîç Finding equipped weapon...")
        local weaponGUID, weaponType = getEquippedWeaponGUID()
        
        if not weaponGUID then
            warn("   ‚ùå No weapon equipped!")
            warn("   üí° Please equip a weapon (not pickaxe) and try again")
            return false
        end
        
        print(string.format("   ‚úÖ Found equipped weapon: %s (GUID: %s)", weaponType or "Unknown", weaponGUID))
        
        -- 3. ‡∏´‡∏≤ Rune ‡∏à‡∏≤‡∏Å Stash UI
        print("\nüîç Finding suitable rune from Stash UI...")
        local selectedRune, errorMsg = findAllowedRuneFromStash()
        
        if not selectedRune then
            warn("   ‚ùå ERROR: " .. errorMsg)
            return false
        end
        
        print(string.format("   ‚úÖ Selected Rune: %s (GUID: %s)", selectedRune.Name, selectedRune.GUID))
        
        -- 4. Attach Rune
        print("\n‚ö° Attaching rune to weapon...")
        local attachSuccess = attachRuneToWeapon(weaponGUID, selectedRune.GUID)
        
        if attachSuccess then
            print("   ‚úÖ Rune attachment complete!")
            return true
        else
            warn("   ‚ùå Rune attachment failed!")
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- SMART QUEST RUNNER
    ----------------------------------------------------------------
    local function RunQuest10()
        print(string.rep("=", 50))
        print("üöÄ QUEST 10: " .. QUEST_CONFIG.QUEST_NAME)
        print("üéØ Objective: Attach Rune to Weapon")
        print("‚úÖ Strategy: Move to NPC ‚Üí Find Rune from Stash ‚Üí Attach")
        print(string.rep("=", 50))
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        
        if not questID then
            warn("‚ùå Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' not found!")
            Quest10Active = false
            cleanupState()
            disableNoclip()
            return
        end
        
        print("‚úÖ Quest found (ID: " .. questID .. ")")
        
        print("\n" .. string.rep("=", 50))
        print("‚öôÔ∏è  Quest Objectives:")
        local objectiveCount = 0
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                objectiveCount = objectiveCount + 1
                local text = getObjectiveText(item)
                local complete = isObjectiveComplete(item)
                print(string.format("   %d. %s [%s]", objectiveCount, text, complete and "‚úÖ" or "‚è≥"))
            end
        end
        print(string.rep("=", 50))
        
        if areAllObjectivesComplete() then
            print("\n‚úÖ Quest already complete!")
            cleanupState()
            disableNoclip()
            return
        end
        
        local maxAttempts = 3
        local attempt = 0
        
        while isQuest10StillActive() and not areAllObjectivesComplete() and attempt < maxAttempts do
            attempt = attempt + 1
            print(string.format("\nüîÑ Attempt #%d", attempt))
            
            local success = doAttachRune()
            
            if success then
                print("   ‚úÖ Rune attachment complete!")
                task.wait(2)
                
                if areAllObjectivesComplete() then
                    print("\nüéâ All objectives complete!")
                    break
                else
                    print("   ‚ö†Ô∏è Quest not marked complete, retrying...")
                    task.wait(2)
                end
            else
                warn("   ‚ùå Rune attachment failed, retrying in 3s...")
                task.wait(3)
            end
        end
        
        task.wait(1)
        
        if areAllObjectivesComplete() then
            print("\n" .. string.rep("=", 50))
            print("‚úÖ Quest 10 Complete!")
            print(string.rep("=", 50))
        else
            warn("\n" .. string.rep("=", 50))
            warn("‚ö†Ô∏è Quest 10 incomplete after " .. attempt .. " attempts")
            warn(string.rep("=", 50))
        end
        
        Quest10Active = false
        cleanupState()
        disableNoclip()
    end
    
    ----------------------------------------------------------------
    -- START
    ----------------------------------------------------------------
    RunQuest10()
end

----------------------------------------------------------------
-- QUEST 11 ORIGINAL (from 11.lua)
----------------------------------------------------------------
local function RunQuest11()
    -- QUEST 11: "End of the Beginning!" (Report to Sensei Moro - Final Quest)
    -- ‚úÖ Body Move to Sensei Moro
    -- ‚úÖ Dialogue + CheckQuest
    -- ‚úÖ Force Restore UI
    
    
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Workspace = game:GetService("Workspace")
    
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    ----------------------------------------------------------------
    -- CONFIG
    ----------------------------------------------------------------
    local Quest11Active = true
    
    local QUEST_CONFIG = {
        QUEST_NAME = "End of the Beginning",
        NPC_NAME = "Sensei Moro",
        QUEST_OPTION_ARG = "CheckQuest",
        MOVE_SPEED = 20,
        NPC_STOP_DISTANCE = 5,
    }
    
    ----------------------------------------------------------------
    -- KNIT SETUP
    ----------------------------------------------------------------
    local KnitPackage = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit")
    local Knit = require(KnitPackage)
    
    if not Knit.OnStart then 
        pcall(function() Knit.Start():await() end)
    end
    
    local ProximityService = nil
    local DialogueService = nil
    
    pcall(function()
        ProximityService = Knit.GetService("ProximityService")
        DialogueService = Knit.GetService("DialogueService")
    end)
    
    local SERVICES = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")
    
    local DIALOGUE_RF = nil
    pcall(function()
        DIALOGUE_RF = SERVICES:WaitForChild("ProximityService", 5):WaitForChild("RF", 3):WaitForChild("Dialogue", 3)
    end)
    
    local RUNCOMMAND_RF = nil
    pcall(function()
        RUNCOMMAND_RF = SERVICES:WaitForChild("DialogueService", 5):WaitForChild("RF", 3):WaitForChild("RunCommand", 3)
    end)
    
    local DIALOGUE_RE = nil
    pcall(function()
        DIALOGUE_RE = SERVICES:WaitForChild("DialogueService", 5):WaitForChild("RE", 3):WaitForChild("DialogueEvent", 3)
    end)
    
    if ProximityService then print("‚úÖ ProximityService Ready!") else warn("‚ö†Ô∏è ProximityService not found") end
    if DialogueService then print("‚úÖ DialogueService Ready!") else warn("‚ö†Ô∏è DialogueService not found") end
    if DIALOGUE_RF then print("‚úÖ Dialogue Remote Ready!") else warn("‚ö†Ô∏è Dialogue Remote not found") end
    if RUNCOMMAND_RF then print("‚úÖ RunCommand Remote Ready!") else warn("‚ö†Ô∏è RunCommand Remote not found") end
    
    ----------------------------------------------------------------
    -- STATE MANAGEMENT
    ----------------------------------------------------------------
    local State = {
        noclipConn = nil,
        moveConn = nil,
        bodyVelocity = nil,
        bodyGyro = nil,
    }
    
    local function cleanupState()
        if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
    end
    
    ----------------------------------------------------------------
    -- QUEST SYSTEM
    ----------------------------------------------------------------
    local function getQuestObjectives(questName)
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil, nil end
        
        local list = gui:FindFirstChild("Main") and gui.Main:FindFirstChild("Screen") 
                     and gui.Main.Screen:FindFirstChild("Quests") and gui.Main.Screen.Quests:FindFirstChild("List")
        if not list then return nil, nil end
        
        local questID = nil
        for _, child in ipairs(list:GetChildren()) do
            local id = string.match(child.Name, "^Introduction(%d+)Title$")
            if id and child:FindFirstChild("Frame") and child.Frame:FindFirstChild("TextLabel") then
                if child.Frame.TextLabel.Text == questName then
                    questID = id
                    break
                end
            end
        end
        
        if not questID then return nil, nil end
        
        local objList = list:FindFirstChild("Introduction" .. questID .. "List")
        return questID, objList
    end
    
    local function isObjectiveComplete(item)
        if not item then return false end
        local check = item:FindFirstChild("Main") and item.Main:FindFirstChild("Frame") and item.Main.Frame:FindFirstChild("Check")
        return check and check.Visible
    end
    
    local function getObjectiveText(item)
        local lbl = item:FindFirstChild("Main") and item.Main:FindFirstChild("TextLabel")
        return lbl and lbl.Text or ""
    end
    
    local function isQuest11StillActive()
        if not Quest11Active then return false end
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        if not questID or not objList then
            print("üõë Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' not found!")
            Quest11Active = false
            return false
        end
        
        return true
    end
    
    local function areAllObjectivesComplete()
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        if not questID or not objList then return true end
        
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                if not isObjectiveComplete(item) then
                    return false
                end
            end
        end
        
        return true
    end
    
    ----------------------------------------------------------------
    -- NPC HELPERS
    ----------------------------------------------------------------
    local function getNpcModel(name)
        local prox = Workspace:FindFirstChild("Proximity")
        return prox and prox:FindFirstChild(name)
    end
    
    local function getNpcPosition(npcModel)
        if not npcModel then return nil end
        
        local targetPart = npcModel.PrimaryPart or npcModel:FindFirstChildWhichIsA("BasePart")
        if not targetPart then return nil end
        
        return targetPart.Position
    end
    
    ----------------------------------------------------------------
    -- NOCLIP & MOVEMENT
    ----------------------------------------------------------------
    local function enableNoclip()
        if State.noclipConn then return end
        
        local char = player.Character
        if not char then return end
        
        State.noclipConn = RunService.Stepped:Connect(function()
            if not char or not char.Parent then
                if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
                return
            end
            
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end
    
    local function disableNoclip()
        if State.noclipConn then
            State.noclipConn:Disconnect()
            State.noclipConn = nil
        end
    end
    
    local function smoothMoveTo(targetPos, callback)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        enableNoclip()
        
        local bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Parent = hrp
        State.bodyVelocity = bv
        
        local bg = Instance.new("BodyGyro")
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.P = 10000
        bg.D = 500
        bg.Parent = hrp
        State.bodyGyro = bg
        
        print(string.format("   üöÄ Moving to (%.1f, %.1f, %.1f)...", targetPos.X, targetPos.Y, targetPos.Z))
        
        State.moveConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                if bv then bv:Destroy() end
                if bg then bg:Destroy() end
                State.bodyVelocity = nil
                State.bodyGyro = nil
                return
            end
            
            local currentPos = hrp.Position
            local direction = (targetPos - currentPos)
            local distance = direction.Magnitude
            
            if distance < QUEST_CONFIG.NPC_STOP_DISTANCE then
                print("   ‚úÖ Reached NPC!")
                
                bv.Velocity = Vector3.zero
                task.wait(0.1)
                
                bv:Destroy()
                bg:Destroy()
                State.bodyVelocity = nil
                State.bodyGyro = nil
                
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                
                if callback then callback() end
                return
            end
            
            local speed = math.min(QUEST_CONFIG.MOVE_SPEED, distance * 10)
            local velocity = direction.Unit * speed
            
            bv.Velocity = velocity
            bg.CFrame = CFrame.lookAt(currentPos, targetPos)
        end)
        
        return true
    end
    
    ----------------------------------------------------------------
    -- UI RESTORE
    ----------------------------------------------------------------
    local function forceRestoreUI()
        print("üîß Forcing UI Restore...")
        
        local char = player.Character
        if char then
            local status = char:FindFirstChild("Status")
            if status then
                for _, tag in ipairs(status:GetChildren()) do
                    if tag.Name == "DisableBackpack" or tag.Name == "NoMovement" or tag.Name == "Talking" then
                        pcall(function() tag:Destroy() end)
                        print("   - Removed Status Tag: " .. tag.Name)
                    end
                end
            end
            
            local humanoid = char:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = 16
                humanoid.JumpPower = 50
            end
        end
        
        local gui = player:FindFirstChild("PlayerGui")
        if gui then
            local dUI = gui:FindFirstChild("DialogueUI")
            if dUI then
                dUI.Enabled = false
                local bb = dUI:FindFirstChild("ResponseBillboard")
                if bb then bb.Visible = false end
            end
            
            local main = gui:FindFirstChild("Main")
            if main then 
                main.Enabled = true 
                print("   - Main UI Restored")
            end
            
            local backpack = gui:FindFirstChild("BackpackGui")
            if backpack then 
                backpack.Enabled = true 
                print("   - Backpack Restored")
            end
            
            local compass = gui:FindFirstChild("Compass")
            if compass then compass.Enabled = true end
            
            local mobile = gui:FindFirstChild("MobileButtons")
            if mobile then mobile.Enabled = true end
        end
        
        local cam = Workspace.CurrentCamera
        if cam then
            cam.CameraType = Enum.CameraType.Custom
            cam.FieldOfView = 70
        end
        
        if DIALOGUE_RE then
            pcall(function() DIALOGUE_RE:FireServer("Closed") end)
        end
        
        print("‚úÖ UI Restore Complete")
    end
    
    ----------------------------------------------------------------
    -- DIALOGUE SYSTEM
    ----------------------------------------------------------------
    local function startDialogue(npcModel)
        if not DIALOGUE_RF then
            warn("   ‚ùå Dialogue Remote not available!")
            return false
        end
        
        print("üìû Starting Dialogue with " .. QUEST_CONFIG.NPC_NAME .. "...")
        
        local success = pcall(function()
            DIALOGUE_RF:InvokeServer(npcModel)
        end)
        
        if success then
            print("   ‚úÖ Dialogue started!")
            return true
        else
            warn("   ‚ùå Failed to start dialogue")
            return false
        end
    end
    
    local function selectQuestOption(optionName)
        if not RUNCOMMAND_RF then
            warn("   ‚ùå RunCommand Remote not available!")
            return false
        end
        
        print("‚úÖ Selecting Option: " .. optionName)
        
        local success = pcall(function()
            RUNCOMMAND_RF:InvokeServer(optionName)
        end)
        
        if success then
            print("   ‚úÖ Option selected!")
            return true
        else
            warn("   ‚ùå Failed to select option")
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- MAIN QUEST EXECUTION
    ----------------------------------------------------------------
    local function doReportToSenseiMoro()
        print("üìã Objective: Report to Sensei Moro (Final Quest)...")
        
        local npcModel = getNpcModel(QUEST_CONFIG.NPC_NAME)
        if not npcModel then
            warn("   ‚ùå NPC not found: " .. QUEST_CONFIG.NPC_NAME)
            return false
        end
        
        local targetPos = getNpcPosition(npcModel)
        if not targetPos then
            warn("   ‚ùå Cannot get NPC position!")
            return false
        end
        
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp then
            local currentDist = (targetPos - hrp.Position).Magnitude
            print(string.format("   üö∂ Moving to %s at (%.1f, %.1f, %.1f) (%.1f studs away)...", 
                QUEST_CONFIG.NPC_NAME, targetPos.X, targetPos.Y, targetPos.Z, currentDist))
        end
        
        local moveComplete = false
        smoothMoveTo(targetPos, function()
            moveComplete = true
        end)
        
        local timeout = 20
        local startTime = tick()
        while not moveComplete and tick() - startTime < timeout do
            task.wait(0.1)
        end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        if not moveComplete then
            warn("   ‚ùå Failed to reach NPC (timeout)")
            return false
        end
        
        print("\nüìû Interacting with Sensei Moro...")
        task.wait(0.5)
        
        local dialogueSuccess = startDialogue(npcModel)
        if not dialogueSuccess then
            warn("   ‚ùå Dialogue failed!")
            return false
        end
        
        print("   ‚è≥ Waiting for dialogue to open...")
        task.wait(1.5)
        
        local optionSuccess = selectQuestOption(QUEST_CONFIG.QUEST_OPTION_ARG)
        if not optionSuccess then
            warn("   ‚ùå Option selection failed!")
        end
        
        print("   ‚è≥ Processing...")
        task.wait(1)
        
        forceRestoreUI()
        
        print("   ‚úÖ Dialogue complete!")
        return true
    end
    
    ----------------------------------------------------------------
    -- SMART QUEST RUNNER
    ----------------------------------------------------------------
    local function RunQuest11()
        print(string.rep("=", 50))
        print("üöÄ QUEST 11: " .. QUEST_CONFIG.QUEST_NAME)
        print("üéØ Objective: Report to Sensei Moro (FINAL QUEST)")
        print("üèÜ Completing Introduction Quest Line!")
        print(string.rep("=", 50))
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        
        if not questID then
            warn("‚ùå Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' not found!")
            Quest11Active = false
            cleanupState()
            disableNoclip()
            return
        end
        
        print("‚úÖ Quest found (ID: " .. questID .. ")")
        
        print("\n" .. string.rep("=", 50))
        print("‚öôÔ∏è  Quest Objectives:")
        local objectiveCount = 0
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                objectiveCount = objectiveCount + 1
                local text = getObjectiveText(item)
                local complete = isObjectiveComplete(item)
                print(string.format("   %d. %s [%s]", objectiveCount, text, complete and "‚úÖ" or "‚è≥"))
            end
        end
        print(string.rep("=", 50))
        
        if areAllObjectivesComplete() then
            print("\n‚úÖ Quest already complete!")
            cleanupState()
            disableNoclip()
            return
        end
        
        local maxAttempts = 3
        local attempt = 0
        
        while isQuest11StillActive() and not areAllObjectivesComplete() and attempt < maxAttempts do
            attempt = attempt + 1
            print(string.format("\nüîÑ Attempt #%d", attempt))
            
            local success = doReportToSenseiMoro()
            
            if success then
                print("   ‚úÖ Reporting complete!")
                task.wait(2)
                
                if areAllObjectivesComplete() then
                    print("\nüéâ All objectives complete!")
                    break
                else
                    print("   ‚ö†Ô∏è Quest not marked complete, retrying...")
                    task.wait(2)
                end
            else
                warn("   ‚ùå Reporting failed, retrying in 3s...")
                task.wait(3)
            end
        end
        
        task.wait(1)
        
        if areAllObjectivesComplete() then
            print("\n" .. string.rep("=", 50))
            print("üèÜ QUEST 11 COMPLETE!")
            print("üéâ INTRODUCTION QUEST LINE FINISHED!")
            print("‚ú® Congratulations!")
            print(string.rep("=", 50))
        else
            warn("\n" .. string.rep("=", 50))
            warn("‚ö†Ô∏è Quest 11 incomplete after " .. attempt .. " attempts")
            warn(string.rep("=", 50))
        end
        
        Quest11Active = false
        cleanupState()
        disableNoclip()
    end
    
    ----------------------------------------------------------------
    -- START
    ----------------------------------------------------------------
    RunQuest11()
end

----------------------------------------------------------------
-- QUEST 12 ORIGINAL (from 12.lua)
----------------------------------------------------------------
local function RunQuest12()
    -- QUEST 12: "Everything starts now!" (Talk to Wizard - Auto Complete)
    -- ‚úÖ Smooth Body Move to Wizard
    -- ‚úÖ Auto Dialogue ‚Üí CheckQuest ‚Üí FinishQuest
    -- ‚úÖ Force Restore UI
    
    
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Workspace = game:GetService("Workspace")
    
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    ----------------------------------------------------------------
    -- CONFIG
    ----------------------------------------------------------------
    local Quest12Active = true
    
    local QUEST_CONFIG = {
        QUEST_NAME = "Everything starts now.",
        NPC_NAME = "Wizard",
        NPC_POSITION = Vector3.new(-24.1, 80.9, -358.5),
        MOVE_SPEED = 20,
        NPC_STOP_DISTANCE = 5,
    }
    
    ----------------------------------------------------------------
    -- STATE MANAGEMENT
    ----------------------------------------------------------------
    local State = {
        noclipConn = nil,
        moveConn = nil,
        bodyVelocity = nil,
        bodyGyro = nil,
    }
    
    local function cleanupState()
        if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
    end
    
    ----------------------------------------------------------------
    -- QUEST SYSTEM
    ----------------------------------------------------------------
    local function getQuestObjectives(questName)
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil, nil end
        
        local list = gui:FindFirstChild("Main") and gui.Main:FindFirstChild("Screen") 
                     and gui.Main.Screen:FindFirstChild("Quests") and gui.Main.Screen.Quests:FindFirstChild("List")
        if not list then return nil, nil end
        
        local questID = nil
        for _, child in ipairs(list:GetChildren()) do
            local id = string.match(child.Name, "^Introduction(%d+)Title$")
            if id and child:FindFirstChild("Frame") and child.Frame:FindFirstChild("TextLabel") then
                if child.Frame.TextLabel.Text == questName then
                    questID = id
                    break
                end
            end
        end
        
        if not questID then return nil, nil end
        
        local objList = list:FindFirstChild("Introduction" .. questID .. "List")
        return questID, objList
    end
    
    local function isObjectiveComplete(item)
        if not item then return false end
        local check = item:FindFirstChild("Main") and item.Main:FindFirstChild("Frame") and item.Main.Frame:FindFirstChild("Check")
        return check and check.Visible
    end
    
    local function getObjectiveText(item)
        local lbl = item:FindFirstChild("Main") and item.Main:FindFirstChild("TextLabel")
        return lbl and lbl.Text or ""
    end
    
    local function isQuest12StillActive()
        if not Quest12Active then return false end
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        if not questID or not objList then
            print("üõë Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' not found!")
            Quest12Active = false
            return false
        end
        
        return true
    end
    
    local function areAllObjectivesComplete()
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        if not questID or not objList then return true end
        
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                if not isObjectiveComplete(item) then
                    return false
                end
            end
        end
        
        return true
    end
    
    ----------------------------------------------------------------
    -- NPC HELPERS
    ----------------------------------------------------------------
    local function getNpcModel(name)
        local prox = Workspace:FindFirstChild("Proximity")
        return prox and prox:FindFirstChild(name)
    end
    
    ----------------------------------------------------------------
    -- NOCLIP & MOVEMENT
    ----------------------------------------------------------------
    local function enableNoclip()
        if State.noclipConn then return end
        
        local char = player.Character
        if not char then return end
        
        State.noclipConn = RunService.Stepped:Connect(function()
            if not char or not char.Parent then
                if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
                return
            end
            
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end
    
    local function disableNoclip()
        if State.noclipConn then
            State.noclipConn:Disconnect()
            State.noclipConn = nil
        end
    end
    
    local function smoothMoveTo(targetPos, callback)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        enableNoclip()
        
        local bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Parent = hrp
        State.bodyVelocity = bv
        
        local bg = Instance.new("BodyGyro")
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.P = 10000
        bg.D = 500
        bg.Parent = hrp
        State.bodyGyro = bg
        
        print(string.format("   üöÄ Moving to (%.1f, %.1f, %.1f)...", targetPos.X, targetPos.Y, targetPos.Z))
        
        State.moveConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                if bv then bv:Destroy() end
                if bg then bg:Destroy() end
                State.bodyVelocity = nil
                State.bodyGyro = nil
                return
            end
            
            local currentPos = hrp.Position
            local direction = (targetPos - currentPos)
            local distance = direction.Magnitude
            
            if distance < QUEST_CONFIG.NPC_STOP_DISTANCE then
                print("   ‚úÖ Reached NPC!")
                
                bv.Velocity = Vector3.zero
                task.wait(0.1)
                
                bv:Destroy()
                bg:Destroy()
                State.bodyVelocity = nil
                State.bodyGyro = nil
                
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                
                if callback then callback() end
                return
            end
            
            local speed = math.min(QUEST_CONFIG.MOVE_SPEED, distance * 10)
            local velocity = direction.Unit * speed
            
            bv.Velocity = velocity
            bg.CFrame = CFrame.lookAt(currentPos, targetPos)
        end)
        
        return true
    end
    
    ----------------------------------------------------------------
    -- REMOTE FUNCTIONS
    ----------------------------------------------------------------
    local function invokeDialogueStart(npcModel)
        local remote = ReplicatedStorage:WaitForChild("Shared")
            :WaitForChild("Packages"):WaitForChild("Knit")
            :WaitForChild("Services"):WaitForChild("ProximityService")
            :WaitForChild("RF"):WaitForChild("Dialogue")
        if remote then
            pcall(function() remote:InvokeServer(npcModel) end)
            print("üì° 1. Started Dialogue")
        end
    end
    
    local function invokeRunCommand(commandName)
        local remote = ReplicatedStorage:WaitForChild("Shared")
            :WaitForChild("Packages"):WaitForChild("Knit")
            :WaitForChild("Services"):WaitForChild("DialogueService")
            :WaitForChild("RF"):WaitForChild("RunCommand")
        if remote then
            print("üì° 2. Executing Command: " .. commandName)
            pcall(function() remote:InvokeServer(commandName) end)
        end
    end
    
    ----------------------------------------------------------------
    -- UI RESTORE
    ----------------------------------------------------------------
    local function forceEndDialogueAndRestore()
        print("üîß 3. Forcing Cleanup & UI Restore...")
        
        -- A. ‡∏õ‡∏¥‡∏î Dialogue & ‡πÅ‡∏Å‡πâ Camera
        local gui = player:FindFirstChild("PlayerGui")
        if gui then
            local dUI = gui:FindFirstChild("DialogueUI")
            if dUI then
                dUI.Enabled = false
                local bb = dUI:FindFirstChild("ResponseBillboard")
                if bb then bb.Visible = false end
            end
        end
        
        local cam = Workspace.CurrentCamera
        if cam then
            cam.CameraType = Enum.CameraType.Custom
            cam.FieldOfView = 70
        end
        
        -- B. ‡∏•‡∏ö Status ‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡πÉ‡∏´‡πâ UI ‡∏´‡∏≤‡∏¢
        local char = player.Character
        if char then
            local status = char:FindFirstChild("Status")
            if status then
                for _, tag in ipairs(status:GetChildren()) do
                    if tag.Name == "DisableBackpack" or tag.Name == "NoMovement" or tag.Name == "Talking" then
                        pcall(function() tag:Destroy() end)
                        print("   - Removed Status Tag: " .. tag.Name)
                    end
                end
            end
            
            -- ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ Humanoid
            local humanoid = char:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = 16
                humanoid.JumpPower = 50
            end
        end
        
        -- C. ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÄ‡∏õ‡∏¥‡∏î UI ‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤
        if gui then
            local main = gui:FindFirstChild("Main")
            if main then 
                main.Enabled = true 
                print("   - Main UI (Quest) Restored")
            end
            
            local backpack = gui:FindFirstChild("BackpackGui")
            if backpack then 
                backpack.Enabled = true 
                print("   - Backpack Restored")
            end
            
            local compass = gui:FindFirstChild("Compass")
            if compass then compass.Enabled = true end
            
            local mobile = gui:FindFirstChild("MobileButtons")
            if mobile then mobile.Enabled = true end
        end
        
        -- D. ‡∏ö‡∏≠‡∏Å Server ‡∏ß‡πà‡∏≤‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß
        local dialogueEvent = ReplicatedStorage:WaitForChild("Shared")
            :WaitForChild("Packages"):WaitForChild("Knit")
            :WaitForChild("Services"):WaitForChild("DialogueService")
            :WaitForChild("RE"):WaitForChild("DialogueEvent")
        if dialogueEvent then
            pcall(function() dialogueEvent:FireServer("Closed") end)
        end
        
        print("‚úÖ Restore Complete")
    end
    
    ----------------------------------------------------------------
    -- MAIN QUEST EXECUTION
    ----------------------------------------------------------------
    local function doTalkToWizard()
        print("üìã Objective: Talk to Wizard...")
        
        local npcModel = getNpcModel(QUEST_CONFIG.NPC_NAME)
        if not npcModel then
            warn("   ‚ùå NPC not found: " .. QUEST_CONFIG.NPC_NAME)
            warn("   üí° Trying to use static position instead...")
        end
        
        local targetPos = QUEST_CONFIG.NPC_POSITION
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        
        if hrp then
            local currentDist = (targetPos - hrp.Position).Magnitude
            print(string.format("   üö∂ Moving to %s at (%.1f, %.1f, %.1f) (%.1f studs away)...", 
                QUEST_CONFIG.NPC_NAME, targetPos.X, targetPos.Y, targetPos.Z, currentDist))
        end
        
        local moveComplete = false
        smoothMoveTo(targetPos, function()
            moveComplete = true
        end)
        
        local timeout = 20
        local startTime = tick()
        while not moveComplete and tick() - startTime < timeout do
            task.wait(0.1)
        end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        if not moveComplete then
            warn("   ‚ö†Ô∏è Failed to reach NPC, continuing anyway...")
        end
        
        -- ‡∏ï‡∏£‡∏ß‡∏à‡∏´‡∏≤ NPC ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á (‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠)
        if not npcModel then
            npcModel = getNpcModel(QUEST_CONFIG.NPC_NAME)
        end
        
        if not npcModel then
            warn("   ‚ùå Cannot find NPC model!")
            return false
        end
        
        print("\nüìû Starting Dialogue with Wizard...")
        task.wait(0.5)
        invokeDialogueStart(npcModel)
        
        print("‚è≥ Waiting for dialogue to open...")
        task.wait(1.5)
        
        print("‚úÖ Selecting CheckQuest option...")
        invokeRunCommand("CheckQuest")
        
        print("‚è≥ Processing CheckQuest...")
        task.wait(0.8)
        
        print("‚úÖ Sending FinishQuest command...")
        invokeRunCommand("FinishQuest")
        
        print("‚è≥ Processing FinishQuest...")
        task.wait(0.5)
        
        forceEndDialogueAndRestore()
        
        print("   ‚úÖ Quest dialogue complete!")
        return true
    end
    
    ----------------------------------------------------------------
    -- SMART QUEST RUNNER
    ----------------------------------------------------------------
    local function RunQuest12()
        print(string.rep("=", 50))
        print("üöÄ QUEST 12: " .. QUEST_CONFIG.QUEST_NAME)
        print("üéØ Objective: Talk to Wizard")
        print("‚úÖ Strategy: Auto CheckQuest + FinishQuest")
        print(string.rep("=", 50))
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        
        if not questID then
            warn("‚ùå Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' not found!")
            Quest12Active = false
            cleanupState()
            disableNoclip()
            return
        end
        
        print("‚úÖ Quest found (ID: " .. questID .. ")")
        
        print("\n" .. string.rep("=", 50))
        print("‚öôÔ∏è  Quest Objectives:")
        local objectiveCount = 0
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                objectiveCount = objectiveCount + 1
                local text = getObjectiveText(item)
                local complete = isObjectiveComplete(item)
                print(string.format("   %d. %s [%s]", objectiveCount, text, complete and "‚úÖ" or "‚è≥"))
            end
        end
        print(string.rep("=", 50))
        
        if areAllObjectivesComplete() then
            print("\n‚úÖ Quest already complete!")
            cleanupState()
            disableNoclip()
            return
        end
        
        local maxAttempts = 3
        local attempt = 0
        
        while isQuest12StillActive() and not areAllObjectivesComplete() and attempt < maxAttempts do
            attempt = attempt + 1
            print(string.format("\nüîÑ Attempt #%d", attempt))
            
            local success = doTalkToWizard()
            
            if success then
                print("   ‚úÖ Dialogue sequence complete!")
                task.wait(2)
                
                if areAllObjectivesComplete() then
                    print("\nüéâ All objectives complete!")
                    break
                else
                    print("   ‚ö†Ô∏è Quest not marked complete, retrying...")
                    task.wait(2)
                end
            else
                warn("   ‚ùå Dialogue failed, retrying in 3s...")
                task.wait(3)
            end
        end
        
        task.wait(1)
        
        if areAllObjectivesComplete() then
            print("\n" .. string.rep("=", 50))
            print("‚úÖ Quest 12 Complete!")
            print("üéâ Everything Starts Now!")
            print(string.rep("=", 50))
        else
            warn("\n" .. string.rep("=", 50))
            warn("‚ö†Ô∏è Quest 12 incomplete after " .. attempt .. " attempts")
            warn(string.rep("=", 50))
        end
        
        Quest12Active = false
        cleanupState()
        disableNoclip()
    end
    
    ----------------------------------------------------------------
    -- START
    ----------------------------------------------------------------
    RunQuest12()
end

----------------------------------------------------------------
-- QUEST 13 ORIGINAL (from 13.lua)
----------------------------------------------------------------
local function RunQuest13()
    -- QUEST 13: Bard Quest (Level-based Auto Quest)
    -- ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ Level ‡∏à‡∏≤‡∏Å PlayerGui.Main.Screen.Hud.Level
    -- ‚úÖ ‡∏ñ‡πâ‡∏≤ Level < 10 ‚Üí Move ‡πÑ‡∏õ NPC Bard
    -- ‚úÖ ‡πÄ‡∏õ‡∏¥‡∏î Dialogue ‚Üí CheckQuest ‚Üí GiveBardQuest
    -- ‚úÖ Auto ‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏ß‡∏™‡πÅ‡∏•‡∏∞‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à
    
    
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Workspace = game:GetService("Workspace")
    
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    ----------------------------------------------------------------
    -- CONFIG
    ----------------------------------------------------------------
    local Quest13Active = true
    local DEBUG_MODE = true
    
    local QUEST_CONFIG = {
        QUEST_NAME = "Bard Quest",  -- ‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏Ñ‡∏ß‡∏™ (‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏à‡∏∞‡πÄ‡∏ä‡πá‡∏Ñ‡∏à‡∏≤‡∏Å Level ‡πÅ‡∏ó‡∏ô)
        NPC_NAME = "Bard",
        NPC_POSITION = Vector3.new(-130.9, 27.8, 109.8),
        MIN_LEVEL = 10,  -- Level ‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
        MOVE_SPEED = 20,
        NPC_STOP_DISTANCE = 5,
    }
    
    ----------------------------------------------------------------
    -- KNIT SETUP
    ----------------------------------------------------------------
    local KnitPackage = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit")
    local Knit = require(KnitPackage)
    
    if not Knit.OnStart then 
        pcall(function() Knit.Start():await() end)
    end
    
    local PlayerController = nil
    local ProximityService = nil
    local DialogueService = nil
    
    pcall(function()
        PlayerController = Knit.GetController("PlayerController")
        ProximityService = Knit.GetService("ProximityService")
        DialogueService = Knit.GetService("DialogueService")
    end)
    
    local SERVICES = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")
    
    local DIALOGUE_RF = nil
    pcall(function()
        DIALOGUE_RF = SERVICES:WaitForChild("ProximityService", 5):WaitForChild("RF", 3):WaitForChild("Dialogue", 3)
    end)
    
    local DIALOGUE_COMMAND_RF = nil
    pcall(function()
        DIALOGUE_COMMAND_RF = SERVICES:WaitForChild("DialogueService", 5):WaitForChild("RF", 3):WaitForChild("RunCommand", 3)
    end)
    
    if PlayerController then print("‚úÖ PlayerController Ready!") else warn("‚ö†Ô∏è PlayerController not found") end
    if ProximityService then print("‚úÖ ProximityService Ready!") else warn("‚ö†Ô∏è ProximityService not found") end
    if DialogueService then print("‚úÖ DialogueService Ready!") else warn("‚ö†Ô∏è DialogueService not found") end
    if DIALOGUE_RF then print("‚úÖ Dialogue Remote Ready!") else warn("‚ö†Ô∏è Dialogue Remote not found") end
    if DIALOGUE_COMMAND_RF then print("‚úÖ DialogueCommand Remote Ready!") else warn("‚ö†Ô∏è DialogueCommand Remote not found") end
    
    ----------------------------------------------------------------
    -- STATE MANAGEMENT
    ----------------------------------------------------------------
    local State = {
        noclipConn = nil,
        moveConn = nil,
        bodyVelocity = nil,
        bodyGyro = nil,
    }
    
    local function cleanupState()
        if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
    end
    
    ----------------------------------------------------------------
    -- LEVEL SYSTEM
    ----------------------------------------------------------------
    local function getPlayerLevel()
        print("   üîç Checking player level...")
        
        -- Path: PlayerGui.Main.Screen.Hud.Level
        local levelLabel = playerGui:FindFirstChild("Main")
                          and playerGui.Main:FindFirstChild("Screen")
                          and playerGui.Main.Screen:FindFirstChild("Hud")
                          and playerGui.Main.Screen.Hud:FindFirstChild("Level")
        
        if not levelLabel then
            warn("   ‚ùå Level Label not found!")
            warn("   üí° Path: PlayerGui.Main.Screen.Hud.Level")
            return nil
        end
        
        if not levelLabel:IsA("TextLabel") then
            warn("   ‚ùå Level is not a TextLabel!")
            return nil
        end
        
        local levelText = levelLabel.Text
        print(string.format("   üìä Level Text: '%s'", levelText))
        
        -- ‡πÅ‡∏¢‡∏Å Level ‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° (‡πÄ‡∏ä‡πà‡∏ô "Level 7" ‚Üí 7)
        local level = tonumber(string.match(levelText, "%d+"))
        
        if level then
            print(string.format("   ‚úÖ Player Level: %d", level))
            return level
        else
            warn("   ‚ùå Failed to parse level from text!")
            return nil
        end
    end
    
    local function shouldDoQuest()
        local level = getPlayerLevel()
        
        if not level then
            warn("   ‚ùå Cannot determine player level!")
            return false
        end
        
        if level < QUEST_CONFIG.MIN_LEVEL then
            print(string.format("   ‚úÖ Level %d < %d - Quest available!", level, QUEST_CONFIG.MIN_LEVEL))
            return true
        else
            print(string.format("   ‚è∏Ô∏è  Level %d >= %d - Quest not available", level, QUEST_CONFIG.MIN_LEVEL))
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- QUEST SYSTEM (Fallback - ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏Ñ‡∏ß‡∏™)
    ----------------------------------------------------------------
    local function getQuestObjectives(questName)
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil, nil end
        
        local list = gui:FindFirstChild("Main") and gui.Main:FindFirstChild("Screen") 
                     and gui.Main.Screen:FindFirstChild("Quests") and gui.Main.Screen.Quests:FindFirstChild("List")
        if not list then return nil, nil end
        
        local questID = nil
        for _, child in ipairs(list:GetChildren()) do
            local id = string.match(child.Name, "^Introduction(%d+)Title$")
            if id and child:FindFirstChild("Frame") and child.Frame:FindFirstChild("TextLabel") then
                if child.Frame.TextLabel.Text == questName then
                    questID = id
                    break
                end
            end
        end
        
        if not questID then return nil, nil end
        
        local objList = list:FindFirstChild("Introduction" .. questID .. "List")
        return questID, objList
    end
    
    local function isObjectiveComplete(item)
        if not item then return false end
        local check = item:FindFirstChild("Main") and item.Main:FindFirstChild("Frame") and item.Main.Frame:FindFirstChild("Check")
        return check and check.Visible
    end
    
    local function getObjectiveText(item)
        local lbl = item:FindFirstChild("Main") and item.Main:FindFirstChild("TextLabel")
        return lbl and lbl.Text or ""
    end
    
    local function areAllObjectivesComplete()
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
        if not questID or not objList then return false end
        
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                if not isObjectiveComplete(item) then
                    return false
                end
            end
        end
        
        return true
    end
    
    ----------------------------------------------------------------
    -- NOCLIP & MOVEMENT
    ----------------------------------------------------------------
    local function enableNoclip()
        if State.noclipConn then return end
        
        local char = player.Character
        if not char then return end
        
        State.noclipConn = RunService.Stepped:Connect(function()
            if not char or not char.Parent then
                if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
                return
            end
            
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end
    
    local function disableNoclip()
        if State.noclipConn then
            State.noclipConn:Disconnect()
            State.noclipConn = nil
        end
    end
    
    local function smoothMoveTo(targetPos, callback)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        enableNoclip()
        
        local bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Parent = hrp
        State.bodyVelocity = bv
        
        local bg = Instance.new("BodyGyro")
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.P = 10000
        bg.D = 500
        bg.Parent = hrp
        State.bodyGyro = bg
        
        print(string.format("   üöÄ Moving to (%.1f, %.1f, %.1f)...", targetPos.X, targetPos.Y, targetPos.Z))
        
        State.moveConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                if bv then bv:Destroy() end
                if bg then bg:Destroy() end
                State.bodyVelocity = nil
                State.bodyGyro = nil
                return
            end
            
            local currentPos = hrp.Position
            local direction = (targetPos - currentPos)
            local distance = direction.Magnitude
            
            if distance < QUEST_CONFIG.NPC_STOP_DISTANCE then
                print("   ‚úÖ Reached target!")
                
                bv.Velocity = Vector3.zero
                task.wait(0.1)
                
                bv:Destroy()
                bg:Destroy()
                State.bodyVelocity = nil
                State.bodyGyro = nil
                
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                
                if callback then callback() end
                return
            end
            
            local speed = math.min(QUEST_CONFIG.MOVE_SPEED, distance * 10)
            local velocity = direction.Unit * speed
            
            bv.Velocity = velocity
            bg.CFrame = CFrame.lookAt(currentPos, targetPos)
        end)
        
        return true
    end
    
    ----------------------------------------------------------------
    -- NPC INTERACTION
    ----------------------------------------------------------------
    local function getNpcModel(name)
        local prox = Workspace:FindFirstChild("Proximity")
        return prox and prox:FindFirstChild(name)
    end
    
    local function openDialogue(npcModel)
        if not DIALOGUE_RF then
            warn("   ‚ùå Dialogue Remote not available!")
            return false
        end
        
        print("   üìû Opening Dialogue with " .. QUEST_CONFIG.NPC_NAME .. "...")
        
        local success = pcall(function()
            DIALOGUE_RF:InvokeServer(npcModel)
        end)
        
        if success then
            print("   ‚úÖ Dialogue opened!")
            return true
        else
            warn("   ‚ùå Failed to open dialogue")
            return false
        end
    end
    
    local function runDialogueCommand(command)
        if not DIALOGUE_COMMAND_RF then
            warn("   ‚ùå DialogueCommand Remote not available!")
            return false
        end
        
        print(string.format("   üí¨ Running command: '%s'", command))
        
        local success, result = pcall(function()
            return DIALOGUE_COMMAND_RF:InvokeServer(command)
        end)
        
        if success then
            print(string.format("   ‚úÖ Command '%s' executed successfully!", command))
            if DEBUG_MODE and result then
                print(string.format("   üìä Result: %s", tostring(result)))
            end
            return true
        else
            warn(string.format("   ‚ùå Failed to execute command '%s': %s", command, tostring(result)))
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- UI RESTORE
    ----------------------------------------------------------------
    local function forceRestoreUI()
        print("üîß Forcing UI Restore...")
        
        local gui = player:FindFirstChild("PlayerGui")
        if gui then
            local dUI = gui:FindFirstChild("DialogueUI")
            if dUI then
                dUI.Enabled = false
                local bb = dUI:FindFirstChild("ResponseBillboard")
                if bb then bb.Visible = false end
            end
        end
        
        local cam = Workspace.CurrentCamera
        if cam then
            cam.CameraType = Enum.CameraType.Custom
            cam.FieldOfView = 70
        end
        
        local char = player.Character
        if char then
            local status = char:FindFirstChild("Status")
            if status then
                for _, tag in ipairs(status:GetChildren()) do
                    if tag.Name == "DisableBackpack" or tag.Name == "NoMovement" or tag.Name == "Talking" then
                        pcall(function() tag:Destroy() end)
                        print("   - Removed Status Tag: " .. tag.Name)
                    end
                end
            end
            
            local humanoid = char:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = 16
                humanoid.JumpPower = 50
            end
        end
        
        if gui then
            local main = gui:FindFirstChild("Main")
            if main then 
                main.Enabled = true 
                print("   - Main UI Restored")
            end
            
            local backpack = gui:FindFirstChild("BackpackGui")
            if backpack then 
                backpack.Enabled = true 
                print("   - Backpack Restored")
            end
        end
        
        print("‚úÖ UI Restore Complete")
    end
    
    ----------------------------------------------------------------
    -- MAIN QUEST EXECUTION
    ----------------------------------------------------------------
    local function doAcceptQuest()
        print("üìú Objective: Accept Bard Quest...")
        
        -- 1. ‡πÄ‡∏ä‡πá‡∏Ñ Level
        print("\nüîç Checking if quest is available...")
        if not shouldDoQuest() then
            warn("   ‚ùå Quest not available (Level too high)")
            return false
        end
        
        -- 2. ‡∏´‡∏≤ NPC
        local npcModel = getNpcModel(QUEST_CONFIG.NPC_NAME)
        if not npcModel then
            warn("   ‚ùå NPC not found: " .. QUEST_CONFIG.NPC_NAME)
            return false
        end
        
        -- 3. Move ‡πÑ‡∏õ‡∏´‡∏≤ NPC
        local npcPos = QUEST_CONFIG.NPC_POSITION
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        
        if hrp then
            local currentDist = (npcPos - hrp.Position).Magnitude
            print(string.format("   üö∂ Moving to %s at (%.1f, %.1f, %.1f) (%.1f studs away)...", 
                QUEST_CONFIG.NPC_NAME, npcPos.X, npcPos.Y, npcPos.Z, currentDist))
        end
        
        local moveComplete = false
        smoothMoveTo(npcPos, function()
            moveComplete = true
        end)
        
        local timeout = 20
        local startTime = tick()
        while not moveComplete and tick() - startTime < timeout do
            task.wait(0.1)
        end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        if not moveComplete then
            warn("   ‚ö†Ô∏è Failed to reach NPC")
            return false
        end
        
        print("   ‚úÖ Reached NPC!")
        task.wait(1)
        
        -- 4. ‡πÄ‡∏õ‡∏¥‡∏î Dialogue
        print("\nüìû Opening Dialogue...")
        local dialogueOpened = openDialogue(npcModel)
        
        if not dialogueOpened then
            warn("   ‚ùå Failed to open dialogue")
            return false
        end
        
        task.wait(1.5)
        
        -- 5. ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏Ñ‡∏ß‡∏™ (CheckQuest)
        print("\nüîç Checking quest availability...")
        local checkSuccess = runDialogueCommand("CheckQuest")
        
        if not checkSuccess then
            warn("   ‚ùå Failed to check quest")
            return false
        end
        
        task.wait(1)
        
        -- 6. ‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏ß‡∏™ (GiveBardQuest)
        print("\n‚úÖ Accepting quest...")
        local giveSuccess = runDialogueCommand("GiveBardQuest")
        
        if not giveSuccess then
            warn("   ‚ùå Failed to accept quest")
            return false
        end
        
        print("   ‚úÖ Quest accepted!")
        
        -- 7. Restore UI
        task.wait(1)
        forceRestoreUI()
        
        return true
    end
    
    ----------------------------------------------------------------
    -- SMART QUEST RUNNER
    ----------------------------------------------------------------
    local function RunQuest13()
        print(string.rep("=", 50))
        print("üöÄ QUEST 13: " .. QUEST_CONFIG.QUEST_NAME)
        print("üéØ Objective: Accept Bard Quest (Level-based)")
        print(string.format("‚úÖ Strategy: Check Level ‚Üí Move to NPC ‚Üí Accept Quest"))
        print(string.rep("=", 50))
        
        -- ‡πÄ‡∏ä‡πá‡∏Ñ Level ‡∏Å‡πà‡∏≠‡∏ô
        print("\nüîç Pre-check: Verifying level requirement...")
        if not shouldDoQuest() then
            print("\n‚úÖ Quest not available (Level too high)")
            print(string.rep("=", 50))
            cleanupState()
            disableNoclip()
            return
        end
        
        -- ‡∏ñ‡πâ‡∏≤ Level ‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤ MIN_LEVEL ‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏ß‡∏™
        local maxAttempts = 3
        local attempt = 0
        
        while Quest13Active and attempt < maxAttempts do
            attempt = attempt + 1
            print(string.format("\nüîÑ Attempt #%d", attempt))
            
            local success = doAcceptQuest()
            
            if success then
                print("   ‚úÖ Quest accepted successfully!")
                task.wait(2)
                
                -- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ Quest ‡πÉ‡∏ô UI ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_NAME)
                if questID then
                    print("\nüéâ Quest found in Quest Log!")
                    
                    print("\n" .. string.rep("=", 50))
                    print("‚öôÔ∏è  Quest Objectives:")
                    local objectiveCount = 0
                    for _, item in ipairs(objList:GetChildren()) do
                        if item:IsA("Frame") and tonumber(item.Name) then
                            objectiveCount = objectiveCount + 1
                            local text = getObjectiveText(item)
                            local complete = isObjectiveComplete(item)
                            print(string.format("   %d. %s [%s]", objectiveCount, text, complete and "‚úÖ" or "‚è≥"))
                        end
                    end
                    print(string.rep("=", 50))
                    
                    break
                else
                    print("   ‚ö†Ô∏è Quest not found in Quest Log, but accepted")
                    break
                end
            else
                warn("   ‚ùå Failed to accept quest, retrying in 3s...")
                task.wait(3)
            end
        end
        
        task.wait(1)
        
        print("\n" .. string.rep("=", 50))
        print("‚úÖ Quest 13 Complete!")
        print(string.rep("=", 50))
        
        Quest13Active = false
        cleanupState()
        disableNoclip()
    end
    
    ----------------------------------------------------------------
    -- START
    ----------------------------------------------------------------
    RunQuest13()
end

----------------------------------------------------------------
-- QUEST 14 ORIGINAL (from 14.lua)
----------------------------------------------------------------
local function RunQuest14()
    -- QUEST 14: "Lost Guitar" (FIXED - ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏π Quest)
    -- ‚úÖ Move ‡πÑ‡∏õ‡∏ó‡∏µ‡πà Guitar (-46.2, -26.6, -63.4)
    -- ‚úÖ ‡πÄ‡∏Å‡πá‡∏ö Guitar ‡∏ú‡πà‡∏≤‡∏ô Functionals Remote
    -- ‚úÖ Move ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏´‡∏≤ Bard NPC (-130.9, 27.8, 109.8)
    -- ‚úÖ ‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ö NPC ‚Üí CheckQuest ‚Üí FinishQuest
    -- ‚úÖ Auto Complete Quest
    
    
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Workspace = game:GetService("Workspace")
    
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    ----------------------------------------------------------------
    -- CONFIG
    ----------------------------------------------------------------
    local Quest14Active = true
    local DEBUG_MODE = true
    
    local QUEST_CONFIG = {
        QUEST_NAME = "Lost Guitar",
        QUEST_ID = "BardQuest",  -- ‡πÉ‡∏ä‡πâ‡πÅ‡∏ó‡∏ô Introduction{N}
        
        -- Guitar Location
        GUITAR_OBJECT_NAME = "BardGuitar",
        GUITAR_POSITION = Vector3.new(-46.2, -26.6, -63.4),
        
        -- Bard NPC
        NPC_NAME = "Bard",
        NPC_POSITION = Vector3.new(-130.9, 27.8, 109.8),
        
        MOVE_SPEED = 20,
        STOP_DISTANCE = 5,
    }
    
    ----------------------------------------------------------------
    -- KNIT SETUP
    ----------------------------------------------------------------
    local KnitPackage = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit")
    local Knit = require(KnitPackage)
    
    if not Knit.OnStart then 
        pcall(function() Knit.Start():await() end)
    end
    
    local PlayerController = nil
    local ProximityService = nil
    local DialogueService = nil
    
    pcall(function()
        PlayerController = Knit.GetController("PlayerController")
        ProximityService = Knit.GetService("ProximityService")
        DialogueService = Knit.GetService("DialogueService")
    end)
    
    local SERVICES = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")
    
    local DIALOGUE_RF = nil
    pcall(function()
        DIALOGUE_RF = SERVICES:WaitForChild("ProximityService", 5):WaitForChild("RF", 3):WaitForChild("Dialogue", 3)
    end)
    
    local FUNCTIONALS_RF = nil
    pcall(function()
        FUNCTIONALS_RF = SERVICES:WaitForChild("ProximityService", 5):WaitForChild("RF", 3):WaitForChild("Functionals", 3)
    end)
    
    local DIALOGUE_COMMAND_RF = nil
    pcall(function()
        DIALOGUE_COMMAND_RF = SERVICES:WaitForChild("DialogueService", 5):WaitForChild("RF", 3):WaitForChild("RunCommand", 3)
    end)
    
    if PlayerController then print("‚úÖ PlayerController Ready!") else warn("‚ö†Ô∏è PlayerController not found") end
    if ProximityService then print("‚úÖ ProximityService Ready!") else warn("‚ö†Ô∏è ProximityService not found") end
    if DialogueService then print("‚úÖ DialogueService Ready!") else warn("‚ö†Ô∏è DialogueService not found") end
    if DIALOGUE_RF then print("‚úÖ Dialogue Remote Ready!") else warn("‚ö†Ô∏è Dialogue Remote not found") end
    if FUNCTIONALS_RF then print("‚úÖ Functionals Remote Ready!") else warn("‚ö†Ô∏è Functionals Remote not found") end
    if DIALOGUE_COMMAND_RF then print("‚úÖ DialogueCommand Remote Ready!") else warn("‚ö†Ô∏è DialogueCommand Remote not found") end
    
    ----------------------------------------------------------------
    -- STATE MANAGEMENT
    ----------------------------------------------------------------
    local State = {
        noclipConn = nil,
        moveConn = nil,
        bodyVelocity = nil,
        bodyGyro = nil,
    }
    
    local function cleanupState()
        if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
    end
    
    ----------------------------------------------------------------
    -- QUEST SYSTEM (FIXED - ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ Introduction{N} ‡πÅ‡∏•‡πâ‡∏ß)
    ----------------------------------------------------------------
    local function getQuestObjectives(questID)
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil, nil end
        
        local list = gui:FindFirstChild("Main") and gui.Main:FindFirstChild("Screen") 
                     and gui.Main.Screen:FindFirstChild("Quests") and gui.Main.Screen.Quests:FindFirstChild("List")
        if not list then return nil, nil end
        
        -- ‡∏´‡∏≤ Title (‡πÄ‡∏ä‡πà‡∏ô "BardQuestTitle")
        local titleFrame = list:FindFirstChild(questID .. "Title")
        if not titleFrame then
            if DEBUG_MODE then
                warn(string.format("   ‚ùå Quest Title not found: %sTitle", questID))
            end
            return nil, nil
        end
        
        -- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤ Title ‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏Ñ‡∏ß‡∏™‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        if titleFrame:FindFirstChild("Frame") and titleFrame.Frame:FindFirstChild("TextLabel") then
            local questName = titleFrame.Frame.TextLabel.Text
            if DEBUG_MODE then
                print(string.format("   ‚úÖ Found Quest: %s", questName))
            end
        end
        
        -- ‡∏´‡∏≤ List (‡πÄ‡∏ä‡πà‡∏ô "BardQuestList")
        local objList = list:FindFirstChild(questID .. "List")
        if not objList then
            if DEBUG_MODE then
                warn(string.format("   ‚ùå Quest List not found: %sList", questID))
            end
            return nil, nil
        end
        
        return questID, objList
    end
    
    local function isObjectiveComplete(item)
        if not item then return false end
        local check = item:FindFirstChild("Main") and item.Main:FindFirstChild("Frame") and item.Main.Frame:FindFirstChild("Check")
        return check and check.Visible
    end
    
    local function getObjectiveText(item)
        local lbl = item:FindFirstChild("Main") and item.Main:FindFirstChild("TextLabel")
        return lbl and lbl.Text or ""
    end
    
    local function isQuest14StillActive()
        if not Quest14Active then return false end
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_ID)
        if not questID or not objList then
            print("üõë Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' not found!")
            Quest14Active = false
            return false
        end
        
        return true
    end
    
    local function areAllObjectivesComplete()
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_ID)
        if not questID or not objList then return true end
        
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                if not isObjectiveComplete(item) then
                    return false
                end
            end
        end
        
        return true
    end
    
    ----------------------------------------------------------------
    -- NOCLIP & MOVEMENT
    ----------------------------------------------------------------
    local function enableNoclip()
        if State.noclipConn then return end
        
        local char = player.Character
        if not char then return end
        
        State.noclipConn = RunService.Stepped:Connect(function()
            if not char or not char.Parent then
                if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
                return
            end
            
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end
    
    local function disableNoclip()
        if State.noclipConn then
            State.noclipConn:Disconnect()
            State.noclipConn = nil
        end
    end
    
    local function smoothMoveTo(targetPos, callback)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        enableNoclip()
        
        local bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Parent = hrp
        State.bodyVelocity = bv
        
        local bg = Instance.new("BodyGyro")
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.P = 10000
        bg.D = 500
        bg.Parent = hrp
        State.bodyGyro = bg
        
        print(string.format("   üöÄ Moving to (%.1f, %.1f, %.1f)...", targetPos.X, targetPos.Y, targetPos.Z))
        
        State.moveConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                if bv then bv:Destroy() end
                if bg then bg:Destroy() end
                State.bodyVelocity = nil
                State.bodyGyro = nil
                return
            end
            
            local currentPos = hrp.Position
            local direction = (targetPos - currentPos)
            local distance = direction.Magnitude
            
            if distance < QUEST_CONFIG.STOP_DISTANCE then
                print("   ‚úÖ Reached target!")
                
                bv.Velocity = Vector3.zero
                task.wait(0.1)
                
                bv:Destroy()
                bg:Destroy()
                State.bodyVelocity = nil
                State.bodyGyro = nil
                
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                
                if callback then callback() end
                return
            end
            
            local speed = math.min(QUEST_CONFIG.MOVE_SPEED, distance * 10)
            local velocity = direction.Unit * speed
            
            bv.Velocity = velocity
            bg.CFrame = CFrame.lookAt(currentPos, targetPos)
        end)
        
        return true
    end
    
    ----------------------------------------------------------------
    -- OBJECT HELPERS
    ----------------------------------------------------------------
    local function getProximityObject(name)
        local prox = Workspace:FindFirstChild("Proximity")
        return prox and prox:FindFirstChild(name)
    end
    
    ----------------------------------------------------------------
    -- GUITAR PICKUP
    ----------------------------------------------------------------
    local function pickupGuitar()
        if not FUNCTIONALS_RF then
            warn("   ‚ùå Functionals Remote not available!")
            return false
        end
        
        local guitarObject = getProximityObject(QUEST_CONFIG.GUITAR_OBJECT_NAME)
        if not guitarObject then
            warn("   ‚ùå Guitar object not found: " .. QUEST_CONFIG.GUITAR_OBJECT_NAME)
            return false
        end
        
        print("   üé∏ Picking up guitar...")
        
        local success, result = pcall(function()
            return FUNCTIONALS_RF:InvokeServer(guitarObject)
        end)
        
        if success then
            print("   ‚úÖ Guitar picked up!")
            return true
        else
            warn("   ‚ùå Failed to pickup guitar: " .. tostring(result))
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- NPC INTERACTION
    ----------------------------------------------------------------
    local function openDialogue(npcModel)
        if not DIALOGUE_RF then
            warn("   ‚ùå Dialogue Remote not available!")
            return false
        end
        
        print("   üìû Opening Dialogue with " .. QUEST_CONFIG.NPC_NAME .. "...")
        
        local success = pcall(function()
            DIALOGUE_RF:InvokeServer(npcModel)
        end)
        
        if success then
            print("   ‚úÖ Dialogue opened!")
            return true
        else
            warn("   ‚ùå Failed to open dialogue")
            return false
        end
    end
    
    local function runDialogueCommand(command)
        if not DIALOGUE_COMMAND_RF then
            warn("   ‚ùå DialogueCommand Remote not available!")
            return false
        end
        
        print(string.format("   üí¨ Running command: '%s'", command))
        
        local success, result = pcall(function()
            return DIALOGUE_COMMAND_RF:InvokeServer(command)
        end)
        
        if success then
            print(string.format("   ‚úÖ Command '%s' executed successfully!", command))
            if DEBUG_MODE and result then
                print(string.format("   üìä Result: %s", tostring(result)))
            end
            return true
        else
            warn(string.format("   ‚ùå Failed to execute command '%s': %s", command, tostring(result)))
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- UI RESTORE
    ----------------------------------------------------------------
    local function forceRestoreUI()
        print("üîß Forcing UI Restore...")
        
        local gui = player:FindFirstChild("PlayerGui")
        if gui then
            local dUI = gui:FindFirstChild("DialogueUI")
            if dUI then
                dUI.Enabled = false
                local bb = dUI:FindFirstChild("ResponseBillboard")
                if bb then bb.Visible = false end
            end
        end
        
        local cam = Workspace.CurrentCamera
        if cam then
            cam.CameraType = Enum.CameraType.Custom
            cam.FieldOfView = 70
        end
        
        local char = player.Character
        if char then
            local status = char:FindFirstChild("Status")
            if status then
                for _, tag in ipairs(status:GetChildren()) do
                    if tag.Name == "DisableBackpack" or tag.Name == "NoMovement" or tag.Name == "Talking" then
                        pcall(function() tag:Destroy() end)
                        print("   - Removed Status Tag: " .. tag.Name)
                    end
                end
            end
            
            local humanoid = char:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = 16
                humanoid.JumpPower = 50
            end
        end
        
        if gui then
            local main = gui:FindFirstChild("Main")
            if main then 
                main.Enabled = true 
                print("   - Main UI Restored")
            end
            
            local backpack = gui:FindFirstChild("BackpackGui")
            if backpack then 
                backpack.Enabled = true 
                print("   - Backpack Restored")
            end
        end
        
        print("‚úÖ UI Restore Complete")
    end
    
    ----------------------------------------------------------------
    -- MAIN QUEST EXECUTION
    ----------------------------------------------------------------
    local function doCollectGuitar()
        print("üé∏ Step 1: Collecting Guitar...")
        
        -- 1. Move ‡πÑ‡∏õ‡∏ó‡∏µ‡πà Guitar
        local guitarPos = QUEST_CONFIG.GUITAR_POSITION
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        
        if hrp then
            local currentDist = (guitarPos - hrp.Position).Magnitude
            print(string.format("   üö∂ Moving to Guitar at (%.1f, %.1f, %.1f) (%.1f studs away)...", 
                guitarPos.X, guitarPos.Y, guitarPos.Z, currentDist))
        end
        
        local moveComplete = false
        smoothMoveTo(guitarPos, function()
            moveComplete = true
        end)
        
        local timeout = 30
        local startTime = tick()
        while not moveComplete and tick() - startTime < timeout do
            task.wait(0.1)
        end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        if not moveComplete then
            warn("   ‚ö†Ô∏è Failed to reach Guitar")
            return false
        end
        
        print("   ‚úÖ Reached Guitar!")
        task.wait(1)
        
        -- 2. ‡πÄ‡∏Å‡πá‡∏ö Guitar
        local pickupSuccess = pickupGuitar()
        
        if not pickupSuccess then
            warn("   ‚ùå Failed to pickup guitar")
            return false
        end
        
        task.wait(1)
        return true
    end
    
    local function doReturnGuitar()
        print("\nüé∏ Step 2: Returning Guitar to Bard...")
        
        -- 1. Move ‡πÑ‡∏õ‡∏´‡∏≤ Bard NPC
        local npcPos = QUEST_CONFIG.NPC_POSITION
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        
        if hrp then
            local currentDist = (npcPos - hrp.Position).Magnitude
            print(string.format("   üö∂ Moving to %s at (%.1f, %.1f, %.1f) (%.1f studs away)...", 
                QUEST_CONFIG.NPC_NAME, npcPos.X, npcPos.Y, npcPos.Z, currentDist))
        end
        
        local moveComplete = false
        smoothMoveTo(npcPos, function()
            moveComplete = true
        end)
        
        local timeout = 30
        local startTime = tick()
        while not moveComplete and tick() - startTime < timeout do
            task.wait(0.1)
        end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        if not moveComplete then
            warn("   ‚ö†Ô∏è Failed to reach NPC")
            return false
        end
        
        print("   ‚úÖ Reached NPC!")
        task.wait(1)
        
        -- 2. ‡∏´‡∏≤ NPC Model
        local npcModel = getProximityObject(QUEST_CONFIG.NPC_NAME)
        if not npcModel then
            warn("   ‚ùå NPC not found: " .. QUEST_CONFIG.NPC_NAME)
            return false
        end
        
        -- 3. ‡πÄ‡∏õ‡∏¥‡∏î Dialogue
        print("\nüìû Opening Dialogue...")
        local dialogueOpened = openDialogue(npcModel)
        
        if not dialogueOpened then
            warn("   ‚ùå Failed to open dialogue")
            return false
        end
        
        task.wait(1.5)
        
        -- 4. CheckQuest
        print("\nüîç Checking quest status...")
        local checkSuccess = runDialogueCommand("CheckQuest")
        
        if not checkSuccess then
            warn("   ‚ùå Failed to check quest")
            return false
        end
        
        task.wait(1)
        
        -- 5. FinishQuest (‡∏™‡πà‡∏á Guitar ‡∏Ñ‡∏∑‡∏ô)
        print("\n‚úÖ Returning guitar to Bard...")
        local finishSuccess = runDialogueCommand("FinishQuest")
        
        if not finishSuccess then
            warn("   ‚ùå Failed to finish quest")
            return false
        end
        
        print("   ‚úÖ Quest completed!")
        
        -- 6. Restore UI
        task.wait(1)
        forceRestoreUI()
        
        return true
    end
    
    ----------------------------------------------------------------
    -- SMART QUEST RUNNER
    ----------------------------------------------------------------
    local function RunQuest14()
        print(string.rep("=", 50))
        print("üöÄ QUEST 14: " .. QUEST_CONFIG.QUEST_NAME)
        print("üéØ Objective: Find and Return Guitar to Bard")
        print("‚úÖ Strategy: Collect Guitar ‚Üí Return to NPC ‚Üí Finish Quest")
        print(string.rep("=", 50))
        
        local questID, objList = getQuestObjectives(QUEST_CONFIG.QUEST_ID)
        
        if not questID then
            warn("‚ùå Quest '" .. QUEST_CONFIG.QUEST_NAME .. "' not found!")
            warn(string.format("   üí° Looking for: %sTitle", QUEST_CONFIG.QUEST_ID))
            Quest14Active = false
            cleanupState()
            disableNoclip()
            return
        end
        
        print("‚úÖ Quest found (ID: " .. questID .. ")")
        
        print("\n" .. string.rep("=", 50))
        print("‚öôÔ∏è  Quest Objectives:")
        local objectiveCount = 0
        for _, item in ipairs(objList:GetChildren()) do
            if item:IsA("Frame") and tonumber(item.Name) then
                objectiveCount = objectiveCount + 1
                local text = getObjectiveText(item)
                local complete = isObjectiveComplete(item)
                print(string.format("   %d. %s [%s]", objectiveCount, text, complete and "‚úÖ" or "‚è≥"))
            end
        end
        print(string.rep("=", 50))
        
        if areAllObjectivesComplete() then
            print("\n‚úÖ Quest already complete!")
            cleanupState()
            disableNoclip()
            return
        end
        
        local maxAttempts = 3
        local attempt = 0
        
        while isQuest14StillActive() and not areAllObjectivesComplete() and attempt < maxAttempts do
            attempt = attempt + 1
            print(string.format("\nüîÑ Attempt #%d", attempt))
            
            -- Step 1: Collect Guitar
            local collectSuccess = doCollectGuitar()
            
            if not collectSuccess then
                warn("   ‚ùå Failed to collect guitar, retrying in 3s...")
                task.wait(3)
                continue
            end
            
            -- Step 2: Return Guitar
            local returnSuccess = doReturnGuitar()
            
            if returnSuccess then
                print("   ‚úÖ Quest completed successfully!")
                task.wait(2)
                
                if areAllObjectivesComplete() then
                    print("\nüéâ All objectives complete!")
                    break
                else
                    print("   ‚ö†Ô∏è Quest not marked complete, retrying...")
                    task.wait(2)
                end
            else
                warn("   ‚ùå Failed to return guitar, retrying in 3s...")
                task.wait(3)
            end
        end
        
        task.wait(1)
        
        if areAllObjectivesComplete() then
            print("\n" .. string.rep("=", 50))
            print("‚úÖ Quest 14 Complete!")
            print(string.rep("=", 50))
        else
            warn("\n" .. string.rep("=", 50))
            warn("‚ö†Ô∏è Quest 14 incomplete after " .. attempt .. " attempts")
            warn(string.rep("=", 50))
        end
        
        Quest14Active = false
        cleanupState()
        disableNoclip()
    end
    
    ----------------------------------------------------------------
    -- START
    ----------------------------------------------------------------
    RunQuest14()
end

----------------------------------------------------------------
-- QUEST 15 ORIGINAL (from 15.lua)
----------------------------------------------------------------
local function RunQuest15()
    -- QUEST 15: Auto Claim Index (Codex System)
    -- ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ Gold ‡∏à‡∏≤‡∏Å PlayerGui.Main.Screen.Hud.Gold
    -- ‚úÖ ‡∏ñ‡πâ‡∏≤ Gold < 3340 ‚Üí Auto Claim ‡∏ó‡∏∏‡∏Å Index
    -- ‚úÖ Claim Ores, Enemies, Equipments
    -- ‚úÖ ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á List ‡πÅ‡∏•‡∏∞ Direct Item
    
    
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    ----------------------------------------------------------------
    -- CONFIG
    ----------------------------------------------------------------
    local Quest15Active = true
    local DEBUG_MODE = true
    
    local QUEST_CONFIG = {
        QUEST_NAME = "Auto Claim Index",
        MIN_GOLD = 3340,  -- ‡∏ñ‡πâ‡∏≤ Gold < 3340 ‡∏à‡∏∞‡∏ó‡∏≥‡∏Å‡∏≤‡∏£ Claim
        
        CLAIM_DELAY = 0.5,  -- Delay ‡∏´‡∏•‡∏±‡∏á Claim ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏≠‡∏±‡∏ô (‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)
    }
    
    ----------------------------------------------------------------
    -- KNIT SETUP
    ----------------------------------------------------------------
    local KnitPackage = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit")
    local Knit = require(KnitPackage)
    
    if not Knit.OnStart then 
        pcall(function() Knit.Start():await() end)
    end
    
    local CodexService = nil
    
    pcall(function()
        CodexService = Knit.GetService("CodexService")
    end)
    
    local SERVICES = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")
    
    local CLAIM_ORE_RF = nil
    pcall(function()
        CLAIM_ORE_RF = SERVICES:WaitForChild("CodexService", 5):WaitForChild("RF", 3):WaitForChild("ClaimOre", 3)
    end)
    
    local CLAIM_ENEMY_RF = nil
    pcall(function()
        CLAIM_ENEMY_RF = SERVICES:WaitForChild("CodexService", 5):WaitForChild("RF", 3):WaitForChild("ClaimEnemy", 3)
    end)
    
    local CLAIM_EQUIPMENT_RF = nil
    pcall(function()
        CLAIM_EQUIPMENT_RF = SERVICES:WaitForChild("CodexService", 5):WaitForChild("RF", 3):WaitForChild("ClaimEquipment", 3)
    end)
    
    if CodexService then print("‚úÖ CodexService Ready!") else warn("‚ö†Ô∏è CodexService not found") end
    if CLAIM_ORE_RF then print("‚úÖ ClaimOre Remote Ready!") else warn("‚ö†Ô∏è ClaimOre Remote not found") end
    if CLAIM_ENEMY_RF then print("‚úÖ ClaimEnemy Remote Ready!") else warn("‚ö†Ô∏è ClaimEnemy Remote not found") end
    if CLAIM_EQUIPMENT_RF then print("‚úÖ ClaimEquipment Remote Ready!") else warn("‚ö†Ô∏è ClaimEquipment Remote not found") end
    
    ----------------------------------------------------------------
    -- GOLD SYSTEM
    ----------------------------------------------------------------
    local function getPlayerGold()
        print("   üîç Checking player gold...")
        
        -- Path: PlayerGui.Main.Screen.Hud.Gold
        local goldLabel = playerGui:FindFirstChild("Main")
                         and playerGui.Main:FindFirstChild("Screen")
                         and playerGui.Main.Screen:FindFirstChild("Hud")
                         and playerGui.Main.Screen.Hud:FindFirstChild("Gold")
        
        if not goldLabel then
            warn("   ‚ùå Gold Label not found!")
            warn("   üí° Path: PlayerGui.Main.Screen.Hud.Gold")
            return nil
        end
        
        if not goldLabel:IsA("TextLabel") then
            warn("   ‚ùå Gold is not a TextLabel!")
            return nil
        end
        
        local goldText = goldLabel.Text
        if DEBUG_MODE then
            print(string.format("   üìä Gold Text: '%s'", goldText))
        end
        
        -- ‡πÅ‡∏¢‡∏Å Gold ‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° (‡πÄ‡∏ä‡πà‡∏ô "$3,722.72" ‚Üí 3722.72)
        -- ‡∏•‡∏ö $ ‡πÅ‡∏•‡∏∞ , ‡∏≠‡∏≠‡∏Å ‡πÅ‡∏•‡πâ‡∏ß convert ‡πÄ‡∏õ‡πá‡∏ô number
        local goldString = string.gsub(goldText, "[$,]", "")
        local gold = tonumber(goldString)
        
        if gold then
            print(string.format("   ‚úÖ Player Gold: $%.2f", gold))
            return gold
        else
            warn("   ‚ùå Failed to parse gold from text!")
            return nil
        end
    end
    
    local function shouldClaimIndex()
        local gold = getPlayerGold()
        
        if not gold then
            warn("   ‚ùå Cannot determine player gold!")
            return false
        end
        
        if gold < QUEST_CONFIG.MIN_GOLD then
            print(string.format("   ‚úÖ Gold $%.2f < $%d - Should claim index!", gold, QUEST_CONFIG.MIN_GOLD))
            return true
        else
            print(string.format("   ‚è∏Ô∏è  Gold $%.2f >= $%d - No need to claim", gold, QUEST_CONFIG.MIN_GOLD))
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- INDEX UI HELPERS
    ----------------------------------------------------------------
    local function getIndexUI()
        local indexUI = playerGui:FindFirstChild("Menu")
                       and playerGui.Menu:FindFirstChild("Frame")
                       and playerGui.Menu.Frame:FindFirstChild("Frame")
                       and playerGui.Menu.Frame.Frame:FindFirstChild("Menus")
                       and playerGui.Menu.Frame.Frame.Menus:FindFirstChild("Index")
        
        if not indexUI then
            warn("   ‚ùå Index UI not found!")
            warn("   üí° Path: PlayerGui.Menu.Frame.Frame.Menus.Index")
            return nil
        end
        
        return indexUI
    end
    
    local function getOresPage()
        local indexUI = getIndexUI()
        if not indexUI then return nil end
        
        local pages = indexUI:FindFirstChild("Pages")
        if not pages then
            warn("   ‚ùå Pages not found!")
            return nil
        end
        
        local oresPage = pages:FindFirstChild("Ores")
        if not oresPage then
            warn("   ‚ùå Ores page not found!")
            return nil
        end
        
        return oresPage
    end
    
    local function getEnemiesPage()
        local indexUI = getIndexUI()
        if not indexUI then return nil end
        
        local pages = indexUI:FindFirstChild("Pages")
        if not pages then return nil end
        
        local enemiesPage = pages:FindFirstChild("Enemies")
        if not enemiesPage then
            warn("   ‚ùå Enemies page not found!")
            return nil
        end
        
        local scrollingFrame = enemiesPage:FindFirstChild("ScrollingFrame")
        if not scrollingFrame then
            warn("   ‚ùå Enemies ScrollingFrame not found!")
            return nil
        end
        
        return scrollingFrame
    end
    
    local function getEquipmentsPage()
        local indexUI = getIndexUI()
        if not indexUI then return nil end
        
        local pages = indexUI:FindFirstChild("Pages")
        if not pages then return nil end
        
        local equipmentsPage = pages:FindFirstChild("Equipments")
        if not equipmentsPage then
            warn("   ‚ùå Equipments page not found!")
            return nil
        end
        
        local scrollingFrame = equipmentsPage:FindFirstChild("ScrollingFrame")
        if not scrollingFrame then
            warn("   ‚ùå Equipments ScrollingFrame not found!")
            return nil
        end
        
        return scrollingFrame
    end
    
    ----------------------------------------------------------------
    -- ORE CLAIM SYSTEM
    ----------------------------------------------------------------
    local function findClaimableOres()
        local claimableOres = {}
        
        print("\nü™® Scanning for claimable Ores...")
        
        local oresPage = getOresPage()
        if not oresPage then
            warn("   ‚ùå Cannot access Ores page!")
            return claimableOres
        end
        
        -- ‡∏ß‡∏ô loop ‡∏´‡∏≤ Map Lists (‡πÄ‡∏ä‡πà‡∏ô "Iron Valley List")
        for _, child in ipairs(oresPage:GetChildren()) do
            if string.find(child.Name, "List$") then  -- ‡∏•‡∏á‡∏ó‡πâ‡∏≤‡∏¢‡∏î‡πâ‡∏ß‡∏¢ "List"
                if DEBUG_MODE then
                    print(string.format("   üìÅ Found Map List: %s", child.Name))
                end
                
                -- ‡∏ß‡∏ô loop ‡∏´‡∏≤ Ore ‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞ Map
                for _, oreItem in ipairs(child:GetChildren()) do
                    if oreItem:IsA("Frame") or oreItem:IsA("GuiObject") then
                        local main = oreItem:FindFirstChild("Main")
                        if main then
                            local claimButton = main:FindFirstChild("Claim")
                            if claimButton then
                                local oreName = oreItem.Name
                                
                                if DEBUG_MODE then
                                    print(string.format("      ‚úÖ Claimable: %s (Map: %s)", oreName, child.Name))
                                end
                                
                                table.insert(claimableOres, {
                                    Name = oreName,
                                    MapList = child.Name,
                                    Frame = oreItem,
                                })
                            end
                        end
                    end
                end
            end
        end
        
        print(string.format("   üìä Found %d claimable ores", #claimableOres))
        
        return claimableOres
    end
    
    local function claimOre(oreName)
        if not CLAIM_ORE_RF then
            warn("   ‚ùå ClaimOre Remote not available!")
            return false
        end
        
        if DEBUG_MODE then
            print(string.format("   ü™® Claiming ore: %s", oreName))
        end
        
        local success, result = pcall(function()
            return CLAIM_ORE_RF:InvokeServer(oreName)
        end)
        
        if success then
            print(string.format("   ‚úÖ Claimed: %s", oreName))
            return true
        else
            warn(string.format("   ‚ùå Failed to claim %s: %s", oreName, tostring(result)))
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- ENEMY CLAIM SYSTEM
    ----------------------------------------------------------------
    local function findClaimableEnemies()
        local claimableEnemies = {}
        
        print("\nüëπ Scanning for claimable Enemies...")
        
        local enemiesPage = getEnemiesPage()
        if not enemiesPage then
            warn("   ‚ùå Cannot access Enemies page!")
            return claimableEnemies
        end
        
        -- ‡∏ß‡∏ô loop ‡∏´‡∏≤ Map Lists (‡πÄ‡∏ä‡πà‡∏ô "Iron Valley List")
        for _, child in ipairs(enemiesPage:GetChildren()) do
            if string.find(child.Name, "List$") then  -- ‡∏•‡∏á‡∏ó‡πâ‡∏≤‡∏¢‡∏î‡πâ‡∏ß‡∏¢ "List"
                if DEBUG_MODE then
                    print(string.format("   üìÅ Found Map List: %s", child.Name))
                end
                
                -- ‡∏ß‡∏ô loop ‡∏´‡∏≤ Enemy ‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞ Map
                for _, enemyItem in ipairs(child:GetChildren()) do
                    if enemyItem:IsA("Frame") or enemyItem:IsA("GuiObject") then
                        local main = enemyItem:FindFirstChild("Main")
                        if main then
                            local claimButton = main:FindFirstChild("Claim")
                            if claimButton then
                                local enemyName = enemyItem.Name
                                
                                if DEBUG_MODE then
                                    print(string.format("      ‚úÖ Claimable: %s (Map: %s)", enemyName, child.Name))
                                end
                                
                                table.insert(claimableEnemies, {
                                    Name = enemyName,
                                    MapList = child.Name,
                                    Frame = enemyItem,
                                })
                            end
                        end
                    end
                end
            end
        end
        
        print(string.format("   üìä Found %d claimable enemies", #claimableEnemies))
        
        return claimableEnemies
    end
    
    local function claimEnemy(enemyName)
        if not CLAIM_ENEMY_RF then
            warn("   ‚ùå ClaimEnemy Remote not available!")
            return false
        end
        
        if DEBUG_MODE then
            print(string.format("   üëπ Claiming enemy: %s", enemyName))
        end
        
        local success, result = pcall(function()
            return CLAIM_ENEMY_RF:InvokeServer(enemyName)
        end)
        
        if success then
            print(string.format("   ‚úÖ Claimed: %s", enemyName))
            return true
        else
            warn(string.format("   ‚ùå Failed to claim %s: %s", enemyName, tostring(result)))
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- EQUIPMENT CLAIM SYSTEM
    ----------------------------------------------------------------
    local function findClaimableEquipments()
        local claimableEquipments = {}
        
        print("\n‚öîÔ∏è Scanning for claimable Equipments...")
        
        local equipmentsPage = getEquipmentsPage()
        if not equipmentsPage then
            warn("   ‚ùå Cannot access Equipments page!")
            return claimableEquipments
        end
        
        -- ‡∏ß‡∏ô loop ‡∏´‡∏≤‡∏ó‡∏±‡πâ‡∏á Direct Items ‡πÅ‡∏•‡∏∞ Lists
        for _, child in ipairs(equipmentsPage:GetChildren()) do
            -- ‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà 1: ‡πÄ‡∏õ‡πá‡∏ô List (‡πÄ‡∏ä‡πà‡∏ô "MediumHelmet List")
            if string.find(child.Name, "List$") then
                if DEBUG_MODE then
                    print(string.format("   üìÅ Found Equipment List: %s", child.Name))
                end
                
                -- ‡∏ß‡∏ô loop ‡∏´‡∏≤ Equipment ‡∏Ç‡πâ‡∏≤‡∏á‡πÉ‡∏ô List
                for _, equipItem in ipairs(child:GetChildren()) do
                    if equipItem:IsA("Frame") or equipItem:IsA("GuiObject") then
                        local main = equipItem:FindFirstChild("Main")
                        if main then
                            local claimButton = main:FindFirstChild("Claim")
                            if claimButton then
                                local equipName = equipItem.Name
                                
                                if DEBUG_MODE then
                                    print(string.format("      ‚úÖ Claimable: %s (List: %s)", equipName, child.Name))
                                end
                                
                                table.insert(claimableEquipments, {
                                    Name = equipName,
                                    ListName = child.Name,
                                    Frame = equipItem,
                                })
                            end
                        end
                    end
                end
            else
                -- ‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà 2: ‡πÄ‡∏õ‡πá‡∏ô Direct Item (‡πÄ‡∏ä‡πà‡∏ô "ColossalSword", "Gauntlet")
                if child:IsA("Frame") or child:IsA("GuiObject") then
                    local main = child:FindFirstChild("Main")
                    if main then
                        local claimButton = main:FindFirstChild("Claim")
                        if claimButton then
                            local equipName = child.Name
                            
                            if DEBUG_MODE then
                                print(string.format("   ‚úÖ Claimable: %s (Direct)", equipName))
                            end
                            
                            table.insert(claimableEquipments, {
                                Name = equipName,
                                ListName = nil,  -- Direct item, no list
                                Frame = child,
                            })
                        end
                    end
                end
            end
        end
        
        print(string.format("   üìä Found %d claimable equipments", #claimableEquipments))
        
        return claimableEquipments
    end
    
    local function claimEquipment(equipmentName)
        if not CLAIM_EQUIPMENT_RF then
            warn("   ‚ùå ClaimEquipment Remote not available!")
            return false
        end
        
        if DEBUG_MODE then
            print(string.format("   ‚öîÔ∏è Claiming equipment: %s", equipmentName))
        end
        
        local success, result = pcall(function()
            return CLAIM_EQUIPMENT_RF:InvokeServer(equipmentName)
        end)
        
        if success then
            print(string.format("   ‚úÖ Claimed: %s", equipmentName))
            return true
        else
            warn(string.format("   ‚ùå Failed to claim %s: %s", equipmentName, tostring(result)))
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- MAIN CLAIM EXECUTION
    ----------------------------------------------------------------
    local function claimAllIndex()
        print("üìú Auto Claiming Index...")
        
        local totalClaimed = 0
        local totalFailed = 0
        
        -- 1. Claim Ores
        print("\n" .. string.rep("=", 50))
        print("ü™® CLAIMING ORES")
        print(string.rep("=", 50))
        
        local claimableOres = findClaimableOres()
        
        for i, ore in ipairs(claimableOres) do
            print(string.format("\n[%d/%d] Claiming %s...", i, #claimableOres, ore.Name))
            
            local success = claimOre(ore.Name)
            
            if success then
                totalClaimed = totalClaimed + 1
            else
                totalFailed = totalFailed + 1
            end
            
            task.wait(QUEST_CONFIG.CLAIM_DELAY)
        end
        
        -- 2. Claim Enemies
        print("\n" .. string.rep("=", 50))
        print("üëπ CLAIMING ENEMIES")
        print(string.rep("=", 50))
        
        local claimableEnemies = findClaimableEnemies()
        
        for i, enemy in ipairs(claimableEnemies) do
            print(string.format("\n[%d/%d] Claiming %s...", i, #claimableEnemies, enemy.Name))
            
            local success = claimEnemy(enemy.Name)
            
            if success then
                totalClaimed = totalClaimed + 1
            else
                totalFailed = totalFailed + 1
            end
            
            task.wait(QUEST_CONFIG.CLAIM_DELAY)
        end
        
        -- 3. Claim Equipments
        print("\n" .. string.rep("=", 50))
        print("‚öîÔ∏è CLAIMING EQUIPMENTS")
        print(string.rep("=", 50))
        
        local claimableEquipments = findClaimableEquipments()
        
        for i, equipment in ipairs(claimableEquipments) do
            print(string.format("\n[%d/%d] Claiming %s...", i, #claimableEquipments, equipment.Name))
            
            local success = claimEquipment(equipment.Name)
            
            if success then
                totalClaimed = totalClaimed + 1
            else
                totalFailed = totalFailed + 1
            end
            
            task.wait(QUEST_CONFIG.CLAIM_DELAY)
        end
        
        -- Summary
        print("\n" .. string.rep("=", 50))
        print("üìä CLAIM SUMMARY")
        print(string.rep("=", 50))
        print(string.format("   ‚úÖ Successfully Claimed: %d", totalClaimed))
        print(string.format("   ‚ùå Failed: %d", totalFailed))
        print(string.rep("=", 50))
        
        return totalClaimed > 0
    end
    
    ----------------------------------------------------------------
    -- SMART QUEST RUNNER
    ----------------------------------------------------------------
    local function RunQuest15()
        print(string.rep("=", 50))
        print("üöÄ QUEST 15: " .. QUEST_CONFIG.QUEST_NAME)
        print("üéØ Objective: Auto Claim Index (Codex)")
        print(string.format("‚úÖ Strategy: Check Gold ‚Üí Claim All Index"))
        print(string.rep("=", 50))
        
        -- ‡πÄ‡∏ä‡πá‡∏Ñ Gold ‡∏Å‡πà‡∏≠‡∏ô
        print("\nüîç Pre-check: Verifying gold requirement...")
        if not shouldClaimIndex() then
            print("\n‚úÖ No need to claim (Gold sufficient)")
            print(string.rep("=", 50))
            return
        end
        
        -- ‡∏ñ‡πâ‡∏≤ Gold ‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ MIN_GOLD ‡πÉ‡∏´‡πâ Claim
        local maxAttempts = 1  -- ‡∏ó‡∏≥‡πÅ‡∏Ñ‡πà‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
        local attempt = 0
        
        while Quest15Active and attempt < maxAttempts do
            attempt = attempt + 1
            print(string.format("\nüîÑ Attempt #%d", attempt))
            
            local success = claimAllIndex()
            
            if success then
                print("\n‚úÖ Claiming complete!")
                
                -- ‡πÄ‡∏ä‡πá‡∏Ñ Gold ‡∏´‡∏•‡∏±‡∏á Claim
                task.wait(2)
                local newGold = getPlayerGold()
                if newGold then
                    print(string.format("\nüí∞ New Gold: $%.2f", newGold))
                end
                
                break
            else
                warn("\n‚ùå No items claimed or all failed")
                break
            end
        end
        
        task.wait(1)
        
        print("\n" .. string.rep("=", 50))
        print("‚úÖ Quest 15 Complete!")
        print(string.rep("=", 50))
        
        Quest15Active = false
    end
    
    ----------------------------------------------------------------
    -- START
    ----------------------------------------------------------------
    RunQuest15()
end

----------------------------------------------------------------
-- QUEST 16 ORIGINAL (from 16.lua)
----------------------------------------------------------------
local function RunQuest16()
    -- QUEST 16: Auto Buy Pickaxe (Gold-based)
    -- ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ Gold > 3340
    -- ‚úÖ Move ‡πÑ‡∏õ‡∏ó‡∏µ‡πà Shop (-32.6, -2.0, -269.3)
    -- ‚úÖ ‡∏ã‡∏∑‡πâ‡∏≠ "Stonewake's Pickaxe" x1
    -- ‚úÖ Auto Purchase
    
    
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Workspace = game:GetService("Workspace")
    
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    ----------------------------------------------------------------
    -- CONFIG
    ----------------------------------------------------------------
    local Quest16Active = true
    local DEBUG_MODE = true
    
    local QUEST_CONFIG = {
        QUEST_NAME = "Auto Buy Pickaxe",
        MIN_GOLD = 3340,  -- ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ Gold >= 3340
        
        -- Shop Location
        SHOP_POSITION = Vector3.new(-32.6, -2.0, -269.3),
        
        -- Purchase Item
        ITEM_NAME = "Stonewake's Pickaxe",
        ITEM_QUANTITY = 1,
        
        MOVE_SPEED = 20,
        STOP_DISTANCE = 5,
    }
    
    ----------------------------------------------------------------
    -- KNIT SETUP
    ----------------------------------------------------------------
    local KnitPackage = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit")
    local Knit = require(KnitPackage)
    
    if not Knit.OnStart then 
        pcall(function() Knit.Start():await() end)
    end
    
    local PlayerController = nil
    local ProximityService = nil
    
    pcall(function()
        PlayerController = Knit.GetController("PlayerController")
        ProximityService = Knit.GetService("ProximityService")
    end)
    
    local SERVICES = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")
    
    local PURCHASE_RF = nil
    pcall(function()
        PURCHASE_RF = SERVICES:WaitForChild("ProximityService", 5):WaitForChild("RF", 3):WaitForChild("Purchase", 3)
    end)
    
    if PlayerController then print("‚úÖ PlayerController Ready!") else warn("‚ö†Ô∏è PlayerController not found") end
    if ProximityService then print("‚úÖ ProximityService Ready!") else warn("‚ö†Ô∏è ProximityService not found") end
    if PURCHASE_RF then print("‚úÖ Purchase Remote Ready!") else warn("‚ö†Ô∏è Purchase Remote not found") end
    
    ----------------------------------------------------------------
    -- STATE MANAGEMENT
    ----------------------------------------------------------------
    local State = {
        noclipConn = nil,
        moveConn = nil,
        bodyVelocity = nil,
        bodyGyro = nil,
    }
    
    local function cleanupState()
        if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
    end
    
    ----------------------------------------------------------------
    -- GOLD SYSTEM
    ----------------------------------------------------------------
    local function getPlayerGold()
        print("   üîç Checking player gold...")
        
        -- Path: PlayerGui.Main.Screen.Hud.Gold
        local goldLabel = playerGui:FindFirstChild("Main")
                         and playerGui.Main:FindFirstChild("Screen")
                         and playerGui.Main.Screen:FindFirstChild("Hud")
                         and playerGui.Main.Screen.Hud:FindFirstChild("Gold")
        
        if not goldLabel then
            warn("   ‚ùå Gold Label not found!")
            warn("   üí° Path: PlayerGui.Main.Screen.Hud.Gold")
            return nil
        end
        
        if not goldLabel:IsA("TextLabel") then
            warn("   ‚ùå Gold is not a TextLabel!")
            return nil
        end
        
        local goldText = goldLabel.Text
        if DEBUG_MODE then
            print(string.format("   üìä Gold Text: '%s'", goldText))
        end
        
        -- ‡πÅ‡∏¢‡∏Å Gold ‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° (‡πÄ‡∏ä‡πà‡∏ô "$3,722.72" ‚Üí 3722.72)
        local goldString = string.gsub(goldText, "[$,]", "")
        local gold = tonumber(goldString)
        
        if gold then
            print(string.format("   ‚úÖ Player Gold: $%.2f", gold))
            return gold
        else
            warn("   ‚ùå Failed to parse gold from text!")
            return nil
        end
    end
    
    local function hasEnoughGold()
        local gold = getPlayerGold()
        
        if not gold then
            warn("   ‚ùå Cannot determine player gold!")
            return false
        end
        
        if gold >= QUEST_CONFIG.MIN_GOLD then
            print(string.format("   ‚úÖ Gold $%.2f >= $%d - Can purchase!", gold, QUEST_CONFIG.MIN_GOLD))
            return true
        else
            print(string.format("   ‚è∏Ô∏è  Gold $%.2f < $%d - Not enough gold", gold, QUEST_CONFIG.MIN_GOLD))
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- NOCLIP & MOVEMENT
    ----------------------------------------------------------------
    local function enableNoclip()
        if State.noclipConn then return end
        
        local char = player.Character
        if not char then return end
        
        State.noclipConn = RunService.Stepped:Connect(function()
            if not char or not char.Parent then
                if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
                return
            end
            
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end
    
    local function disableNoclip()
        if State.noclipConn then
            State.noclipConn:Disconnect()
            State.noclipConn = nil
        end
    end
    
    local function smoothMoveTo(targetPos, callback)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        enableNoclip()
        
        local bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Parent = hrp
        State.bodyVelocity = bv
        
        local bg = Instance.new("BodyGyro")
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.P = 10000
        bg.D = 500
        bg.Parent = hrp
        State.bodyGyro = bg
        
        print(string.format("   üöÄ Moving to (%.1f, %.1f, %.1f)...", targetPos.X, targetPos.Y, targetPos.Z))
        
        State.moveConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                if bv then bv:Destroy() end
                if bg then bg:Destroy() end
                State.bodyVelocity = nil
                State.bodyGyro = nil
                return
            end
            
            local currentPos = hrp.Position
            local direction = (targetPos - currentPos)
            local distance = direction.Magnitude
            
            if distance < QUEST_CONFIG.STOP_DISTANCE then
                print("   ‚úÖ Reached target!")
                
                bv.Velocity = Vector3.zero
                task.wait(0.1)
                
                bv:Destroy()
                bg:Destroy()
                State.bodyVelocity = nil
                State.bodyGyro = nil
                
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                
                if callback then callback() end
                return
            end
            
            local speed = math.min(QUEST_CONFIG.MOVE_SPEED, distance * 10)
            local velocity = direction.Unit * speed
            
            bv.Velocity = velocity
            bg.CFrame = CFrame.lookAt(currentPos, targetPos)
        end)
        
        return true
    end
    
    ----------------------------------------------------------------
    -- PURCHASE SYSTEM
    ----------------------------------------------------------------
    local function purchaseItem(itemName, quantity)
        if not PURCHASE_RF then
            warn("   ‚ùå Purchase Remote not available!")
            return false
        end
        
        print(string.format("   üõí Purchasing: %s x%d", itemName, quantity))
        
        local success, result = pcall(function()
            return PURCHASE_RF:InvokeServer(itemName, quantity)
        end)
        
        if success then
            print(string.format("   ‚úÖ Purchased: %s x%d", itemName, quantity))
            return true
        else
            warn(string.format("   ‚ùå Failed to purchase %s: %s", itemName, tostring(result)))
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- INVENTORY CHECK
    ----------------------------------------------------------------
    local function hasPickaxe(pickaxeName)
        if not PlayerController or not PlayerController.Replica then
            warn("   ‚ùå PlayerController/Replica not available!")
            return false
        end
        
        local replica = PlayerController.Replica
        if not replica.Data or not replica.Data.Inventory or not replica.Data.Inventory.Equipments then
            warn("   ‚ùå Equipments not found in Replica!")
            return false
        end
        
        local equipments = replica.Data.Inventory.Equipments
        
        for id, item in pairs(equipments) do
            if type(item) == "table" and item.Type then
                if item.Type == pickaxeName then
                    print(string.format("   ‚úÖ Already have: %s", pickaxeName))
                    return true
                end
            end
        end
        
        return false
    end
    
    ----------------------------------------------------------------
    -- MAIN QUEST EXECUTION
    ----------------------------------------------------------------
    local function doBuyPickaxe()
        print("üõí Objective: Buy Pickaxe...")
        
        -- 1. ‡πÄ‡∏ä‡πá‡∏Ñ Gold
        print("\nüí∞ Checking gold...")
        if not hasEnoughGold() then
            warn("   ‚ùå Not enough gold to purchase!")
            return false
        end
        
        -- 2. ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ Pickaxe ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
        print("\nüîç Checking inventory...")
        if hasPickaxe(QUEST_CONFIG.ITEM_NAME) then
            print("   ‚úÖ Already have the pickaxe!")
            return true
        end
        
        -- 3. Move ‡πÑ‡∏õ‡∏ó‡∏µ‡πà Shop
        local shopPos = QUEST_CONFIG.SHOP_POSITION
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        
        if hrp then
            local currentDist = (shopPos - hrp.Position).Magnitude
            print(string.format("   üö∂ Moving to Shop at (%.1f, %.1f, %.1f) (%.1f studs away)...", 
                shopPos.X, shopPos.Y, shopPos.Z, currentDist))
        end
        
        local moveComplete = false
        smoothMoveTo(shopPos, function()
            moveComplete = true
        end)
        
        local timeout = 30
        local startTime = tick()
        while not moveComplete and tick() - startTime < timeout do
            task.wait(0.1)
        end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        if not moveComplete then
            warn("   ‚ö†Ô∏è Failed to reach Shop")
            return false
        end
        
        print("   ‚úÖ Reached Shop!")
        task.wait(1)
        
        -- 4. ‡∏ã‡∏∑‡πâ‡∏≠ Pickaxe
        print("\nüõí Purchasing pickaxe...")
        local purchaseSuccess = purchaseItem(QUEST_CONFIG.ITEM_NAME, QUEST_CONFIG.ITEM_QUANTITY)
        
        if not purchaseSuccess then
            warn("   ‚ùå Failed to purchase pickaxe")
            return false
        end
        
        print("   ‚úÖ Purchase complete!")
        
        -- 5. ‡πÄ‡∏ä‡πá‡∏Ñ Gold ‡∏´‡∏•‡∏±‡∏á‡∏ã‡∏∑‡πâ‡∏≠
        task.wait(1)
        local newGold = getPlayerGold()
        if newGold then
            print(string.format("\nüí∞ Gold after purchase: $%.2f", newGold))
        end
        
        -- 6. ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡πÑ‡∏î‡πâ Pickaxe ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
        task.wait(1)
        if hasPickaxe(QUEST_CONFIG.ITEM_NAME) then
            print(string.format("   ‚úÖ Successfully obtained: %s", QUEST_CONFIG.ITEM_NAME))
            return true
        else
            warn("   ‚ö†Ô∏è Purchase successful but item not found in inventory")
            return true  -- ‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÄ‡∏û‡∏£‡∏≤‡∏∞ Remote ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
        end
    end
    
    ----------------------------------------------------------------
    -- SMART QUEST RUNNER
    ----------------------------------------------------------------
    local function RunQuest16()
        print(string.rep("=", 50))
        print("üöÄ QUEST 16: " .. QUEST_CONFIG.QUEST_NAME)
        print("üéØ Objective: Buy Pickaxe")
        print(string.format("‚úÖ Strategy: Check Gold ‚Üí Move to Shop ‚Üí Purchase"))
        print(string.rep("=", 50))
        
        -- ‡πÄ‡∏ä‡πá‡∏Ñ Gold ‡∏Å‡πà‡∏≠‡∏ô
        print("\nüîç Pre-check: Verifying gold requirement...")
        if not hasEnoughGold() then
            print("\n‚ùå Not enough gold (Need >= $" .. QUEST_CONFIG.MIN_GOLD .. ")")
            print(string.rep("=", 50))
            cleanupState()
            disableNoclip()
            return
        end
        
        -- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ Pickaxe ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
        print("\nüîç Pre-check: Checking if already have pickaxe...")
        if hasPickaxe(QUEST_CONFIG.ITEM_NAME) then
            print("\n‚úÖ Already have the pickaxe!")
            print(string.rep("=", 50))
            cleanupState()
            disableNoclip()
            return
        end
        
        -- ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ Gold ‡∏û‡∏≠ ‡πÅ‡∏•‡∏∞‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ Pickaxe ‡πÉ‡∏´‡πâ‡∏ã‡∏∑‡πâ‡∏≠
        local maxAttempts = 3
        local attempt = 0
        
        while Quest16Active and attempt < maxAttempts do
            attempt = attempt + 1
            print(string.format("\nüîÑ Attempt #%d", attempt))
            
            local success = doBuyPickaxe()
            
            if success then
                print("\n‚úÖ Purchase complete!")
                break
            else
                warn("\n‚ùå Purchase failed, retrying in 3s...")
                task.wait(3)
            end
        end
        
        task.wait(1)
        
        print("\n" .. string.rep("=", 50))
        print("‚úÖ Quest 16 Complete!")
        print(string.rep("=", 50))
        
        Quest16Active = false
        cleanupState()
        disableNoclip()
    end
    
    ----------------------------------------------------------------
    -- START
    ----------------------------------------------------------------
    RunQuest16()
end

----------------------------------------------------------------
-- QUEST 17 ORIGINAL (from 17.lua)
----------------------------------------------------------------
local function RunQuest17()
    -- QUEST 17: Auto Mining Until Level 10 (FIXED - Smooth Movement)
    -- ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ Level < 10
    -- ‚úÖ ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ó‡∏∏‡∏Å Boulder ‡πÉ‡∏ô workspace.Rocks
    -- ‚úÖ Smooth transition ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏£‡πà (‡πÑ‡∏°‡πà‡∏ï‡∏Å Map)
    -- ‚úÖ Loop ‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤ Level = 10
    
    
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local Workspace = game:GetService("Workspace")
    
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    ----------------------------------------------------------------
    -- CONFIG
    ----------------------------------------------------------------
    local Quest17Active = true
    local IsMiningActive = false
    local DEBUG_MODE = true
    
    local QUEST_CONFIG = {
        QUEST_NAME = "Auto Mining Until Level 10",
        TARGET_LEVEL = 10,  -- ‡∏Ç‡∏∏‡∏î‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤ Level ‡∏à‡∏∞ = 10
        
        -- Rock Settings
        ROCK_NAME = "Boulder",  -- ‡∏ä‡∏∑‡πà‡∏≠‡πÅ‡∏£‡πà‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ç‡∏∏‡∏î
        
        UNDERGROUND_OFFSET = 4,
        LAYING_ANGLE = 90,
        MOVE_SPEED = 20,
        
        -- Smooth Movement Settings
        HOLD_POSITION_AFTER_MINE = true,  -- ‡∏Ñ‡πâ‡∏≤‡∏á Position ‡∏´‡∏•‡∏±‡∏á‡∏Ç‡∏∏‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à
        RESPAWN_WAIT_TIME = 3,  -- ‡∏£‡∏≠ Respawn (‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)
    }
    
    ----------------------------------------------------------------
    -- KNIT SETUP
    ----------------------------------------------------------------
    local KnitPackage = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit")
    local Knit = require(KnitPackage)
    
    if not Knit.OnStart then 
        pcall(function() Knit.Start():await() end)
    end
    
    local CharacterService = nil
    local PlayerController = nil
    
    pcall(function()
        CharacterService = Knit.GetService("CharacterService")
        PlayerController = Knit.GetController("PlayerController")
    end)
    
    local ToolController = nil
    local ToolActivatedFunc = nil
    
    pcall(function()
        for _, v in pairs(getgc(true)) do
            if type(v) == "table" then
                if rawget(v, "Name") == "ToolController" and rawget(v, "ToolActivated") then
                    ToolController = v
                    ToolActivatedFunc = v.ToolActivated
                    break
                end
            end
        end
    end)
    
    local SERVICES = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")
    
    local CHAR_RF = nil
    pcall(function()
        CHAR_RF = SERVICES:WaitForChild("CharacterService", 5):WaitForChild("RF", 3):WaitForChild("EquipItem", 3)
    end)
    
    local TOOL_RF_BACKUP = nil
    pcall(function()
        TOOL_RF_BACKUP = SERVICES:WaitForChild("ToolService", 5):WaitForChild("RF", 3):WaitForChild("ToolActivated", 3)
    end)
    
    local MINING_FOLDER_PATH = Workspace:WaitForChild("Rocks")
    
    if CharacterService then print("‚úÖ CharacterService Ready!") else warn("‚ö†Ô∏è CharacterService not found") end
    if PlayerController then print("‚úÖ PlayerController Ready!") else warn("‚ö†Ô∏è PlayerController not found") end
    if ToolController then print("‚úÖ ToolController Ready!") else warn("‚ö†Ô∏è ToolController not found") end
    
    ----------------------------------------------------------------
    -- STATE MANAGEMENT
    ----------------------------------------------------------------
    local State = {
        currentTarget = nil,
        targetDestroyed = false,
        hpWatchConn = nil,
        noclipConn = nil,
        moveConn = nil,
        positionLockConn = nil,
        bodyVelocity = nil,
        bodyGyro = nil,
    }
    
    local function cleanupState()
        if State.hpWatchConn then State.hpWatchConn:Disconnect() State.hpWatchConn = nil end
        if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.positionLockConn then State.positionLockConn:Disconnect() State.positionLockConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        State.currentTarget = nil
        State.targetDestroyed = false
        
        if ToolController then
            ToolController.holdingM1 = false
        end
    end
    
    ----------------------------------------------------------------
    -- LEVEL SYSTEM
    ----------------------------------------------------------------
    local function getPlayerLevel()
        -- Path: PlayerGui.Main.Screen.Hud.Level
        local levelLabel = playerGui:FindFirstChild("Main")
                          and playerGui.Main:FindFirstChild("Screen")
                          and playerGui.Main.Screen:FindFirstChild("Hud")
                          and playerGui.Main.Screen.Hud:FindFirstChild("Level")
        
        if not levelLabel or not levelLabel:IsA("TextLabel") then
            return nil
        end
        
        local levelText = levelLabel.Text
        local level = tonumber(string.match(levelText, "%d+"))
        
        return level
    end
    
    local function shouldMine()
        local level = getPlayerLevel()
        
        if not level then
            warn("   ‚ùå Cannot determine player level!")
            return false
        end
        
        if level < QUEST_CONFIG.TARGET_LEVEL then
            return true
        else
            print(string.format("   ‚è∏Ô∏è  Level %d >= %d - Stop mining", level, QUEST_CONFIG.TARGET_LEVEL))
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- HELPER FUNCTIONS
    ----------------------------------------------------------------
    local HOTKEY_MAP = {
        ["1"] = Enum.KeyCode.One,
        ["2"] = Enum.KeyCode.Two,
        ["3"] = Enum.KeyCode.Three,
        ["4"] = Enum.KeyCode.Four,
        ["5"] = Enum.KeyCode.Five,
        ["6"] = Enum.KeyCode.Six,
        ["7"] = Enum.KeyCode.Seven,
        ["8"] = Enum.KeyCode.Eight,
        ["9"] = Enum.KeyCode.Nine,
        ["0"] = Enum.KeyCode.Zero,
    }
    
    local function pressKey(keyCode)
        if not keyCode then return end
        VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
        task.wait(0.05)
        VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
    end
    
    local function findPickaxeSlotKey()
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil end
        
        local hotbar = gui:FindFirstChild("BackpackGui") 
                       and gui.BackpackGui:FindFirstChild("Backpack") 
                       and gui.BackpackGui.Backpack:FindFirstChild("Hotbar")
        
        if hotbar then
            for _, slotFrame in ipairs(hotbar:GetChildren()) do
                local frame = slotFrame:FindFirstChild("Frame")
                local label = frame and frame:FindFirstChild("ToolName")
                if label and label:IsA("TextLabel") and string.find(label.Text, "Pickaxe") then
                    return HOTKEY_MAP[slotFrame.Name]
                end
            end
        end
        
        return nil
    end
    
    local function checkMiningError()
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return false end
        
        local notif = gui:FindFirstChild("Notifications")
        if notif and notif:FindFirstChild("Screen") and notif.Screen:FindFirstChild("NotificationsFrame") then
            for _, child in ipairs(notif.Screen.NotificationsFrame:GetChildren()) do
                local lbl = child:FindFirstChild("TextLabel", true)
                if lbl and string.find(lbl.Text, "Someone else is already mining") then
                    return true
                end
            end
        end
        
        return false
    end
    
    ----------------------------------------------------------------
    -- ROCK HELPERS
    ----------------------------------------------------------------
    local function getRockUndergroundPosition(rockModel)
        if not rockModel or not rockModel.Parent then
            return nil
        end
        
        local pivotCFrame = nil
        pcall(function()
            if rockModel.GetPivot then
                pivotCFrame = rockModel:GetPivot()
            elseif rockModel.WorldPivot then
                pivotCFrame = rockModel.WorldPivot
            end
        end)
        
        if pivotCFrame then
            local pos = pivotCFrame.Position
            return Vector3.new(pos.X, pos.Y - QUEST_CONFIG.UNDERGROUND_OFFSET, pos.Z)
        end
        
        if rockModel.PrimaryPart then
            local pos = rockModel.PrimaryPart.Position
            return Vector3.new(pos.X, pos.Y - QUEST_CONFIG.UNDERGROUND_OFFSET, pos.Z)
        end
        
        local part = rockModel:FindFirstChildWhichIsA("BasePart")
        if part then
            local pos = part.Position
            return Vector3.new(pos.X, pos.Y - QUEST_CONFIG.UNDERGROUND_OFFSET, pos.Z)
        end
        
        return nil
    end
    
    local function getRockHP(rock)
        if not rock or not rock.Parent then
            return 0
        end
        
        local success, result = pcall(function()
            return rock:GetAttribute("Health") or 0
        end)
        
        return success and result or 0
    end
    
    local function isTargetValid(rock)
        if not rock or not rock.Parent then
            return false
        end
        
        if not rock:FindFirstChildWhichIsA("BasePart") then
            return false
        end
        
        local hp = getRockHP(rock)
        return hp > 0
    end
    
    local function findNearestBoulder(excludeRock)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return nil end
        
        local targetRock, minDist = nil, math.huge
        
        -- ‡∏ß‡∏ô loop ‡∏´‡∏≤‡∏ó‡∏∏‡∏Å Folder/Model ‡πÉ‡∏ô workspace.Rocks
        for _, folder in ipairs(MINING_FOLDER_PATH:GetChildren()) do
            if folder:IsA("Folder") or folder:IsA("Model") then
                -- ‡∏ß‡∏ô loop ‡∏´‡∏≤‡∏ó‡∏∏‡∏Å SpawnLocation ‡πÉ‡∏ô Folder
                for _, child in ipairs(folder:GetChildren()) do
                    if child:IsA("SpawnLocation") or child.Name == "SpawnLocation" then
                        -- ‡∏´‡∏≤ Boulder ‡πÉ‡∏ô SpawnLocation
                        local rock = child:FindFirstChild(QUEST_CONFIG.ROCK_NAME)
                        
                        -- ‡∏Ç‡πâ‡∏≤‡∏° Rock ‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏á‡∏Ç‡∏∏‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à
                        if rock ~= excludeRock and isTargetValid(rock) then
                            local pos = getRockUndergroundPosition(rock)
                            if pos then
                                local dist = (pos - hrp.Position).Magnitude
                                
                                if dist < minDist then
                                    minDist = dist
                                    targetRock = rock
                                end
                            end
                        end
                    end
                end
            end
        end
        
        return targetRock, minDist
    end
    
    local function watchRockHP(rock)
        if State.hpWatchConn then
            State.hpWatchConn:Disconnect()
        end
        
        if not rock then return end
        
        State.hpWatchConn = rock:GetAttributeChangedSignal("Health"):Connect(function()
            local hp = rock:GetAttribute("Health") or 0
            
            if hp <= 0 then
                print("   ‚úÖ Rock destroyed!")
                State.targetDestroyed = true
                
                if ToolController then
                    ToolController.holdingM1 = false
                end
            end
        end)
    end
    
    ----------------------------------------------------------------
    -- NOCLIP & MOVEMENT
    ----------------------------------------------------------------
    local function enableNoclip()
        if State.noclipConn then return end
        
        local char = player.Character
        if not char then return end
        
        State.noclipConn = RunService.Stepped:Connect(function()
            if not char or not char.Parent then
                if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
                return
            end
            
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end
    
    local function disableNoclip()
        if State.noclipConn then
            State.noclipConn:Disconnect()
            State.noclipConn = nil
        end
    end
    
    local function smoothMoveTo(targetPos, callback)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        enableNoclip()
        
        local bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Parent = hrp
        State.bodyVelocity = bv
        
        local bg = Instance.new("BodyGyro")
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.P = 10000
        bg.D = 500
        bg.Parent = hrp
        State.bodyGyro = bg
        
        print(string.format("   üöÄ Moving to (%.1f, %.1f, %.1f)...", targetPos.X, targetPos.Y, targetPos.Z))
        
        State.moveConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                if bv then bv:Destroy() end
                if bg then bg:Destroy() end
                State.bodyVelocity = nil
                State.bodyGyro = nil
                return
            end
            
            local currentPos = hrp.Position
            local direction = (targetPos - currentPos)
            local distance = direction.Magnitude
            
            if distance < 2 then
                print("   ‚úÖ Reached target!")
                
                bv.Velocity = Vector3.zero
                task.wait(0.1)
                
                bv:Destroy()
                bg:Destroy()
                State.bodyVelocity = nil
                State.bodyGyro = nil
                
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                
                if callback then callback() end
                return
            end
            
            local speed = math.min(QUEST_CONFIG.MOVE_SPEED, distance * 10)
            local velocity = direction.Unit * speed
            
            bv.Velocity = velocity
            bg.CFrame = CFrame.lookAt(currentPos, targetPos)
        end)
        
        return true
    end
    
    ----------------------------------------------------------------
    -- POSITION LOCK (SMOOTH TRANSITION)
    ----------------------------------------------------------------
    local function lockPositionLayingDown(targetPos)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        if State.positionLockConn then
            State.positionLockConn:Disconnect()
            State.positionLockConn = nil
        end
        
        local angle = math.rad(QUEST_CONFIG.LAYING_ANGLE)
        local baseCFrame = CFrame.new(targetPos)
        local layingCFrame = baseCFrame * CFrame.Angles(angle, 0, 0)
        
        State.positionLockConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.positionLockConn then
                    State.positionLockConn:Disconnect()
                    State.positionLockConn = nil
                end
                return
            end
            
            hrp.CFrame = layingCFrame
            hrp.Velocity = Vector3.zero
            hrp.AssemblyLinearVelocity = Vector3.zero
        end)
        
        print("   üîí Position locked")
    end
    
    local function transitionToNewTarget(newTargetPos)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        print(string.format("   üîÑ Smooth transition to new target..."))
        
        -- ‡πÉ‡∏ä‡πâ position lock ‡πÅ‡∏ö‡∏ö smooth ‡πÅ‡∏ó‡∏ô unlock
        if State.positionLockConn then
            State.positionLockConn:Disconnect()
            State.positionLockConn = nil
        end
        
        -- Move to new target ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á unlock)
        smoothMoveTo(newTargetPos, function()
            lockPositionLayingDown(newTargetPos)
        end)
        
        return true
    end
    
    function unlockPosition()
        if State.positionLockConn then
            State.positionLockConn:Disconnect()
            State.positionLockConn = nil
            print("   üîì Position unlocked")
        end
    end
    
    ----------------------------------------------------------------
    -- MAIN MINING EXECUTION (SMOOTH VERSION)
    ----------------------------------------------------------------
    local function doMineUntilLevel10()
        print("‚õèÔ∏è Objective: Mine until Level 10...")
        
        IsMiningActive = true
        
        print("\n" .. string.rep("=", 50))
        print("‚õèÔ∏è Starting Mining Loop...")
        print(string.rep("=", 50))
        
        while Quest17Active and shouldMine() do
            local char = player.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            
            if not hrp then
                warn("   ‚ö†Ô∏è Waiting for character...")
                task.wait(2)
                continue
            end
            
            -- ‡πÑ‡∏°‡πà cleanup state ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡∏°‡∏µ position lock
            if not State.positionLockConn then
                cleanupState()
            end
            
            -- 1. ‡∏´‡∏≤ Boulder ‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
            local targetRock, dist = findNearestBoulder(State.currentTarget)
            
            if not targetRock then
                warn("   ‚ùå No Boulder found, waiting for respawn...")
                
                -- ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡πÅ‡∏£‡πà ‚Üí unlock position ‡πÅ‡∏•‡πâ‡∏ß‡∏£‡∏≠
                unlockPosition()
                cleanupState()
                
                task.wait(QUEST_CONFIG.RESPAWN_WAIT_TIME)
                continue
            end
            
            local previousTarget = State.currentTarget
            State.currentTarget = targetRock
            State.targetDestroyed = false
            
            -- 2. ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á Underground
            local targetPos = getRockUndergroundPosition(targetRock)
            
            if not targetPos then
                warn("   ‚ùå Cannot get rock position!")
                task.wait(1)
                continue
            end
            
            local currentHP = getRockHP(targetRock)
            local currentLevel = getPlayerLevel()
            
            print(string.format("\nüéØ Target: %s.%s (HP: %d, Dist: %.1f, Level: %d)", 
                targetRock.Parent.Parent.Name,
                targetRock.Parent.Name,
                currentHP, 
                dist,
                currentLevel or 0))
            
            -- 3. Watch HP
            watchRockHP(targetRock)
            
            -- 4. Move to Rock (Smooth Transition)
            if State.positionLockConn and previousTarget ~= targetRock then
                -- ‡∏°‡∏µ position lock ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‚Üí smooth transition
                print("   üîÑ Smooth transition from previous target...")
                transitionToNewTarget(targetPos)
            else
                -- ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ position lock ‚Üí move ‡∏õ‡∏Å‡∏ï‡∏¥
                local moveStarted = false
                smoothMoveTo(targetPos, function()
                    lockPositionLayingDown(targetPos)
                    moveStarted = true
                end)
                
                local timeout = 15
                local startTime = tick()
                while not moveStarted and tick() - startTime < timeout do
                    task.wait(0.1)
                end
                
                if not moveStarted then
                    lockPositionLayingDown(targetPos)
                end
            end
            
            task.wait(0.5)
            
            -- 5. ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Ç‡∏∏‡∏î
            while not State.targetDestroyed and Quest17Active and shouldMine() do
                if not char or not char.Parent then
                    print("   ‚ùå Character died!")
                    break
                end
                
                if not targetRock or not targetRock.Parent then
                    print("   ‚úÖ Target removed!")
                    State.targetDestroyed = true
                    break
                end
                
                if checkMiningError() then
                    print("   ‚ö†Ô∏è Someone else mining! Switching target...")
                    State.targetDestroyed = true
                    if ToolController then
                        ToolController.holdingM1 = false
                    end
                    break
                end
                
                -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ Pickaxe ‡πÉ‡∏ô‡∏°‡∏∑‡∏≠‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                local toolInHand = char:FindFirstChildWhichIsA("Tool")
                local isPickaxeHeld = toolInHand and string.find(toolInHand.Name, "Pickaxe")
                
                if not isPickaxeHeld then
                    -- ‡∏´‡∏¢‡∏∏‡∏î‡∏Ç‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô
                    if ToolController then
                        ToolController.holdingM1 = false
                    end
                    
                    -- ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏° Equip Pickaxe
                    local key = findPickaxeSlotKey()
                    if key then
                        pressKey(key)
                        task.wait(0.3)
                    else
                        -- Fallback: ‡πÉ‡∏ä‡πâ Remote
                        pcall(function()
                            if PlayerController and PlayerController.Replica then
                                local replica = PlayerController.Replica
                                if replica.Data and replica.Data.Inventory and replica.Data.Inventory.Equipments then
                                    for id, item in pairs(replica.Data.Inventory.Equipments) do
                                        if type(item) == "table" and item.Type and string.find(item.Type, "Pickaxe") then
                                            CHAR_RF:InvokeServer({Runes = {}}, item)
                                            break
                                        end
                                    end
                                end
                            end
                        end)
                        task.wait(0.5)
                    end
                else
                    -- ‡∏Ç‡∏∏‡∏î!
                    if ToolController and ToolActivatedFunc then
                        ToolController.holdingM1 = true
                        pcall(function()
                            ToolActivatedFunc(ToolController, toolInHand)
                        end)
                    else
                        -- Fallback
                        pcall(function()
                            TOOL_RF_BACKUP:InvokeServer(toolInHand.Name, true)
                        end)
                    end
                end
                
                task.wait(0.15)
            end
            
            -- 6. ‡∏´‡∏•‡∏±‡∏á‡∏Ç‡∏∏‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à - ‡∏Ñ‡πâ‡∏≤‡∏á Position ‡πÑ‡∏ß‡πâ‡∏Å‡πà‡∏≠‡∏ô (‡πÑ‡∏°‡πà unlock ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ)
            if QUEST_CONFIG.HOLD_POSITION_AFTER_MINE then
                print("   ‚è∏Ô∏è  Holding position, searching for next target...")
                -- ‡πÑ‡∏°‡πà unlock position ‚Üí ‡∏à‡∏∞ transition smooth ‡πÑ‡∏õ‡∏≠‡∏±‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
            else
                unlockPosition()
            end
            
            -- ‡πÄ‡∏ä‡πá‡∏Ñ Level ‡∏´‡∏•‡∏±‡∏á‡∏Ç‡∏∏‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à
            local newLevel = getPlayerLevel()
            if newLevel and newLevel >= QUEST_CONFIG.TARGET_LEVEL then
                print(string.format("\nüéâ Level %d reached! Mining complete!", newLevel))
                break
            end
            
            if DEBUG_MODE then
                print(string.format("   üìä Current Level: %d / %d", newLevel or 0, QUEST_CONFIG.TARGET_LEVEL))
            end
            
            -- ‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏≤‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏ñ‡∏±‡∏î‡πÑ‡∏õ (smooth transition)
            task.wait(0.5)
        end
        
        print("\n" .. string.rep("=", 50))
        print("‚úÖ Mining ended")
        print(string.rep("=", 50))
        
        IsMiningActive = false
        unlockPosition()
        disableNoclip()
        cleanupState()
    end
    
    ----------------------------------------------------------------
    -- SMART QUEST RUNNER
    ----------------------------------------------------------------
    local function RunQuest17()
        print(string.rep("=", 50))
        print("üöÄ QUEST 17: " .. QUEST_CONFIG.QUEST_NAME)
        print("üéØ Objective: Mine until Level 10")
        print(string.format("‚úÖ Strategy: Smooth mining all '%s' in workspace.Rocks", QUEST_CONFIG.ROCK_NAME))
        print(string.rep("=", 50))
        
        -- ‡πÄ‡∏ä‡πá‡∏Ñ Level ‡∏Å‡πà‡∏≠‡∏ô
        print("\nüîç Pre-check: Verifying level requirement...")
        if not shouldMine() then
            print("\n‚úÖ Already Level 10 or higher!")
            print(string.rep("=", 50))
            cleanupState()
            disableNoclip()
            return
        end
        
        -- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ Boulder ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        print("\nüîç Pre-check: Scanning for Boulders...")
        local targetRock, dist = findNearestBoulder()
        
        if not targetRock then
            warn("\n‚ùå No Boulder found in workspace.Rocks!")
            print(string.rep("=", 50))
            cleanupState()
            disableNoclip()
            return
        end
        
        print("   ‚úÖ Found Boulders!")
        
        -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Ç‡∏∏‡∏î
        doMineUntilLevel10()
        
        task.wait(1)
        
        local finalLevel = getPlayerLevel()
        
        if finalLevel and finalLevel >= QUEST_CONFIG.TARGET_LEVEL then
            print("\n" .. string.rep("=", 50))
            print("‚úÖ Quest 17 Complete!")
            print(string.format("   üéâ Final Level: %d", finalLevel))
            print(string.rep("=", 50))
        else
            warn("\n" .. string.rep("=", 50))
            warn("‚ö†Ô∏è Quest 17 incomplete")
            warn(string.format("   üìä Current Level: %d / %d", finalLevel or 0, QUEST_CONFIG.TARGET_LEVEL))
            warn(string.rep("=", 50))
        end
        
        Quest17Active = false
        cleanupState()
        disableNoclip()
    end
    
    ----------------------------------------------------------------
    -- START
    ----------------------------------------------------------------
    RunQuest17()
end

----------------------------------------------------------------
-- QUEST 18 ORIGINAL (from 18.lua)
----------------------------------------------------------------
local function RunQuest18()
    -- QUEST 18: Smart Teleport & Mining + Auto Sell & Auto Buy (FIXED)
    -- ‚úÖ Priority 1: Smart Teleport (‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏π‡πà Island1)
    -- ‚úÖ Priority 2: Auto Sell Init (‡∏ó‡∏≥‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß - ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô)
    -- ‚úÖ Priority 3: Background Tasks (Auto Sell + Auto Buy - ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡∏•‡∏≠‡∏î)
    -- ‚úÖ Priority 4: Mining
    
    
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local Workspace = game:GetService("Workspace")
    
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    ----------------------------------------------------------------
    -- CONFIG
    ----------------------------------------------------------------
    local Quest18Active = true
    local IsMiningActive = false
    local DEBUG_MODE = true
    
    local QUEST_CONFIG = {
        QUEST_NAME = "Smart Teleport & Mining + Auto Sell & Buy",
        REQUIRED_LEVEL = 10,
        
        -- Priority 1: Teleport
        ISLAND_NAME = "Forgotten Kingdom",
        
        -- Priority 2: Auto Sell
        AUTO_SELL_ENABLED = true,
        AUTO_SELL_INTERVAL = 10,
        AUTO_SELL_NPC_NAME = "Greedy Cey",
        
        -- Priority 3: Auto Buy (Background - ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡∏•‡∏≠‡∏î)
        AUTO_BUY_ENABLED = true,
        AUTO_BUY_INTERVAL = 15,
        TARGET_PICKAXE = "Cobalt Pickaxe",
        MIN_GOLD_TO_BUY = 9999,
        SHOP_POSITION = Vector3.new(-165, 22, -111.7),
        
        -- Priority 4: Mining
        ROCK_NAME = "Basalt Rock",
        UNDERGROUND_OFFSET = 4,
        LAYING_ANGLE = 90,
        MOVE_SPEED = 20,
        STOP_DISTANCE = 2,
        
        MINING_PATHS = {
            "Island2CaveStart",
            "Island2CaveDanger1",
            "Island2CaveDanger2",
            "Island2CaveDanger3",
            "Island2CaveDanger4",
            "Island2CaveDangerClosed",
            "Island2CaveDeep",
            "Island2CaveLavaClosed",
            "Island2CaveMid",
        },
        
        WAYPOINTS = {
            Vector3.new(-154.5, 39.1, 138.8),
            Vector3.new(11, 46.5, 124.2),
            Vector3.new(65, 74.2, -44),
        },
        
        WAYPOINT_STOP_DISTANCE = 5,
        MAX_ROCKS_TO_MINE = 10,
        HOLD_POSITION_AFTER_MINE = true,
    }
    
    ----------------------------------------------------------------
    -- KNIT SETUP
    ----------------------------------------------------------------
    local KnitPackage = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit")
    local Knit = require(KnitPackage)
    
    if not Knit.OnStart then 
        pcall(function() Knit.Start():await() end)
    end
    
    local CharacterService = nil
    local PlayerController = nil
    
    pcall(function()
        CharacterService = Knit.GetService("CharacterService")
        PlayerController = Knit.GetController("PlayerController")
    end)
    
    local ToolController = nil
    local ToolActivatedFunc = nil
    
    pcall(function()
        for _, v in pairs(getgc(true)) do
            if type(v) == "table" then
                if rawget(v, "Name") == "ToolController" and rawget(v, "ToolActivated") then
                    ToolController = v
                    ToolActivatedFunc = v.ToolActivated
                    break
                end
            end
        end
    end)
    
    local SERVICES = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services")
    
    local PORTAL_RF = nil
    pcall(function()
        PORTAL_RF = SERVICES:WaitForChild("PortalService", 5):WaitForChild("RF", 3):WaitForChild("TeleportToIsland", 3)
    end)
    
    local CHAR_RF = nil
    pcall(function()
        CHAR_RF = SERVICES:WaitForChild("CharacterService", 5):WaitForChild("RF", 3):WaitForChild("EquipItem", 3)
    end)
    
    local TOOL_RF_BACKUP = nil
    pcall(function()
        TOOL_RF_BACKUP = SERVICES:WaitForChild("ToolService", 5):WaitForChild("RF", 3):WaitForChild("ToolActivated", 3)
    end)
    
    local DIALOGUE_RF = nil
    local DialogueRE = nil
    pcall(function()
        local dialogueService = SERVICES:WaitForChild("DialogueService", 5)
        DIALOGUE_RF = dialogueService:WaitForChild("RF", 3):WaitForChild("RunCommand", 3)
        DialogueRE = dialogueService:WaitForChild("RE", 3):WaitForChild("DialogueEvent", 3)
    end)
    
    local ProximityDialogueRF = nil
    local PURCHASE_RF = nil
    pcall(function()
        local proximityService = SERVICES:WaitForChild("ProximityService", 5)
        ProximityDialogueRF = proximityService:WaitForChild("RF", 3):WaitForChild("Dialogue", 3)
        PURCHASE_RF = proximityService:WaitForChild("RF", 3):WaitForChild("Purchase", 3)
    end)
    
    local FORGES_FOLDER = Workspace:WaitForChild("Forges")
    local MINING_FOLDER_PATH = Workspace:WaitForChild("Rocks")
    
    if PORTAL_RF then print("‚úÖ Portal Remote Ready!") else warn("‚ö†Ô∏è Portal Remote not found") end
    if PlayerController then print("‚úÖ PlayerController Ready!") else warn("‚ö†Ô∏è PlayerController not found") end
    if ToolController then print("‚úÖ ToolController Ready!") else warn("‚ö†Ô∏è ToolController not found") end
    if DIALOGUE_RF then print("‚úÖ Dialogue Remote Ready!") else warn("‚ö†Ô∏è Dialogue Remote not found") end
    if PURCHASE_RF then print("‚úÖ Purchase Remote Ready!") else warn("‚ö†Ô∏è Purchase Remote not found") end
    
    ----------------------------------------------------------------
    -- STATE MANAGEMENT
    ----------------------------------------------------------------
    local State = {
        currentTarget = nil,
        targetDestroyed = false,
        hpWatchConn = nil,
        noclipConn = nil,
        moveConn = nil,
        positionLockConn = nil,
        bodyVelocity = nil,
        bodyGyro = nil,
        
        autoSellTask = nil,
        autoBuyTask = nil,
        isPaused = false,
    }
    
    local AutoSellInitialized = false
    
    local function cleanupState()
        if State.hpWatchConn then State.hpWatchConn:Disconnect() State.hpWatchConn = nil end
        if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.positionLockConn then State.positionLockConn:Disconnect() State.positionLockConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        State.currentTarget = nil
        State.targetDestroyed = false
        
        if ToolController then
            ToolController.holdingM1 = false
        end
    end
    
    ----------------------------------------------------------------
    -- GOLD SYSTEM
    ----------------------------------------------------------------
    local function getGold()
        local goldLabel = playerGui:FindFirstChild("Main")
                         and playerGui.Main:FindFirstChild("Screen")
                         and playerGui.Main.Screen:FindFirstChild("Hud")
                         and playerGui.Main.Screen.Hud:FindFirstChild("Gold")
        
        if not goldLabel or not goldLabel:IsA("TextLabel") then
            return 0
        end
        
        local goldText = goldLabel.Text
        local goldString = string.gsub(goldText, "[$,]", "")
        local gold = tonumber(goldString)
        
        return gold or 0
    end
    
    ----------------------------------------------------------------
    -- INVENTORY CHECK
    ----------------------------------------------------------------
    local function hasPickaxe(pickaxeName)
        if not PlayerController or not PlayerController.Replica then
            return false
        end
        
        local replica = PlayerController.Replica
        if not (replica.Data and replica.Data.Inventory and replica.Data.Inventory.Equipments) then
            return false
        end
        
        for _, item in pairs(replica.Data.Inventory.Equipments) do
            if type(item) == "table" and item.Type == pickaxeName then
                return true
            end
        end
        
        return false
    end
    
    ----------------------------------------------------------------
    -- FORCE CLOSE DIALOG
    ----------------------------------------------------------------
    local function ForceEndDialogueAndRestore()
        local gui = player:FindFirstChild("PlayerGui")
        if gui then
            local dUI = gui:FindFirstChild("DialogueUI")
            if dUI then
                dUI.Enabled = false
                local bb = dUI:FindFirstChild("ResponseBillboard")
                if bb then bb.Visible = false end
            end
        end
        
        local cam = Workspace.CurrentCamera
        if cam then
            cam.CameraType = Enum.CameraType.Custom
            cam.FieldOfView = 70
        end
        
        local char = player.Character
        if char then
            local status = char:FindFirstChild("Status")
            if status then
                for _, tag in ipairs(status:GetChildren()) do
                    if tag.Name == "DisableBackpack" or tag.Name == "NoMovement" or tag.Name == "Talking" then
                        tag:Destroy()
                    end
                end
            end
            
            local humanoid = char:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = 16
                humanoid.JumpPower = 50
            end
        end
        
        if gui then
            local main = gui:FindFirstChild("Main")
            if main then main.Enabled = true end
            
            local backpack = gui:FindFirstChild("BackpackGui")
            if backpack then backpack.Enabled = true end
        end
        
        if DialogueRE then
            pcall(function()
                DialogueRE:FireServer("Closed")
            end)
        end
    end
    
    ----------------------------------------------------------------
    -- AUTO SELL SYSTEM
    ----------------------------------------------------------------
    local function getSellNPC()
        local prox = Workspace:FindFirstChild("Proximity")
        return prox and prox:FindFirstChild(QUEST_CONFIG.AUTO_SELL_NPC_NAME) or nil
    end
    
    local function getSellNPCPos()
        local npc = getSellNPC()
        if not npc then return nil end
        local hrp = npc:FindFirstChild("HumanoidRootPart")
        return hrp and hrp.Position or nil
    end
    
    local function getStashBackground()
        local menu = playerGui:FindFirstChild("Menu")
        if not menu then return nil end
        local f1 = menu:FindFirstChild("Frame")
        if not f1 then return nil end
        local f2 = f1:FindFirstChild("Frame")
        if not f2 then return nil end
        local menus = f2:FindFirstChild("Menus")
        if not menus then return nil end
        local stash = menus:FindFirstChild("Stash")
        if not stash then return nil end
        return stash:FindFirstChild("Background")
    end
    
    local function parseQty(text)
        if not text or text == "" then return 1 end
        local n = string.match(text, "x?(%d+)")
        return tonumber(n) or 1
    end
    
    local function getStashItemsUI()
        local bg = getStashBackground()
        if not bg then return {} end
        
        local basket = {}
        for _, child in ipairs(bg:GetChildren()) do
            if child:IsA("GuiObject") and not string.match(child.Name, "^UI") then
                local qty = 1
                local main = child:FindFirstChild("Main")
                if main then
                    local q = main:FindFirstChild("Quantity")
                    if q and q:IsA("TextLabel") and q.Visible then
                        qty = parseQty(q.Text)
                    end
                end
                basket[child.Name] = qty
            end
        end
        return basket
    end
    
    local function initAutoSellWithNPC()
        if AutoSellInitialized then return true end
        
        print("\n" .. string.rep("=", 60))
        print("üîß INITIALIZING AUTO SELL (ONE-TIME)")
        print(string.rep("=", 60))
        
        local npcPos = getSellNPCPos()
        if not npcPos then
            warn("   ‚ùå NPC not found: " .. QUEST_CONFIG.AUTO_SELL_NPC_NAME)
            return false
        end
        
        print(string.format("   ‚úÖ Found %s at (%.1f, %.1f, %.1f)", 
            QUEST_CONFIG.AUTO_SELL_NPC_NAME, npcPos.X, npcPos.Y, npcPos.Z))
        
        print("   üö∂ Moving to NPC...")
        
        local done = false
        smoothMoveTo(npcPos, function() done = true end)
        
        local t0 = tick()
        while not done and tick() - t0 < 30 do
            task.wait(0.1)
        end
        
        if not done then
            warn("   ‚ùå Failed to reach NPC (timeout)")
            return false
        end
        
        print("   ‚úÖ Reached NPC!")
        task.wait(1)
        
        local npc = getSellNPC()
        if npc and ProximityDialogueRF then
            print("   üí¨ Opening dialog...")
            pcall(function()
                ProximityDialogueRF:InvokeServer(npc)
            end)
        end
        
        task.wait(2)
        
        print("   üö™ Closing dialog...")
        ForceEndDialogueAndRestore()
        
        task.wait(1)
        
        AutoSellInitialized = true
        
        print("\n" .. string.rep("=", 60))
        print("‚úÖ AUTO SELL INITIALIZED!")
        print(string.rep("=", 60))
        
        return true
    end
    
    local function sellAllFromUI()
        if not DIALOGUE_RF then return end
        if not AutoSellInitialized then return end
        
        local basket = getStashItemsUI()
        local hasItem = false
        for _, v in pairs(basket) do
            if v > 0 then hasItem = true break end
        end
        
        if not hasItem then
            if DEBUG_MODE then print("AutoSell: no items") end
            return
        end
        
        local args = { "SellConfirm", { Basket = basket } }
        local ok, res = pcall(function()
            return DIALOGUE_RF:InvokeServer(unpack(args))
        end)
        
        if ok then
            print("üí∞ AutoSell: sold items!")
        else
            warn("AutoSell failed:", res)
        end
    end
    
    local function startAutoSellTask()
        if not QUEST_CONFIG.AUTO_SELL_ENABLED or not DIALOGUE_RF then
            return
        end
        
        print("ü§ñ Auto Sell Background Task Started!")
        
        State.autoSellTask = task.spawn(function()
            while Quest18Active do
                task.wait(QUEST_CONFIG.AUTO_SELL_INTERVAL)
                
                if not State.isPaused then
                    pcall(sellAllFromUI)
                end
            end
        end)
    end
    
    ----------------------------------------------------------------
    -- AUTO BUY SYSTEM (Background - ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡∏•‡∏≠‡∏î)
    ----------------------------------------------------------------
    local function purchasePickaxe(pickaxeName)
        if not PURCHASE_RF then
            warn("Purchase RF missing")
            return false
        end
        
        print(string.format("   üõí Purchasing: %s", pickaxeName))
        
        local ok, res = pcall(function()
            return PURCHASE_RF:InvokeServer(pickaxeName, 1)
        end)
        
        if ok then
            print(string.format("   ‚úÖ Purchased: %s!", pickaxeName))
            return true
        else
            warn(string.format("   ‚ùå Failed: %s", tostring(res)))
            return false
        end
    end
    
    local function tryBuyPickaxe()
        local pickaxeName = QUEST_CONFIG.TARGET_PICKAXE
        
        -- 1. ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
        if hasPickaxe(pickaxeName) then
            if DEBUG_MODE then
                print(string.format("   ‚úÖ Already have: %s", pickaxeName))
            end
            return true
        end
        
        -- 2. ‡πÄ‡∏ä‡πá‡∏Ñ Gold
        local gold = getGold()
        if gold < QUEST_CONFIG.MIN_GOLD_TO_BUY then
            if DEBUG_MODE then
                print(string.format("   ‚è∏Ô∏è  Not enough gold (Need: %d, Have: %d)", 
                    QUEST_CONFIG.MIN_GOLD_TO_BUY, gold))
            end
            return false
        end
        
        -- 3. ‡∏°‡∏µ‡πÄ‡∏á‡∏¥‡∏ô‡∏û‡∏≠ ‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ Pickaxe
        print(string.format("\nüõí Auto Buy: Need %s! (Gold: %d)", pickaxeName, gold))
        
        -- Pause ‡∏ñ‡πâ‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ç‡∏∏‡∏î‡∏≠‡∏¢‡∏π‡πà
        local wasMining = IsMiningActive
        if wasMining then
            State.isPaused = true
            print("   ‚è∏Ô∏è  Pausing mining...")
            
            if ToolController then
                ToolController.holdingM1 = false
            end
            
            unlockPosition()
            task.wait(1)
        end
        
        -- 4. ‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏£‡πâ‡∏≤‡∏ô
        local shopPos = QUEST_CONFIG.SHOP_POSITION
        print(string.format("   üö∂ Going to shop (%.1f, %.1f, %.1f)...", 
            shopPos.X, shopPos.Y, shopPos.Z))
        
        local done = false
        smoothMoveTo(shopPos, function() done = true end)
        
        local t0 = tick()
        while not done and tick() - t0 < 30 do
            task.wait(0.1)
        end
        
        if not done then
            warn("   ‚ö†Ô∏è Failed to reach shop!")
            if wasMining then
                State.isPaused = false
            end
            return false
        end
        
        print("   ‚úÖ Arrived at shop!")
        task.wait(1)
        
        -- 5. ‡∏ã‡∏∑‡πâ‡∏≠
        local purchased = purchasePickaxe(pickaxeName)
        
        if purchased then
            print("   ‚úÖ Purchase complete!")
            task.wait(2)
        else
            warn("   ‚ùå Purchase failed!")
        end
        
        -- Resume mining
        if wasMining then
            print("   ‚ñ∂Ô∏è  Resuming mining...")
            State.isPaused = false
        end
        
        return purchased
    end
    
    local function startAutoBuyTask()
        if not QUEST_CONFIG.AUTO_BUY_ENABLED or not PURCHASE_RF then
            return
        end
        
        print("ü§ñ Auto Buy Background Task Started!")
        
        State.autoBuyTask = task.spawn(function()
            while Quest18Active do
                task.wait(QUEST_CONFIG.AUTO_BUY_INTERVAL)
                
                if State.isPaused then
                    continue
                end
                
                pcall(function()
                    tryBuyPickaxe()
                end)
            end
        end)
    end
    
    ----------------------------------------------------------------
    -- ISLAND DETECTION
    ----------------------------------------------------------------
    local function getCurrentIsland()
        for _, child in ipairs(FORGES_FOLDER:GetChildren()) do
            if child:IsA("Folder") or child:IsA("Model") then
                if string.match(child.Name, "Island%d+") then
                    return child.Name
                end
            end
        end
        return nil
    end
    
    local function needsTeleport()
        local currentIsland = getCurrentIsland()
        
        if not currentIsland then
            return true
        end
        
        if currentIsland == "Island1" then
            print(string.format("   ‚úÖ On %s ‚Üí Need teleport!", currentIsland))
            return true
        elseif currentIsland == "Island2" then
            print(string.format("   ‚úÖ On %s ‚Üí Ready to mine!", currentIsland))
            return false
        else
            warn(string.format("   ‚ö†Ô∏è Unknown: %s", currentIsland))
            return true
        end
    end
    
    ----------------------------------------------------------------
    -- LEVEL SYSTEM
    ----------------------------------------------------------------
    local function getPlayerLevel()
        local levelLabel = playerGui:FindFirstChild("Main")
                          and playerGui.Main:FindFirstChild("Screen")
                          and playerGui.Main.Screen:FindFirstChild("Hud")
                          and playerGui.Main.Screen.Hud:FindFirstChild("Level")
        
        if not levelLabel or not levelLabel:IsA("TextLabel") then
            return nil
        end
        
        local levelText = levelLabel.Text
        local level = tonumber(string.match(levelText, "%d+"))
        
        return level
    end
    
    local function hasRequiredLevel()
        local level = getPlayerLevel()
        
        if not level then
            warn("   ‚ùå Cannot determine level!")
            return false
        end
        
        if level >= QUEST_CONFIG.REQUIRED_LEVEL then
            print(string.format("   ‚úÖ Level %d >= %d", level, QUEST_CONFIG.REQUIRED_LEVEL))
            return true
        else
            print(string.format("   ‚è∏Ô∏è  Level %d < %d", level, QUEST_CONFIG.REQUIRED_LEVEL))
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- HELPER FUNCTIONS
    ----------------------------------------------------------------
    local HOTKEY_MAP = {
        ["1"] = Enum.KeyCode.One,
        ["2"] = Enum.KeyCode.Two,
        ["3"] = Enum.KeyCode.Three,
        ["4"] = Enum.KeyCode.Four,
        ["5"] = Enum.KeyCode.Five,
        ["6"] = Enum.KeyCode.Six,
        ["7"] = Enum.KeyCode.Seven,
        ["8"] = Enum.KeyCode.Eight,
        ["9"] = Enum.KeyCode.Nine,
        ["0"] = Enum.KeyCode.Zero,
    }
    
    local function pressKey(keyCode)
        if not keyCode then return end
        VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
        task.wait(0.05)
        VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
    end
    
    local function findPickaxeSlotKey()
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return nil end
        
        local hotbar = gui:FindFirstChild("BackpackGui") 
                       and gui.BackpackGui:FindFirstChild("Backpack") 
                       and gui.BackpackGui.Backpack:FindFirstChild("Hotbar")
        
        if hotbar then
            for _, slotFrame in ipairs(hotbar:GetChildren()) do
                local frame = slotFrame:FindFirstChild("Frame")
                local label = frame and frame:FindFirstChild("ToolName")
                if label and label:IsA("TextLabel") and string.find(label.Text, "Pickaxe") then
                    return HOTKEY_MAP[slotFrame.Name]
                end
            end
        end
        
        return nil
    end
    
    local function checkMiningError()
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then return false end
        
        local notif = gui:FindFirstChild("Notifications")
        if notif and notif:FindFirstChild("Screen") and notif.Screen:FindFirstChild("NotificationsFrame") then
            for _, child in ipairs(notif.Screen.NotificationsFrame:GetChildren()) do
                local lbl = child:FindFirstChild("TextLabel", true)
                if lbl and string.find(lbl.Text, "Someone else is already mining") then
                    return true
                end
            end
        end
        
        return false
    end
    
    ----------------------------------------------------------------
    -- NOCLIP & MOVEMENT
    ----------------------------------------------------------------
    local function enableNoclip()
        if State.noclipConn then return end
        
        local char = player.Character
        if not char then return end
        
        State.noclipConn = RunService.Stepped:Connect(function()
            if not char or not char.Parent then
                if State.noclipConn then State.noclipConn:Disconnect() State.noclipConn = nil end
                return
            end
            
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end
    
    local function disableNoclip()
        if State.noclipConn then
            State.noclipConn:Disconnect()
            State.noclipConn = nil
        end
    end
    
    function smoothMoveTo(targetPos, callback)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end
        
        if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
        if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
        if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
        
        enableNoclip()
        
        local bv = Instance.new("BodyVelocity")
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Velocity = Vector3.zero
        bv.Parent = hrp
        State.bodyVelocity = bv
        
        local bg = Instance.new("BodyGyro")
        bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        bg.P = 10000
        bg.D = 500
        bg.Parent = hrp
        State.bodyGyro = bg
        
        if DEBUG_MODE then
            print(string.format("   üöÄ Moving to (%.1f, %.1f, %.1f)...", targetPos.X, targetPos.Y, targetPos.Z))
        end
        
        local reachedTarget = false
        
        State.moveConn = RunService.Heartbeat:Connect(function()
            if reachedTarget then return end
            
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                if bv and bv.Parent then bv:Destroy() end
                if bg and bg.Parent then bg:Destroy() end
                State.bodyVelocity = nil
                State.bodyGyro = nil
                return
            end
            
            local currentPos = hrp.Position
            local direction = (targetPos - currentPos)
            local distance = direction.Magnitude
            
            if distance < QUEST_CONFIG.STOP_DISTANCE then
                if DEBUG_MODE then
                    print(string.format("   ‚úÖ Reached! (%.1f)", distance))
                end
                
                reachedTarget = true
                
                bv.Velocity = Vector3.zero
                hrp.Velocity = Vector3.zero
                hrp.AssemblyLinearVelocity = Vector3.zero
                
                task.wait(0.1)
                
                if bv and bv.Parent then bv:Destroy() end
                if bg and bg.Parent then bg:Destroy() end
                State.bodyVelocity = nil
                State.bodyGyro = nil
                
                if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
                
                if callback then callback() end
                return
            end
            
            local speed = math.min(QUEST_CONFIG.MOVE_SPEED, distance * 10)
            local velocity = direction.Unit * speed
            
            bv.Velocity = velocity
            bg.CFrame = CFrame.lookAt(currentPos, targetPos)
        end)
        
        return true
    end
    
    ----------------------------------------------------------------
    -- POSITION LOCK
    ----------------------------------------------------------------
    local function lockPositionLayingDown(targetPos)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        if State.positionLockConn then
            State.positionLockConn:Disconnect()
            State.positionLockConn = nil
        end
        
        local angle = math.rad(QUEST_CONFIG.LAYING_ANGLE)
        local baseCFrame = CFrame.new(targetPos)
        local layingCFrame = baseCFrame * CFrame.Angles(angle, 0, 0)
        
        State.positionLockConn = RunService.Heartbeat:Connect(function()
            if not char or not char.Parent or not hrp or not hrp.Parent then
                if State.positionLockConn then
                    State.positionLockConn:Disconnect()
                    State.positionLockConn = nil
                end
                return
            end
            
            hrp.CFrame = layingCFrame
            hrp.Velocity = Vector3.zero
            hrp.AssemblyLinearVelocity = Vector3.zero
        end)
        
        if DEBUG_MODE then
            print("   üîí Position locked")
        end
    end
    
    local function transitionToNewTarget(newTargetPos)
        if State.positionLockConn then
            State.positionLockConn:Disconnect()
            State.positionLockConn = nil
        end
        
        smoothMoveTo(newTargetPos, function()
            lockPositionLayingDown(newTargetPos)
        end)
        
        return true
    end
    
    function unlockPosition()
        if State.positionLockConn then
            State.positionLockConn:Disconnect()
            State.positionLockConn = nil
            if DEBUG_MODE then
                print("   üîì Position unlocked")
            end
        end
    end
    
    ----------------------------------------------------------------
    -- WAYPOINT NAVIGATION
    ----------------------------------------------------------------
    local function navigateWaypoints(waypoints)
        print("\nüó∫Ô∏è  Waypoint Navigation...")
        
        for i, waypoint in ipairs(waypoints) do
            print(string.format("\nüìç Waypoint %d/%d", i, #waypoints))
            
            local moveComplete = false
            smoothMoveTo(waypoint, function()
                moveComplete = true
            end)
            
            local timeout = 30
            local startTime = tick()
            while not moveComplete and tick() - startTime < timeout do
                task.wait(0.1)
            end
            
            if State.moveConn then State.moveConn:Disconnect() State.moveConn = nil end
            if State.bodyVelocity then State.bodyVelocity:Destroy() State.bodyVelocity = nil end
            if State.bodyGyro then State.bodyGyro:Destroy() State.bodyGyro = nil end
            
            if not moveComplete then
                warn(string.format("   ‚ö†Ô∏è Waypoint %d timeout", i))
                return false
            end
            
            print(string.format("   ‚úÖ Waypoint %d done!", i))
            task.wait(0.5)
        end
        
        print("\n‚úÖ All waypoints done!")
        return true
    end
    
    ----------------------------------------------------------------
    -- ROCK HELPERS
    ----------------------------------------------------------------
    local function getRockUndergroundPosition(rockModel)
        if not rockModel or not rockModel.Parent then
            return nil
        end
        
        local pivotCFrame = nil
        pcall(function()
            if rockModel.GetPivot then
                pivotCFrame = rockModel:GetPivot()
            elseif rockModel.WorldPivot then
                pivotCFrame = rockModel.WorldPivot
            end
        end)
        
        if pivotCFrame then
            local pos = pivotCFrame.Position
            return Vector3.new(pos.X, pos.Y - QUEST_CONFIG.UNDERGROUND_OFFSET, pos.Z)
        end
        
        if rockModel.PrimaryPart then
            local pos = rockModel.PrimaryPart.Position
            return Vector3.new(pos.X, pos.Y - QUEST_CONFIG.UNDERGROUND_OFFSET, pos.Z)
        end
        
        local part = rockModel:FindFirstChildWhichIsA("BasePart")
        if part then
            local pos = part.Position
            return Vector3.new(pos.X, pos.Y - QUEST_CONFIG.UNDERGROUND_OFFSET, pos.Z)
        end
        
        return nil
    end
    
    local function getRockHP(rock)
        if not rock or not rock.Parent then
            return 0
        end
        
        local success, result = pcall(function()
            return rock:GetAttribute("Health") or 0
        end)
        
        return success and result or 0
    end
    
    local function isTargetValid(rock)
        if not rock or not rock.Parent then
            return false
        end
        
        if not rock:FindFirstChildWhichIsA("BasePart") then
            return false
        end
        
        local hp = getRockHP(rock)
        return hp > 0
    end
    
    local function findNearestBasaltRock(excludeRock)
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return nil end
        
        local targetRock, minDist = nil, math.huge
        
        for _, pathName in ipairs(QUEST_CONFIG.MINING_PATHS) do
            local folder = MINING_FOLDER_PATH:FindFirstChild(pathName)
            
            if folder then
                for _, child in ipairs(folder:GetChildren()) do
                    if child:IsA("SpawnLocation") or child.Name == "SpawnLocation" then
                        local rock = child:FindFirstChild(QUEST_CONFIG.ROCK_NAME)
                        
                        if rock ~= excludeRock and isTargetValid(rock) then
                            local pos = getRockUndergroundPosition(rock)
                            if pos then
                                local dist = (pos - hrp.Position).Magnitude
                                
                                if dist < minDist then
                                    minDist = dist
                                    targetRock = rock
                                end
                            end
                        end
                    end
                end
            end
        end
        
        return targetRock, minDist
    end
    
    local function watchRockHP(rock)
        if State.hpWatchConn then
            State.hpWatchConn:Disconnect()
        end
        
        if not rock then return end
        
        State.hpWatchConn = rock:GetAttributeChangedSignal("Health"):Connect(function()
            local hp = rock:GetAttribute("Health") or 0
            
            if hp <= 0 then
                print("   ‚úÖ Rock destroyed!")
                State.targetDestroyed = true
                
                if ToolController then
                    ToolController.holdingM1 = false
                end
            end
        end)
    end
    
    ----------------------------------------------------------------
    -- TELEPORT SYSTEM
    ----------------------------------------------------------------
    local function teleportToIsland(islandName)
        if not PORTAL_RF then
            warn("   ‚ùå Portal Remote not available!")
            return false
        end
        
        print(string.format("   üåÄ Teleporting to: %s", islandName))
        
        local args = {islandName}
        
        local success, result = pcall(function()
            return PORTAL_RF:InvokeServer(unpack(args))
        end)
        
        if success then
            print(string.format("   ‚úÖ Teleported to: %s", islandName))
            return true
        else
            warn(string.format("   ‚ùå Failed: %s", tostring(result)))
            return false
        end
    end
    
    ----------------------------------------------------------------
    -- MINING EXECUTION
    ----------------------------------------------------------------
    local function doMineBasaltRock()
        print("\n‚õèÔ∏è Mining Started...")
        print(string.format("   Target: %d rocks", QUEST_CONFIG.MAX_ROCKS_TO_MINE))
        
        IsMiningActive = true
        
        local miningCount = 0
        
        print("\n" .. string.rep("=", 50))
        print("‚õèÔ∏è Mining Loop...")
        print(string.rep("=", 50))
        
        while Quest18Active and miningCount < QUEST_CONFIG.MAX_ROCKS_TO_MINE do
            if State.isPaused then
                print("   ‚è∏Ô∏è  Paused (Auto Buy running)...")
                task.wait(2)
                continue
            end
            
            local char = player.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            
            if not hrp then
                warn("   ‚ö†Ô∏è Waiting for character...")
                task.wait(2)
                continue
            end
            
            if not State.positionLockConn then
                cleanupState()
            end
            
            local targetRock, dist = findNearestBasaltRock(State.currentTarget)
            
            if not targetRock then
                warn("   ‚ùå No rocks found!")
                unlockPosition()
                cleanupState()
                task.wait(3)
                continue
            end
            
            local previousTarget = State.currentTarget
            State.currentTarget = targetRock
            State.targetDestroyed = false
            
            local targetPos = getRockUndergroundPosition(targetRock)
            
            if not targetPos then
                warn("   ‚ùå Cannot get position!")
                task.wait(1)
                continue
            end
            
            local currentHP = getRockHP(targetRock)
            
            print(string.format("\nüéØ Target #%d: %s (HP: %d, Dist: %.1f)", 
                miningCount + 1,
                targetRock.Parent.Parent.Name,
                currentHP, 
                dist))
            
            watchRockHP(targetRock)
            
            if State.positionLockConn and previousTarget ~= targetRock then
                transitionToNewTarget(targetPos)
            else
                local moveStarted = false
                smoothMoveTo(targetPos, function()
                    lockPositionLayingDown(targetPos)
                    moveStarted = true
                end)
                
                local timeout = 15
                local startTime = tick()
                while not moveStarted and tick() - startTime < timeout do
                    task.wait(0.1)
                end
                
                if not moveStarted then
                    lockPositionLayingDown(targetPos)
                end
            end
            
            task.wait(0.5)
            
            while not State.targetDestroyed and Quest18Active and not State.isPaused do
                if not char or not char.Parent then
                    break
                end
                
                if not targetRock or not targetRock.Parent then
                    State.targetDestroyed = true
                    break
                end
                
                if checkMiningError() then
                    State.targetDestroyed = true
                    if ToolController then
                        ToolController.holdingM1 = false
                    end
                    break
                end
                
                local toolInHand = char:FindFirstChildWhichIsA("Tool")
                local isPickaxeHeld = toolInHand and string.find(toolInHand.Name, "Pickaxe")
                
                if not isPickaxeHeld then
                    if ToolController then
                        ToolController.holdingM1 = false
                    end
                    
                    local key = findPickaxeSlotKey()
                    if key then
                        pressKey(key)
                        task.wait(0.3)
                    else
                        pcall(function()
                            if PlayerController and PlayerController.Replica then
                                local replica = PlayerController.Replica
                                if replica.Data and replica.Data.Inventory and replica.Data.Inventory.Equipments then
                                    for id, item in pairs(replica.Data.Inventory.Equipments) do
                                        if type(item) == "table" and item.Type and string.find(item.Type, "Pickaxe") then
                                            CHAR_RF:InvokeServer({Runes = {}}, item)
                                            break
                                        end
                                    end
                                end
                            end
                        end)
                        task.wait(0.5)
                    end
                else
                    if ToolController and ToolActivatedFunc then
                        ToolController.holdingM1 = true
                        pcall(function()
                            ToolActivatedFunc(ToolController, toolInHand)
                        end)
                    else
                        pcall(function()
                            TOOL_RF_BACKUP:InvokeServer(toolInHand.Name, true)
                        end)
                    end
                end
                
                task.wait(0.15)
            end
            
            if QUEST_CONFIG.HOLD_POSITION_AFTER_MINE then
                -- Hold position
            else
                unlockPosition()
            end
            
            if State.targetDestroyed then
                miningCount = miningCount + 1
                print(string.format("\n‚úÖ Mined! (%d/%d)", miningCount, QUEST_CONFIG.MAX_ROCKS_TO_MINE))
            end
            
            task.wait(0.5)
        end
        
        print("\n" .. string.rep("=", 50))
        print("‚úÖ Mining complete!")
        print(string.format("   Total: %d rocks", miningCount))
        print(string.rep("=", 50))
        
        IsMiningActive = false
        unlockPosition()
        disableNoclip()
        cleanupState()
    end
    
    ----------------------------------------------------------------
    -- MAIN QUEST EXECUTION
    ----------------------------------------------------------------
    local function RunQuest18()
        print(string.rep("=", 60))
        print("üöÄ QUEST 18: " .. QUEST_CONFIG.QUEST_NAME)
        print(string.rep("=", 60))
        print("üìã System:")
        print("   1. Smart Teleport (if Island1)")
        print("   2. Auto Sell Init (one-time)")
        print("   3. Background Tasks (Auto Sell + Auto Buy)")
        print("   4. Mining")
        print(string.rep("=", 60))
        
        -- Level Check
        print("\nüíé Checking level...")
        if not hasRequiredLevel() then
            warn("\n‚ùå Level requirement not met!")
            return
        end
        
        -- Priority 1: Teleport Check
        print("\n" .. string.rep("=", 60))
        print("PRIORITY 1: SMART TELEPORT")
        print(string.rep("=", 60))
        
        local shouldTeleport = needsTeleport()
        
        if shouldTeleport then
            print("\nüåÄ Teleporting...")
            task.wait(1)
            
            local success = teleportToIsland(QUEST_CONFIG.ISLAND_NAME)
            
            if success then
                print("\n‚úÖ Teleported!")
                task.wait(2)
            else
                warn("\n‚ùå Teleport failed!")
            end
            
            print("\n" .. string.rep("=", 60))
            print("‚úÖ Quest 18 Complete!")
            print(string.rep("=", 60))
            return
        end
        
        print("\n‚úÖ Already on Island2!")
        
        -- Priority 2: Auto Sell Init (‡∏£‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô)
        print("\n" .. string.rep("=", 60))
        print("PRIORITY 2: AUTO SELL INITIALIZATION")
        print(string.rep("=", 60))
        
        if QUEST_CONFIG.AUTO_SELL_ENABLED and DIALOGUE_RF then
            local initSuccess = initAutoSellWithNPC()
            
            if not initSuccess then
                warn("\n‚ö†Ô∏è Auto Sell init failed! Continuing anyway...")
            end
        else
            print("\n‚ö†Ô∏è Auto Sell disabled or Remote not found")
        end
        
        task.wait(2)
        
        -- Priority 3: Background Tasks
        print("\n" .. string.rep("=", 60))
        print("PRIORITY 3: BACKGROUND TASKS")
        print(string.rep("=", 60))
        
        print("\nü§ñ Starting background tasks...")
        startAutoSellTask()
        startAutoBuyTask()
        
        print("\n‚úÖ Background tasks started!")
        task.wait(2)
        
        -- Priority 4: Mining
        print("\n" .. string.rep("=", 60))
        print("PRIORITY 4: MINING")
        print(string.rep("=", 60))
        
        print("\nüó∫Ô∏è  Navigating to mining area...")
        local waypointSuccess = navigateWaypoints(QUEST_CONFIG.WAYPOINTS)
        
        if not waypointSuccess then
            warn("\n‚ö†Ô∏è Waypoint failed!")
        else
            print("\n‚úÖ Waypoints done!")
        end
        
        task.wait(1)
        
        doMineBasaltRock()
        
        print("\n" .. string.rep("=", 60))
        print("‚úÖ Quest 18 Complete!")
        print(string.rep("=", 60))
        
        Quest18Active = false
        cleanupState()
        disableNoclip()
    end
    
    ----------------------------------------------------------------
    -- START
    ----------------------------------------------------------------
    RunQuest18()
end

----------------------------------------------------------------
-- AUTO RUNNER
----------------------------------------------------------------

local QUEST_DELAY_BETWEEN = 1.5

local QuestOrder = {
    { id =  1, fn = RunQuest01 },
    { id =  2, fn = RunQuest02 },
    { id =  3, fn = RunQuest03 },
    { id =  4, fn = RunQuest04 },
    { id =  5, fn = RunQuest05 },
    { id =  6, fn = RunQuest06 },
    { id =  7, fn = RunQuest07 },
    { id =  8, fn = RunQuest08 },
    { id =  9, fn = RunQuest09 },
    { id = 10, fn = RunQuest10 },
    { id = 11, fn = RunQuest11 },
    { id = 12, fn = RunQuest12 },
    { id = 13, fn = RunQuest13 },
    { id = 14, fn = RunQuest14 },
    -- Quest 15 ‡∏à‡∏∞‡∏£‡∏±‡∏ô‡πÅ‡∏ö‡∏ö background ‡∏ó‡∏∏‡∏Å ‡πÜ 10 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á
    { id = 16, fn = RunQuest16 },
    { id = 17, fn = RunQuest17 },
    { id = 18, fn = RunQuest18 },
}

-- Quest 15: ‡∏£‡∏±‡∏ô‡∏ã‡πâ‡∏≥‡∏ó‡∏∏‡∏Å ‡πÜ 10 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ‡πÅ‡∏ï‡πà‡πÉ‡∏ä‡πâ logic ‡πÄ‡∏î‡∏¥‡∏°‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå 15.lua
task.spawn(function()
    while true do
        local ok, err = pcall(RunQuest15)
        if not ok then
            warn(string.format("[QUEST-AUTO] Quest 15 error: %s", tostring(err)))
        end
        task.wait(10)
    end
end)

-- Linear Runner: ‡∏ß‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ï‡∏≤‡∏°‡∏•‡∏≥‡∏î‡∏±‡∏ö 1,2,3,...,18 ‡πÅ‡∏•‡πâ‡∏ß loop
task.spawn(function()
    print("[QUEST-AUTO] ===== Linear Auto Runner (Original) START =====")
    while true do
        for _, q in ipairs(QuestOrder) do
            local ok, err = pcall(q.fn)
            if not ok then
                warn(string.format("[QUEST-AUTO] Quest %d error: %s", q.id, tostring(err)))
            end
            task.wait(QUEST_DELAY_BETWEEN)
        end
    end
end)
